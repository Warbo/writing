\section{Contributions}
\label{current}

\iffalse
TODO
Good analysis of differences with ML4PG/ACL2ML
\fi

\subsection{Recurrent Clustering}
\label{recurrentclustering}

We take the \emph{recurrent clustering} approach found in ML4PG and ACL2(ml), and implement a variant in the context of Haskell theory exploration. Here we give a brief description of recurrent clustering, describe our algorithm, and compare its similarity and differences to ML4PG and ACL2(ml).

\subsubsection{Overview}

The purpose of recurrent clustering, as with other clustering algorithms, is to identify similarities between a set of inputs. In our case, we want compare the abstract syntax trees of Core expressions, which presents a difficulty for clustering: many leaves are \emph{references}, containing identifiers for other expressions. For example, consider the following expressions which are identical except for an identifier:\footnote{The \texttt{(\&\&)} function is boolean AND, \texttt{(++)} appends lists and \texttt{map} applies a function to the elements of a list.}

\begin{equation*}
  \begin{split}
    X =\ & \texttt{App}\ (\texttt{Var}\ (\texttt{Local}\ \texttt{"f"}))\ (\texttt{Var}\ (\texttt{Global}\ \texttt{"base:Prelude.(\&\&)"})) \\
    Y =\ & \texttt{App}\ (\texttt{Var}\ (\texttt{Local}\ \texttt{"f"}))\ (\texttt{Var}\ (\texttt{Global}\ \texttt{"base:Prelude.(++)"})) \\
    Z =\ & \texttt{App}\ (\texttt{Var}\ (\texttt{Local}\ \texttt{"f"}))\ (\texttt{Var}\ (\texttt{Global}\ \texttt{"base:Prelude.map"}))
  \end{split}
\end{equation*}

Two simple methods for comparison are to ignore identifiers completely, or to compare them for equality. Neither is completely satisfactory, as the former will \emph{over-estimate} similarity (considering $X$, $Y$ and $Z$ to be the same), whilst the latter will \emph{under-estimate} similarity (considering $X$, $Y$ and $Z$ to be equidistant).

Ideally we would like something in between these two extremes, which requires a more sophisticated notion of similarity for identifiers. In the above example, we may intuitively consider \texttt{(\&\&)} and \texttt{(++)} to be closer to each other than to \texttt{map}; both in terms of \emph{definition} (e.g. only the former can be specified by pattern-matching on their first argument), and by their \emph{properties} (e.g. only the former can form monoids).

Recurrent clustering tackles this problem in a straightforward way: we look up the expressions \emph{referenced by} each identifier, and use \emph{their} similarity in place of the identifiers'. This gives rise to a recursive process, where feature extraction is interleaved with multiple rounds of clustering. For this recursive process to be well-founded, we impose a topological ordering on expressions based on their dependencies (the expressions they reference). This is slightly complicated in Haskell (compared to Coq, for example), since general recursion is permitted and several mutually-recursive expressions may appear at the same level.

\subsubsection{Algorithm}

\begin{figure}
  \begin{haskell}
    type Env = [Local]
    type Db  = [(Global, Int)]

    data RoseTree a = Rose a [RoseTree a]

    exprTree :: Env -> Db -> Expr -> RoseTree Int
    exprTree env db e = case e of
      Var (Global i) -> Rose (fromMaybe sUNKNOWN (lookup db  i)) []
      Var (Local  i) -> Rose (fromMaybe sUNKNOWN (lookup env i)) []
      Lit (LitNum _) -> Rose (sLITNUM) []
      Lit (LitStr _) -> Rose (sLITSTR) []
      App  e1 e2     -> Rose (sAPP) [exprTree    env  db e1,
                                     exprTree    env  db e2]
      Lam  i  e      -> Rose (sLAM) [exprTree (i:env) db e1]
      Let  bs e      -> Rose (sLET)
      Case e i alts  -> Rose (sCASE) (exprTree env db e : map (altTree (i:env) db) alts)

    altTree :: Env -> Db -> Alt -> Rose Int
    altTree env db alt = case alt of
      (DataAlt _, vs, e) -> exprTree (vs ++ env) db e
      (LitAlt  _, _,  e) -> exprTree env db e
      (Default,   _,  e) -> exprTree env db e

    closedTree :: Db -> Core -> RoseTree Int
    closedTree = exprTree []
  \end{haskell}
  \caption{Feature extraction for Haskell Core, using recurrent clustering an k-means.}
  \label{featureextractionalgorithm}
\end{figure}

Our feature extraction algorithm is given in figure \ref{featureextractionalgorithm}. Here we highlight some key features:

\begin{itemize}
  \item Since they are comparatively rare, we ignore the particular value of each literal.
  \item Since we are currently focused on expressions, we ignore particular data constructors and types.
  \item If we cannot find a particular identifier, we use the sentinel value \hs{sUNKNOWN}. In practice, this only occurs for mutually-recursive references, since the toplogical sort will populate the \hs{db} with all other global identifiers, and local identifiers which don't occur in the environment would be rejected as invalid Haskell before the translation to Core.
  \item
\end{itemize}

\subsubsection{Comparison}

Our algorithm is most similar to that of ML4PG, as our transformation maps each element in a tree to a distinct cell in its matrix. In contrast, the matrices produced by ACL2(ml) \emph{summarise} the tree elements: providing, for each level of the tree, the number of variables, nullary symbols, unary symbols, etc.

There are two major differences between our algorithm and that of ML4PG: mutual-recursion and types.

The special handling required for mutual recursion is discussed above (namely, topological sorting of expressions and the \hs{sUNKNOWN} sentinel). Such handling is not present in ML4PG, since the Coq code it analyses must, by virtue of the language, be written in dependency order to begin with. Coq \emph{does} have limited support for mutually-recursive functions, of the following form:

\begin{coqblock}
Fixpoint even n := match n with
                       | O   => true
                       | S m => odd m
                   end
    with odd  n := match n with
                       | O   => false
                       | S m => even m
                   end.
\end{coqblock}

However, this is relatively uncommon and unsupported by ML4PG.

\iffalse
TODO
Replacing mutually-recursive calls (i.e. unknown global references) by the \hs{sUNKNOWN} sentinel, has the effect of denotes an has a similar effect to a consistently
\fi

The more interesting differences come from our handling (or lack thereof) for types. Coq and ACL2 are at opposite ends of the typing spectrum, with the former treating types as first class entities of the language whilst the latter is untyped (or \emph{unityped}). In both cases, we have a \emph{single} language to analyse, by ML4PG and ACL2(ml) respectively.\footnote{ML4PG can also analyse Coq's \textsc{Ltac} meta-language. Haskell has its own meta-language, Template Haskell, but here we only consider the regular Haskell which it generates.}

The situation is different for Haskell, where the type level is distinct from the value level, and there are strict rules for how they can influence each other. In particular, Haskell values can depend on types (via the type class mechanism) but types cannot depend on values.

In our initial approach, we restrict ourselves to the value level. This has several consequences:

\begin{itemize}
  \item We cannot distinguish between data constructors, other than using exact equality.
  \item The arity of Since Core uses a single \texttt{Lam} abstraction for both value- and type-level parameters, there may be spurious after erasure rather than the Our Core expressions may contain type-level operation
\end{itemize}

effectively a collection contains  As a sub-set of Common Lisp, ACL2 is an untyped language; whilst Coq makes heavy use of types as first-class values.  Haskell differs from both (the ACL2 sub-set of) Common Lisp and Coq (by ML4PG) analyses an untyped language, Haskell effectively lives between the two extremes of untyped programming (as analysed by ACL2(ml)) and dependently typed programming (Coq (which is dependently typed) a sense, Haskell ACL2(ml)

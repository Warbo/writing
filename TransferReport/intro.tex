\section{Introduction}

\iffalse
TODO
Intro + motivation

About 2 pages

Haskell is a mainstream FP language (motivation)

QuickCheck (example)

How to come up with the properties

Mention theory exploration
\fi

\iffalse TODO: sounds strange... what does it mean for software to be capable or uncapable? of what? Rephrase? \fi As computers and software become more capable, and as our reliance on them increases, the importance of \emph{understanding}, \emph{predicting} and \emph{verifying} these systems grows; which is undermined by their ever-increasing complexity. The \emph{functional programming} paradigm has been proposed for addressing these issues \cite{hughes1989functional}, in part by constructing programs which are more amenable to mathematical analysis. \iffalse TODO: I am not sure the example makes sense without explaining what effects are and why separating them helps. Rather than going there, perhaps just say about declarative style of programming and types expressing prperties of computations? \fi For example, by separating \emph{computation} from \emph{effects}, we can analyse each in isolation; in particular, pure computations can be evaluated without fear of damaging side-effects, and results are repeatable (since there can be no dependence on external state).

Whilst use of pure functional programming languages, like Haskell and Idris, is relatively rare, their features are well suited to common software engineering practices like \emph{unit testing}; where tasks are broken down into small, easily-specified ``units'', and tested in isolation for a variety of use-cases. Functional ideas are thus spreading to mainstream software engineering in a more dilute form; seen, for example, in the recent inclusion of first-class functions in Java \cite{gosling2015java} and C++ \cite{willcock2006lambda}.

Functional programming is also well suited to less-widespread practices, such as \emph{property checking} (as popularised by \qcheck{}) and \emph{theorem proving}, which are promising methods for increasing confidence in software, yet can be prohibitively expensive. Here we investigate how the recent \emph{theory exploration} approach can lower the effort required to pursue these goals, and in particular how machine learning techniques can mitigate the costs of the combinatorial algorithms involved.

Our contributions are:

\begin{itemize}
  \item A framework for applying theory exploration tools such as \qspec{} to Haskell's existing package system.
  \item A feature extraction method for transforming Haskell expressions into a form amenable to off-the-shelf machine learning algorithms. \iffalse TODO: say how this item fits in the TE agenda. \fi
  \item A comparison of our methods with existing approaches, both for theory exploration in Haskell, and for machine learning in other languages.
\end{itemize}

We begin in \S \ref{sec:background} by providing a formal context for analysing Haskell expressions (\S \ref{sec:haskell}) and the results of theory exploration systems like \qspec{} (\S \ref{sec:theoryexploration}). We give a brief overview of testing approaches and how they relate to Haskell (\S \ref{sec:quickcheck}), as well as the machine learning approaches we are building on (\S \ref{sec:featureextraction}). We discuss our contributions in more depth in \S \ref{sec:contributions}, and provide implementation details \S \ref{sec:implementation}. A variety of related work is surveyed in \S \ref{sec:related}, and we give several potential directions for future research in \S \ref{sec:future} before concluding in \S \ref{sec:conclusion}.

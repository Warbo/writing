\section{Introduction}

\iffalse
TODO
Intro + motivation

About 2 pages

Haskell is a mainstream FP language (motivation)

QuickCheck (example)

How to come up with the properties

Mention theory exploration
\fi

As computers and software become more capable, and as our reliance on them increases, the importance of \emph{understanding}, \emph{predicting} and \emph{verifying} these systems grows; which is undermined by their ever-increasing complexity. The \emph{functional programming} paradigm has been proposed for addressing these issues \cite{hughes1989functional}, in part by constructing programs which are more amenable to mathematical analysis. For example, by separating \emph{computation} from \emph{effects}, we can analyse each in isolation; in particular, pure computations can be evaluated without fear of damaging side-effects, and results are repeatable (since there can be no dependence on external state).

Whilst use of pure functional programming languages, like Haskell and Idris, is relatively rare, their features are well suited to common software engineering practices like \emph{unit testing}; where tasks are broken down into small, easily-specified ``units'', and tested in isolation for a variety of use-cases. Functional ideas are thus spreading to mainstream software engineering in a more dilute form; seen, for example, in the recent inclusion of first-class functions in Java \cite{gosling2015java} and C++ \cite{willcock2006lambda}.

Functional programming is also well suited to more radical practices, such as \emph{property checking} and \emph{theorem proving}, which are promising methods for increasing confidence in software, yet are currently prohibitively expensive. Here we investigate how the recent \emph{theory exploration} approach can lower the effort required to pursue these goals, and in particular how machine learning techniques can mitigate the costs of the combinatorial algorithms involved.

\iffalse
TODO
Our contributions are:

\begin{itemize}
  \item A framework for applying theory exploration tools such as \qspec{} to Haskell's existing package system.
  \item A
\end{itemize}
\fi

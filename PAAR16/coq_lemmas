Lemma le_exists_sub : forall n m, n<=m -> exists p, m == p+n /\ 0<=p.
Lemma pow_sqr : forall (x:R) (i:nat), x ^ (2 * i) = (x * x) ^ i.
Lemma A1_cvg : forall x:R, Un_cv (A1 x) (cos x).
Lemma C1_cvg : forall x y:R, Un_cv (C1 x y) (cos (x + y)).
Lemma B1_cvg : forall x:R, Un_cv (B1 x) (sin x).
Lemma JMeq_sym : forall (A B:Type) (x:A) (y:B), JMeq x y -> JMeq y x.
Lemma JMeq_trans : forall (A B C:Type) (x:A) (y:B) (z:C), JMeq x y -> JMeq y z -> JMeq x z.
Lemma JMeq_ind : forall (A:Type) (x:A) (P:A -> Prop), P x -> forall y, JMeq x y -> P y.
Lemma JMeq_rec : forall (A:Type) (x:A) (P:A -> Set), P x -> forall y, JMeq x y -> P y.
Lemma JMeq_rect : forall (A:Type) (x:A) (P:A->Type), P x -> forall y, JMeq x y -> P y.
Lemma JMeq_ind_r : forall (A:Type) (x:A) (P:A -> Prop),  P x -> forall y, JMeq y x -> P y.
Lemma JMeq_rec_r : forall (A:Type) (x:A) (P:A -> Set),  P x -> forall y, JMeq y x -> P y.
Lemma JMeq_rect_r : forall (A:Type) (x:A) (P:A -> Type),  P x -> forall y, JMeq y x -> P y.
Lemma JMeq_congr : forall (A:Type) (x:A) (B:Type) (f:A->B) (y:A), JMeq x y -> f x = f y.
Lemma JMeq_eq_dep_id : forall (A B:Type) (x:A) (y:B), JMeq x y -> eq_dep Type (fun X => X) A x B y.
Lemma eq_dep_id_JMeq : forall (A B:Type) (x:A) (y:B), eq_dep Type (fun X => X) A x B y -> JMeq x y.
Lemma eq_dep_JMeq : forall U P p x q y, eq_dep U P p x q y -> JMeq x y.
Lemma eq_dep_strictly_stronger_JMeq : exists U P p q x y, JMeq x y /\ ~ eq_dep U P p x q y.
Lemma JMeq_eq_dep :  forall U (P:U->Prop) p q (x:P p) (y:P q),  p = q -> JMeq x y -> eq_dep U P p x q y.
Lemma multiplicity_In :   forall l a, In a l <-> 0 < multiplicity (list_contents l) a.
Lemma multiplicity_In_O :   forall l a, ~ In a l -> multiplicity (list_contents l) a = 0.
Lemma multiplicity_In_S :   forall l a, In a l -> multiplicity (list_contents l) a >= 1.
Lemma multiplicity_NoDup :   forall l, NoDup l <-> (forall a, multiplicity (list_contents l) a <= 1).
Lemma NoDup_permut :   forall l l', NoDup l -> NoDup l' ->     (forall x, In x l <-> In x l') -> permutation l l'.
Lemma permut_In_In :   forall l1 l2 e, permutation l1 l2 -> In e l1 -> In e l2.
Lemma permut_cons_In :   forall l1 l2 e, permutation (e :: l1) l2 -> In e l2.
Lemma permut_nil :   forall l, permutation l nil -> l = nil.
Lemma permutation_Permutation :   forall l l', Permutation l l' <-> permutation l l'.
Lemma permut_length_1:   forall a b, permutation (a :: nil) (b :: nil)  -> a=b.
Lemma permut_length_2 :   forall a1 b1 a2 b2, permutation (a1 :: b1 :: nil) (a2 :: b2 :: nil) ->     (a1=a2) /\ (b1=b2) \/ (a1=b2) /\ (a2=b1).
Lemma permut_length :   forall l1 l2, permutation l1 l2 -> length l1 = length l2.
Lemma permutation_map :   forall f l1 l2, permutation l1 l2 ->     PermutSetoid.permutation _ eqB_dec (map f l1) (map f l2).
Lemma Rlt_R0_R2 : 0 < 2.
Lemma IZR_eq : forall z1 z2:Z, z1 = z2 -> IZR z1 = IZR z2.
Lemma IZR_neq : forall z1 z2:Z, z1 <> z2 -> IZR z1 <> IZR z2.
Lemma bool_dec : forall b1 b2 : bool, {b1 = b2} + {b1 <> b2}.
Lemma diff_true_false : true <> false.
Lemma diff_false_true : false <> true.
Lemma eq_true_false_abs : forall b:bool, b = true -> b = false -> False.
Lemma not_true_is_false : forall b:bool, b <> true -> b = false.
Lemma not_false_is_true : forall b:bool, b <> false -> b = true.
Lemma not_true_iff_false : forall b, b <> true <-> b = false.
Lemma not_false_iff_true : forall b, b <> false <-> b = true.
Lemma leb_implb : forall b1 b2, leb b1 b2 <-> implb b1 b2 = true.
Lemma eqb_subst : forall (P:bool -> Prop) (b1 b2:bool), eqb b1 b2 = true -> P b1 -> P b2.
Lemma eqb_reflx : forall b:bool, eqb b b = true.
Lemma eqb_prop : forall a b:bool, eqb a b = true -> a = b.
Lemma eqb_true_iff : forall a b:bool, eqb a b = true <-> a = b.
Lemma eqb_false_iff : forall a b:bool, eqb a b = false <-> a <> b.
Lemma negb_orb : forall b1 b2:bool, negb (b1 || b2) = negb b1 && negb b2.
Lemma negb_andb : forall b1 b2:bool, negb (b1 && b2) = negb b1 || negb b2.
Lemma negb_involutive : forall b:bool, negb (negb b) = b.
Lemma negb_involutive_reverse : forall b:bool, b = negb (negb b).
Lemma negb_sym : forall b b':bool, b' = negb b -> b = negb b'.
Lemma no_fixpoint_negb : forall b:bool, negb b <> b.
Lemma eqb_negb1 : forall b:bool, eqb (negb b) b = false.
Lemma eqb_negb2 : forall b:bool, eqb b (negb b) = false.
Lemma if_negb : forall (A:Type) (b:bool) (x y:A),   (if negb b then x else y) = (if b then y else x).
Lemma negb_true_iff : forall b, negb b = true <-> b = false.
Lemma negb_false_iff : forall b, negb b = false <-> b = true.
Lemma orb_true_iff : forall b1 b2, b1 || b2 = true <-> b1 = true \/ b2 = true.
Lemma orb_false_iff : forall b1 b2, b1 || b2 = false <-> b1 = false /\ b2 = false.
Lemma orb_true_elim : forall b1 b2:bool, b1 || b2 = true -> {b1 = true} + {b2 = true}.
Lemma orb_prop : forall a b:bool, a || b = true -> a = true \/ b = true.
Lemma orb_true_intro : forall b1 b2:bool, b1 = true \/ b2 = true -> b1 || b2 = true.
Lemma orb_false_intro : forall b1 b2:bool, b1 = false -> b2 = false -> b1 || b2 = false.
Lemma orb_false_elim : forall b1 b2:bool, b1 || b2 = false -> b1 = false /\ b2 = false.
Lemma orb_diag : forall b, b || b = b.
Lemma orb_true_r : forall b:bool, b || true = true.
Lemma orb_true_l : forall b:bool, true || b = true.
Lemma orb_false_r : forall b:bool, b || false = b.
Lemma orb_false_l : forall b:bool, false || b = b.
Lemma orb_negb_r : forall b:bool, b || negb b = true.
Lemma orb_comm : forall b1 b2:bool, b1 || b2 = b2 || b1.
Lemma orb_assoc : forall b1 b2 b3:bool, b1 || (b2 || b3) = b1 || b2 || b3.
Lemma andb_true_iff : forall b1 b2:bool, b1 && b2 = true <-> b1 = true /\ b2 = true.
Lemma andb_false_iff : forall b1 b2:bool, b1 && b2 = false <-> b1 = false \/ b2 = false.
Lemma andb_true_eq : forall a b:bool, true = a && b -> true = a /\ true = b.
Lemma andb_false_intro1 : forall b1 b2:bool, b1 = false -> b1 && b2 = false.
Lemma andb_false_intro2 : forall b1 b2:bool, b2 = false -> b1 && b2 = false.
Lemma andb_false_r : forall b:bool, b && false = false.
Lemma andb_false_l : forall b:bool, false && b = false.
Lemma andb_diag : forall b, b && b = b.
Lemma andb_true_r : forall b:bool, b && true = b.
Lemma andb_true_l : forall b:bool, true && b = b.
Lemma andb_false_elim : forall b1 b2:bool, b1 && b2 = false -> {b1 = false} + {b2 = false}.
Lemma andb_negb_r : forall b:bool, b && negb b = false.
Lemma andb_comm : forall b1 b2:bool, b1 && b2 = b2 && b1.
Lemma andb_assoc : forall b1 b2 b3:bool, b1 && (b2 && b3) = b1 && b2 && b3.
Lemma andb_orb_distrib_r : forall b1 b2 b3:bool, b1 && (b2 || b3) = b1 && b2 || b1 && b3.
Lemma andb_orb_distrib_l : forall b1 b2 b3:bool, (b1 || b2) && b3 = b1 && b3 || b2 && b3.
Lemma orb_andb_distrib_r : forall b1 b2 b3:bool, b1 || b2 && b3 = (b1 || b2) && (b1 || b3).
Lemma orb_andb_distrib_l : forall b1 b2 b3:bool, b1 && b2 || b3 = (b1 || b3) && (b2 || b3).
Lemma absorption_andb : forall b1 b2:bool, b1 && (b1 || b2) = b1.
Lemma absorption_orb : forall b1 b2:bool, b1 || b1 && b2 = b1.
Lemma xorb_false_r : forall b:bool, xorb b false = b.
Lemma xorb_false_l : forall b:bool, xorb false b = b.
Lemma xorb_true_r : forall b:bool, xorb b true = negb b.
Lemma xorb_true_l : forall b:bool, xorb true b = negb b.
Lemma xorb_nilpotent : forall b:bool, xorb b b = false.
Lemma xorb_comm : forall b b':bool, xorb b b' = xorb b' b.
Lemma xorb_assoc_reverse : forall b b' b'':bool, xorb (xorb b b') b'' = xorb b (xorb b' b'').
Lemma xorb_eq : forall b b':bool, xorb b b' = false -> b = b'.
Lemma xorb_move_l_r_1 : forall b b' b'':bool, xorb b b' = b'' -> b' = xorb b b''.
Lemma xorb_move_l_r_2 : forall b b' b'':bool, xorb b b' = b'' -> b = xorb b'' b'.
Lemma xorb_move_r_l_1 : forall b b' b'':bool, b = xorb b' b'' -> xorb b' b = b''.
Lemma xorb_move_r_l_2 : forall b b' b'':bool, b = xorb b' b'' -> xorb b b'' = b'.
Lemma negb_xorb_l : forall b b', negb (xorb b b') = xorb (negb b) b'.
Lemma negb_xorb_r : forall b b', negb (xorb b b') = xorb b (negb b').
Lemma xorb_negb_negb : forall b b', xorb (negb b) (negb b') = xorb b b'.
Lemma eq_iff_eq_true : forall b1 b2, b1 = b2 <-> (b1 = true <-> b2 = true).
Lemma eq_true_iff_eq : forall b1 b2, (b1 = true <-> b2 = true) -> b1 = b2.
Lemma eq_true_negb_classical : forall b:bool, negb b <> true -> b = true.
Lemma eq_true_not_negb : forall b:bool, b <> true -> negb b = true.
Lemma absurd_eq_bool : forall b b':bool, False -> b = b'.
Lemma absurd_eq_true : forall b, False -> b = true.
Lemma trans_eq_bool : forall x y z:bool, x = y -> y = z -> x = z.
Lemma Is_true_eq_true : forall x:bool, Is_true x -> x = true.
Lemma Is_true_eq_left : forall x:bool, x = true -> Is_true x.
Lemma Is_true_eq_right : forall x:bool, true = x -> Is_true x.
Lemma eqb_refl : forall x:bool, Is_true (eqb x x).
Lemma eqb_eq : forall x y:bool, Is_true (eqb x y) -> x = y.
Lemma orb_prop_elim : forall a b:bool, Is_true (a || b) -> Is_true a \/ Is_true b.
Lemma orb_prop_intro : forall a b:bool, Is_true a \/ Is_true b -> Is_true (a || b).
Lemma andb_prop_intro : forall b1 b2:bool, Is_true b1 /\ Is_true b2 -> Is_true (b1 && b2).
Lemma andb_prop_elim : forall a b:bool, Is_true (a && b) -> Is_true a /\ Is_true b.
Lemma eq_bool_prop_intro : forall b1 b2, (Is_true b1 <-> Is_true b2) -> b1 = b2.
Lemma eq_bool_prop_elim : forall b1 b2, b1 = b2 -> (Is_true b1 <-> Is_true b2).
Lemma negb_prop_elim : forall b, Is_true (negb b) -> ~ Is_true b.
Lemma negb_prop_intro : forall b, ~ Is_true b -> Is_true (negb b).
Lemma negb_prop_classical : forall b, ~ Is_true (negb b) -> Is_true b.
Lemma negb_prop_involutive : forall b, Is_true b -> ~ Is_true (negb b).
Lemma andb_if : forall (A:Type)(a a':A)(b b' : bool), (if b && b' then a else a') = (if b then if b' then a else a' else a').
Lemma negb_if : forall (A:Type)(a a':A)(b:bool), (if negb b then a else a') = (if b then a' else a).
Lemma andb_lazy_alt : forall a b : bool, a && b = a &&& b.
Lemma orb_lazy_alt : forall a b : bool, a || b = a ||| b.
Lemma reflect_iff : forall P b, reflect P b -> (P<->b=true).
Lemma iff_reflect : forall P b, (P<->b=true) -> reflect P b.
Lemma reflect_dec : forall P b, reflect P b -> {P}+{~P}.
Lemma P_Rmin : forall (P:R -> Prop) (x y:R), P x -> P y -> P (Rmin x y).
Lemma exp_le_3 : exp 1 <= 3.
Lemma exp_ineq1 : forall x:R, 0 < x -> 1 + x < exp x.
Lemma ln_exists1 : forall y:R, 1 <= y -> { z:R | y = exp z }.
Lemma ln_exists : forall y:R, 0 < y -> { z:R | y = exp z }.
Lemma exp_ln : forall x:R, 0 < x -> exp (ln x) = x.
Lemma derivable_pt_lim_ln : forall x:R, 0 < x -> derivable_pt_lim ln x (/ x).
Lemma pascal_step1 : forall n i:nat, (i <= n)%nat -> C n i = C n (n - i).
Lemma pascal_step2 : forall n i:nat,   (i <= n)%nat -> C (S n) i = INR (S n) / INR (S n - i) * C n i.
Lemma pascal_step3 : forall n i:nat, (i < n)%nat -> C n (S i) = INR (n - i) / INR (S i) * C n i.
Lemma pascal : forall n i:nat, (i < n)%nat -> C n i + C n (S i) = C (S n) (S i).
Lemma binomial : forall (x y:R) (n:nat),   (x + y) ^ n = sum_f_R0 (fun i:nat => C n i * x ^ i * y ^ (n - i)) n.
Lemma eq_rect_eq :   forall (p:U) (Q:U -> Type) (x:Q p) (h:p = p), x = eq_rect p Q x p h.
Lemma UIP : forall (x y:U) (p1 p2:x = y), p1 = p2.
Lemma UIP_refl : forall (x:U) (p:x = x), p = eq_refl x.
Lemma Streicher_K :   forall (x:U) (P:x = x -> Prop), P (eq_refl x) -> forall p:x = x, P p.
Lemma inj_pairT2 :   forall (P:U -> Type) (p:U) (x y:P p),     existT P p x = existT P p y -> x = y.
Lemma inj_pairP2 :   forall (P:U -> Prop) (x:U) (p q:P x),     ex_intro P x p = ex_intro P x q -> p = q.
Lemma eq_rect_eq :   forall (p:U) (Q:U -> Type) (x:Q p) (h:p = p), x = eq_rect p Q x p h.
Lemma UIP : forall (x y:U) (p1 p2:x = y), p1 = p2.
Lemma UIP_refl : forall (x:U) (p:x = x), p = eq_refl x.
Lemma Streicher_K :   forall (x:U) (P:x = x -> Prop), P (eq_refl x) -> forall p:x = x, P p.
Lemma inj_pairP2 :   forall (P:U -> Prop) (x:U) (p q:P x),     ex_intro P x p = ex_intro P x q -> p = q.
Lemma inj_pair2 :   forall (P:U -> Type) (p:U) (x y:P p),     existT P p x = existT P p y -> x = y.
Lemma inj_pair2_eq_dec : forall A:Type, (forall x y:A, {x=y}+{x<>y}) ->  ( forall (P:A -> Type) (p:A) (x y:P p), existT P p x = existT P p y -> x = y ).
Lemma empty_1 : Empty empty.
Lemma empty_sorted : Sort empty.
Lemma is_empty_1 :forall m, Empty m -> is_empty m = true.
Lemma is_empty_2 : forall m, is_empty m = true -> Empty m.
Lemma mem_1 : forall m (Hm:Sort m) x, In x m -> mem x m = true.
Lemma mem_2 : forall m (Hm:Sort m) x, mem x m = true -> In x m.
Lemma find_2 :  forall m x e, find x m = Some e -> MapsTo x e m.
Lemma find_1 :  forall m (Hm:Sort m) x e, MapsTo x e m -> find x m = Some e.
Lemma add_1 : forall m x y e, X.eq x y -> MapsTo y e (add x e m).
Lemma add_2 : forall m x y e e', ~ X.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Lemma add_3 : forall m x y e e', ~ X.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Lemma add_Inf : forall (m:t elt)(x x':key)(e e':elt), Inf (x',e') m -> ltk (x',e') (x,e) -> Inf (x',e') (add x e m).
Lemma add_sorted : forall m (Hm:Sort m) x e, Sort (add x e m).
Lemma remove_1 : forall m (Hm:Sort m) x y, X.eq x y -> ~ In y (remove x m).
Lemma remove_2 : forall m (Hm:Sort m) x y e, ~ X.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Lemma remove_3 : forall m (Hm:Sort m) x y e, MapsTo y e (remove x m) -> MapsTo y e m.
Lemma remove_Inf : forall (m:t elt)(Hm : Sort m)(x x':key)(e':elt), Inf (x',e') m -> Inf (x',e') (remove x m).
Lemma remove_sorted : forall m (Hm:Sort m) x, Sort (remove x m).
Lemma elements_1 : forall m x e, MapsTo x e m -> InA eqke (x,e) (elements m).
Lemma elements_2 : forall m x e, InA eqke (x,e) (elements m) -> MapsTo x e m.
Lemma elements_3 : forall m (Hm:Sort m), sort ltk (elements m).
Lemma elements_3w : forall m (Hm:Sort m), NoDupA eqk (elements m).
Lemma fold_1 : forall m (A:Type)(i:A)(f:key->elt->A->A), fold f m i = fold_left (fun a p => f (fst p) (snd p) a) (elements m) i.
Lemma equal_1 : forall m (Hm:Sort m) m' (Hm': Sort m') cmp, Equivb cmp m m' -> equal cmp m m' = true.
Lemma equal_2 : forall m (Hm:Sort m) m' (Hm:Sort m') cmp, equal cmp m m' = true -> Equivb cmp m m'.
Lemma equal_cons : forall cmp l1 l2 x y, Sort (x::l1) -> Sort (y::l2) -> eqk x y -> cmp (snd x) (snd y) = true -> (Equivb cmp l1 l2 <-> Equivb cmp (x :: l1) (y :: l2)).
Lemma map_1 : forall (m:t elt)(x:key)(e:elt)(f:elt->elt'), MapsTo x e m -> MapsTo x (f e) (map f m).
Lemma map_2 : forall (m:t elt)(x:key)(f:elt->elt'), In x (map f m) -> In x m.
Lemma map_lelistA : forall (m: t elt)(x:key)(e:elt)(e':elt')(f:elt->elt'), lelistA (@ltk elt) (x,e) m -> lelistA (@ltk elt') (x,e') (map f m).
Lemma map_sorted : forall (m: t elt)(Hm : sort (@ltk elt) m)(f:elt -> elt'), sort (@ltk elt') (map f m).
Lemma mapi_1 : forall (m:t elt)(x:key)(e:elt)(f:key->elt->elt'), MapsTo x e m -> exists y, X.eq y x /\ MapsTo x (f y e) (mapi f m).
Lemma mapi_2 : forall (m:t elt)(x:key)(f:key->elt->elt'), In x (mapi f m) -> In x m.
Lemma mapi_lelistA : forall (m: t elt)(x:key)(e:elt)(f:key->elt->elt'), lelistA (@ltk elt) (x,e) m -> lelistA (@ltk elt') (x,f x e) (mapi f m).
Lemma mapi_sorted : forall m (Hm : sort (@ltk elt) m)(f: key ->elt -> elt'), sort (@ltk elt') (mapi f m).
Lemma map2_alt_equiv : forall m m', map2_alt m m' = map2 m m'.
Lemma combine_lelistA : forall m m' (x:key)(e:elt)(e':elt')(e'':oee'), lelistA (@ltk elt) (x,e) m -> lelistA (@ltk elt') (x,e') m' -> lelistA (@ltk oee') (x,e'') (combine m m').
Lemma combine_sorted : forall m (Hm : sort (@ltk elt) m) m' (Hm' : sort (@ltk elt') m'), sort (@ltk oee') (combine m m').
Lemma map2_sorted : forall m (Hm : sort (@ltk elt) m) m' (Hm' : sort (@ltk elt') m'), sort (@ltk elt'') (map2 m m').
Lemma combine_1 : forall m (Hm : sort (@ltk elt) m) m' (Hm' : sort (@ltk elt') m') (x:key), find x (combine m m') = at_least_one (find x m) (find x m').
Lemma map2_0 : forall m (Hm : sort (@ltk elt) m) m' (Hm' : sort (@ltk elt') m') (x:key), find x (map2 m m') = at_least_one_then_f (find x m) (find x m').
Lemma map2_1 : forall m (Hm : sort (@ltk elt) m) m' (Hm' : sort (@ltk elt') m')(x:key), In x m \/ In x m' -> find x (map2 m m') = f (find x m) (find x m').
Lemma map2_2 : forall m (Hm : sort (@ltk elt) m) m' (Hm' : sort (@ltk elt') m')(x:key), In x (map2 m m') -> In x m \/ In x m'.
Lemma MapsTo_1 : forall m x y e, E.eq x y -> MapsTo x e m -> MapsTo y e m.
Lemma mem_1 : forall m x, In x m -> mem x m = true.
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Lemma empty_1 : Empty empty.
Lemma is_empty_1 : forall m, Empty m -> is_empty m = true.
Lemma is_empty_2 :  forall m, is_empty m = true -> Empty m.
Lemma add_1 : forall m x y e, E.eq x y -> MapsTo y e (add x e m).
Lemma add_2 : forall m x y e e', ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Lemma add_3 : forall m x y e e', ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Lemma remove_1 : forall m x y, E.eq x y -> ~ In y (remove x m).
Lemma remove_2 : forall m x y e, ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Lemma remove_3 : forall m x y e, MapsTo y e (remove x m) -> MapsTo y e m.
Lemma find_1 : forall m x e, MapsTo x e m -> find x m = Some e.
Lemma find_2 : forall m x e, find x m = Some e -> MapsTo x e m.
Lemma elements_1 : forall m x e, MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Lemma elements_2 : forall m x e, InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Lemma elements_3 : forall m, sort lt_key (elements m).
Lemma elements_3w : forall m, NoDupA eq_key (elements m).
Lemma cardinal_1 : forall m, cardinal m = length (elements m).
Lemma fold_1 : forall m (A : Type) (i : A) (f : key -> elt -> A -> A),       fold f m i = fold_left (fun a p => f (fst p) (snd p) a) (elements m) i.
Lemma equal_1 : forall m m' cmp, Equivb cmp m m' -> equal cmp m m' = true.
Lemma equal_2 : forall m m' cmp, equal cmp m m' = true -> Equivb cmp m m'.
Lemma map_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)(f:elt->elt'),       MapsTo x e m -> MapsTo x (f e) (map f m).
Lemma map_2 : forall (elt elt':Type)(m: t elt)(x:key)(f:elt->elt'),       In x (map f m) -> In x m.
Lemma mapi_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)       (f:key->elt->elt'), MapsTo x e m ->       exists y, E.eq y x /\ MapsTo x (f y e) (mapi f m).
Lemma mapi_2 : forall (elt elt':Type)(m: t elt)(x:key)       (f:key->elt->elt'), In x (mapi f m) -> In x m.
Lemma map2_1 : forall (elt elt' elt'':Type)(m: t elt)(m': t elt') (x:key)(f:option elt->option elt'->option elt''), In x m \/ In x m' ->       find x (map2 f m m') = f (find x m) (find x m').
Lemma map2_2 : forall (elt elt' elt'':Type)(m: t elt)(m': t elt') (x:key)(f:option elt->option elt'->option elt''),       In x (map2 f m m') -> In x m \/ In x m'.
Lemma eq_equal : forall m m', eq m m' <-> equal cmp m m' = true.
Lemma eq_1 : forall m m', Equivb cmp m m' -> eq m m'.
Lemma eq_2 : forall m m', eq m m' -> Equivb cmp m m'.
Lemma eq_refl : forall m : t, eq m m.
Lemma  eq_sym : forall m1 m2 : t, eq m1 m2 -> eq m2 m1.
Lemma eq_trans : forall m1 m2 m3 : t, eq m1 m2 -> eq m2 m3 -> eq m1 m3.
Lemma lt_trans : forall m1 m2 m3 : t, lt m1 m2 -> lt m2 m3 -> lt m1 m3.
Lemma lt_not_eq : forall m1 m2 : t, lt m1 m2 -> ~ eq m1 m2.
Lemma Zquot_0_r a : a ÷ 0 = 0.
Lemma Zrem_0_r a : Z.rem a 0 = a.
Lemma Zrem_0_l a : Z.rem 0 a = 0.
Lemma Zquot_0_l a : 0÷a = 0.
Lemma Z_rem_same a : Z.rem a a = 0.
Lemma Z_rem_mult a b : Z.rem (a*b) b = 0.
Lemma Remainder_equiv : forall a b r, Remainder a b r <-> Remainder_alt a b r.
Lemma Z_quot_pos a b : 0 <= a -> 0 <= b -> 0 <= a÷b.
Lemma Z_quot_lt a b : 0 < a -> 2 <= b -> a÷b < a.
Lemma Z_quot_monotone a b c : 0<=c -> a<=b -> a÷c <= b÷c.
Lemma Z_mult_quot_le a b : 0 <= a -> 0 <= b*(a÷b) <= a.
Lemma Z_mult_quot_ge a b : a <= 0 -> a <= b*(a÷b) <= 0.
Lemma Z_quot_exact_full a b : a = b*(a÷b) <-> Z.rem a b = 0.
Lemma Z_rem_plus : forall a b c:Z, 0 <= (a+b*c) * a -> Z.rem (a + b * c) c = Z.rem a c.
Lemma Z_quot_plus : forall a b c:Z, 0 <= (a+b*c) * a -> c<>0 -> (a + b * c) ÷ c = a ÷ c + b.
Lemma Zquot_mult_cancel_r : forall a b c:Z, c<>0 -> (a*c)÷(b*c) = a÷b.
Lemma Zquot_mult_cancel_l : forall a b c:Z, c<>0 -> (c*a)÷(c*b) = a÷b.
Lemma Zmult_rem_distr_l: forall a b c, Z.rem (c*a) (c*b) = c * (Z.rem a b).
Lemma Zmult_rem_distr_r: forall a b c, Z.rem (a*c) (b*c) = (Z.rem a b) * c.
Lemma Zplus_rem_idemp_l: forall a b n, 0 <= a * b -> Z.rem (Z.rem a n + b) n = Z.rem (a + b) n.
Lemma Zplus_rem_idemp_r: forall a b n, 0 <= a*b -> Z.rem (b + Z.rem a n) n = Z.rem (b + a) n.
Lemma Zmult_rem_idemp_l: forall a b n, Z.rem (Z.rem a n * b) n = Z.rem (a * b) n.
Lemma Zmult_rem_idemp_r: forall a b n, Z.rem (b * Z.rem a n) n = Z.rem (b * a) n.
Lemma Zquot_Zquot : forall a b c, (a÷b)÷c = a÷(b*c).
Lemma Zrem_divides : forall a b, Z.rem a b = 0 <-> exists c, a = b*c.
Lemma Zquot2_odd_remainder : forall a, Remainder a 2 (if Z.odd a then Z.sgn a else 0).
Lemma Zrem_odd : forall a, Z.rem a 2 = if Z.odd a then Z.sgn a else 0.
Lemma Zrem_even : forall a, Z.rem a 2 = if Z.even a then 0 else Z.sgn a.
Lemma Zeven_rem : forall a, Z.even a = Z.eqb (Z.rem a 2) 0.
Lemma Zodd_rem : forall a, Z.odd a = negb (Z.eqb (Z.rem a 2) 0).
Lemma inj_succ p : to_nat (succ p) = S (to_nat p).
Lemma inj_1 : to_nat 1 = 1.
Lemma inj_xO p : to_nat (xO p) = 2 * to_nat p.
Lemma inj_xI p : to_nat (xI p) = S (2 * to_nat p).
Lemma is_succ : forall p, exists n, to_nat p = S n.
Lemma is_pos p : 0 < to_nat p.
Lemma inj p q : to_nat p = to_nat q -> p = q.
Lemma inj_iff p q : to_nat p = to_nat q <-> p = q.
Lemma inj_compare p q : (p ?= q) = nat_compare (to_nat p) (to_nat q).
Lemma inj_lt p q : (p < q)%positive <-> to_nat p < to_nat q.
Lemma inj_le p q : (p <= q)%positive <-> to_nat p <= to_nat q.
Lemma inj_gt p q : (p > q)%positive <-> to_nat p > to_nat q.
Lemma inj_ge p q : (p >= q)%positive <-> to_nat p >= to_nat q.
Lemma inj_min p q : to_nat (min p q) = Peano.min (to_nat p) (to_nat q).
Lemma inj_max p q : to_nat (max p q) = Peano.max (to_nat p) (to_nat q).
Lemma inj (n m : nat) : n<>0 -> m<>0 -> Pos.of_nat n = Pos.of_nat m -> n = m.
Lemma inj_iff (n m : nat) : n<>0 -> m<>0 -> (Pos.of_nat n = Pos.of_nat m <-> n = m).
Lemma inj_succ (n:nat) : n<>0 -> Pos.of_nat (S n) = Pos.succ (Pos.of_nat n).
Lemma inj_pred (n:nat) : Pos.of_nat (pred n) = Pos.pred (Pos.of_nat n).
Lemma inj_add (n m : nat) : n<>0 -> m<>0 -> Pos.of_nat (n+m) = (Pos.of_nat n + Pos.of_nat m)%positive.
Lemma inj_mul (n m : nat) : n<>0 -> m<>0 -> Pos.of_nat (n*m) = (Pos.of_nat n * Pos.of_nat m)%positive.
Lemma inj_compare (n m : nat) : n<>0 -> m<>0 -> nat_compare n m = (Pos.of_nat n ?= Pos.of_nat m).
Lemma inj_sub (n m : nat) : m<>0 -> Pos.of_nat (n-m) = (Pos.of_nat n - Pos.of_nat m)%positive.
Lemma inj_min (n m : nat) : Pos.of_nat (min n m) = Pos.min (Pos.of_nat n) (Pos.of_nat m).
Lemma inj_max (n m : nat) : Pos.of_nat (max n m) = Pos.max (Pos.of_nat n) (Pos.of_nat m).
Lemma inj (n m : nat) : Pos.of_succ_nat n = Pos.of_succ_nat m -> n = m.
Lemma inj_iff (n m : nat) : Pos.of_succ_nat n = Pos.of_succ_nat m <-> n = m.
Lemma inj_succ n : Pos.of_succ_nat (S n) = Pos.succ (Pos.of_succ_nat n).
Lemma inj_compare n m : nat_compare n m = (Pos.of_succ_nat n ?= Pos.of_succ_nat m).
Lemma nat_of_P_minus_morphism p q : Pos.compare_cont p q Eq = Gt ->
Lemma nat_of_P_lt_Lt_compare_morphism p q : Pos.compare_cont p q Eq = Lt -> Pos.to_nat p < Pos.to_nat q.
Lemma nat_of_P_gt_Gt_compare_morphism p q : Pos.compare_cont p q Eq = Gt -> Pos.to_nat p > Pos.to_nat q.
Lemma nat_of_P_lt_Lt_compare_complement_morphism p q : Pos.to_nat p < Pos.to_nat q -> Pos.compare_cont p q Eq = Lt.
Lemma Pmult_nat_mult : forall p n, Pmult_nat p n = Pos.to_nat p * n.
Lemma Pmult_nat_succ_morphism : forall p n, Pmult_nat (Pos.succ p) n = n + Pmult_nat p n.
Lemma Pmult_nat_r_plus_morphism : forall p n, Pmult_nat p (n + n) = Pmult_nat p n + Pmult_nat p n.
Lemma ZL6 : forall p, Pmult_nat p 2 = Pos.to_nat p + Pos.to_nat p.
Lemma le_Pmult_nat : forall p n, n <= Pmult_nat p n.
Lemma distance_refl : forall x0 y0:R, dist_euc x0 y0 x0 y0 = 0.
Lemma distance_symm : forall x0 y0 x1 y1:R, dist_euc x0 y0 x1 y1 = dist_euc x1 y1 x0 y0.
Lemma law_cosines : forall x0 y0 x1 y1 x2 y2 ac:R,   let a := dist_euc x1 y1 x0 y0 in     let b := dist_euc x2 y2 x0 y0 in       let c := dist_euc x2 y2 x1 y1 in         a * c * cos ac = (x0 - x1) * (x2 - x1) + (y0 - y1) * (y2 - y1) ->         Rsqr b = Rsqr c + Rsqr a - 2 * (a * c * cos ac).
Lemma triangle : forall x0 y0 x1 y1 x2 y2:R,   dist_euc x0 y0 x1 y1 <= dist_euc x0 y0 x2 y2 + dist_euc x2 y2 x1 y1.
Lemma translation_0 : forall x y:R, xt x 0 = x /\ yt y 0 = y.
Lemma isometric_translation : forall x1 x2 y1 y2 tx ty:R,   Rsqr (x1 - x2) + Rsqr (y1 - y2) =   Rsqr (xt x1 tx - xt x2 tx) + Rsqr (yt y1 ty - yt y2 ty).
Lemma rotation_0 : forall x y:R, xr x y 0 = x /\ yr x y 0 = y.
Lemma rotation_PI2 : forall x y:R, xr x y (PI / 2) = y /\ yr x y (PI / 2) = - x.
Lemma isometric_rotation_0 : forall x1 y1 x2 y2 theta:R,   Rsqr (x1 - x2) + Rsqr (y1 - y2) =   Rsqr (xr x1 y1 theta - xr x2 y2 theta) +   Rsqr (yr x1 y1 theta - yr x2 y2 theta).
Lemma isometric_rotation : forall x1 y1 x2 y2 theta:R,   dist_euc x1 y1 x2 y2 =   dist_euc (xr x1 y1 theta) (yr x1 y1 theta) (xr x2 y2 theta)   (yr x2 y2 theta).
Lemma isometric_rot_trans : forall x1 y1 x2 y2 tx ty theta:R,   Rsqr (x1 - x2) + Rsqr (y1 - y2) =   Rsqr (xr (xt x1 tx) (yt y1 ty) theta - xr (xt x2 tx) (yt y2 ty) theta) +   Rsqr (yr (xt x1 tx) (yt y1 ty) theta - yr (xt x2 tx) (yt y2 ty) theta).
Lemma isometric_trans_rot : forall x1 y1 x2 y2 tx ty theta:R,   Rsqr (x1 - x2) + Rsqr (y1 - y2) =   Rsqr (xt (xr x1 y1 theta) tx - xt (xr x2 y2 theta) tx) +   Rsqr (yt (yr x1 y1 theta) ty - yt (yr x2 y2 theta) ty).
Lemma predicate_equivalence_pointwise (l : Tlist) : Proper (@predicate_equivalence l ==> pointwise_lifting iff l) id.
Lemma predicate_implication_pointwise (l : Tlist) : Proper (@predicate_implication l ==> pointwise_lifting impl l) id.
Lemma inverse_pointwise_relation A (R : relation A) : relation_equivalence (pointwise_relation A (inverse R)) (inverse (pointwise_relation A R)).
Lemma compat_P_aux :  forall (P : elt -> Prop) (Pdec : forall x : elt, {P x} + {~ P x}),  compat_P E.eq P -> compat_bool E.eq (fdec Pdec).
Lemma choose_ok1 :  forall s x, M.choose s = Some x <-> exists H:In x s,
Lemma choose_ok2 :  forall s, M.choose s = None <-> exists H:Empty s,
Lemma choose_equal : forall s s', Equal s s' ->    match choose s, choose s' with      | inleft (exist x _), inleft (exist x' _) => E.eq x x'
Lemma empty_1 : Empty empty.
Lemma is_empty_1 : forall s : t, Empty s -> is_empty s = true.
Lemma is_empty_2 : forall s : t, is_empty s = true -> Empty s.
Lemma mem_1 : forall (s : t) (x : elt), In x s -> mem x s = true.
Lemma mem_2 : forall (s : t) (x : elt), mem x s = true -> In x s.
Lemma equal_1 : forall s s' : t, Equal s s' -> equal s s' = true.
Lemma equal_2 : forall s s' : t, equal s s' = true -> Equal s s'.
Lemma subset_1 : forall s s' : t, Subset s s' -> subset s s' = true.
Lemma subset_2 : forall s s' : t, subset s s' = true -> Subset s s'.
Lemma choose_1 : forall (s : t) (x : elt), choose s = Some x -> In x s.
Lemma choose_2 : forall s : t, choose s = None -> Empty s.
Lemma choose_3 : forall s s' x x',  choose s = Some x -> choose s' = Some x' -> Equal s s' -> E.eq x x'.
Lemma elements_1 : forall (s : t) (x : elt), In x s -> InA E.eq x (elements s).
Lemma elements_2 : forall (s : t) (x : elt), InA E.eq x (elements s) -> In x s.
Lemma elements_3 : forall s : t, sort E.lt (elements s).
Lemma elements_3w : forall s : t, NoDupA E.eq (elements s).
Lemma min_elt_1 : forall (s : t) (x : elt), min_elt s = Some x -> In x s.
Lemma min_elt_2 :  forall (s : t) (x y : elt), min_elt s = Some x -> In y s -> ~ E.lt y x.
Lemma min_elt_3 : forall s : t, min_elt s = None -> Empty s.
Lemma max_elt_1 : forall (s : t) (x : elt), max_elt s = Some x -> In x s.
Lemma max_elt_2 :  forall (s : t) (x y : elt), max_elt s = Some x -> In y s -> ~ E.lt x y.
Lemma max_elt_3 : forall s : t, max_elt s = None -> Empty s.
Lemma add_1 : forall (s : t) (x y : elt), E.eq x y -> In y (add x s).
Lemma add_2 : forall (s : t) (x y : elt), In y s -> In y (add x s).
Lemma add_3 :  forall (s : t) (x y : elt), ~ E.eq x y -> In y (add x s) -> In y s.
Lemma remove_1 : forall (s : t) (x y : elt), E.eq x y -> ~ In y (remove x s).
Lemma remove_2 :  forall (s : t) (x y : elt), ~ E.eq x y -> In y s -> In y (remove x s).
Lemma remove_3 : forall (s : t) (x y : elt), In y (remove x s) -> In y s.
Lemma singleton_1 : forall x y : elt, In y (singleton x) -> E.eq x y.
Lemma singleton_2 : forall x y : elt, E.eq x y -> In y (singleton x).
Lemma union_1 :  forall (s s' : t) (x : elt), In x (union s s') -> In x s \/ In x s'.
Lemma union_2 : forall (s s' : t) (x : elt), In x s -> In x (union s s').
Lemma union_3 : forall (s s' : t) (x : elt), In x s' -> In x (union s s').
Lemma inter_1 : forall (s s' : t) (x : elt), In x (inter s s') -> In x s.
Lemma inter_2 : forall (s s' : t) (x : elt), In x (inter s s') -> In x s'.
Lemma inter_3 :  forall (s s' : t) (x : elt), In x s -> In x s' -> In x (inter s s').
Lemma diff_1 : forall (s s' : t) (x : elt), In x (diff s s') -> In x s.
Lemma diff_2 : forall (s s' : t) (x : elt), In x (diff s s') -> ~ In x s'.
Lemma diff_3 :  forall (s s' : t) (x : elt), In x s -> ~ In x s' -> In x (diff s s').
Lemma cardinal_1 : forall s, cardinal s = length (elements s).
Lemma fold_1 :  forall (s : t) (A : Type) (i : A) (f : elt -> A -> A),  fold f s i = fold_left (fun a e => f e a) (elements s) i.
Lemma compat_P_aux :  forall f : elt -> bool,  compat_bool E.eq f -> compat_P E.eq (fun x => f x = true).
Lemma filter_1 :  forall (s : t) (x : elt) (f : elt -> bool),  compat_bool E.eq f -> In x (filter f s) -> In x s.
Lemma filter_2 :  forall (s : t) (x : elt) (f : elt -> bool),  compat_bool E.eq f -> In x (filter f s) -> f x = true.
Lemma filter_3 :  forall (s : t) (x : elt) (f : elt -> bool),  compat_bool E.eq f -> In x s -> f x = true -> In x (filter f s).
Lemma for_all_1 :  forall (s : t) (f : elt -> bool),  compat_bool E.eq f ->
Lemma for_all_2 :  forall (s : t) (f : elt -> bool),  compat_bool E.eq f ->
Lemma exists_1 :  forall (s : t) (f : elt -> bool),  compat_bool E.eq f -> Exists (fun x => f x = true) s -> exists_ f s = true.
Lemma exists_2 :  forall (s : t) (f : elt -> bool),  compat_bool E.eq f -> exists_ f s = true -> Exists (fun x => f x = true) s.
Lemma partition_1 :  forall (s : t) (f : elt -> bool),  compat_bool E.eq f -> Equal (fst (partition f s)) (filter f s).
Lemma partition_2 :  forall (s : t) (f : elt -> bool),  compat_bool E.eq f -> Equal (snd (partition f s)) (filter (fun x => negb (f x)) s).
Lemma exp_cof_no_R0 : forall n:nat, / INR (fact n) <> 0.
Lemma exist_exp : forall x:R, { l:R | exp_in x l }.
Lemma pow_i : forall i:nat, (0 < i)%nat -> 0 ^ i = 0.
Lemma exist_exp0 : { l:R | exp_in 0 l }.
Lemma exp_0 : exp 0 = 1.
Lemma cosh_0 : cosh 0 = 1.
Lemma sinh_0 : sinh 0 = 0.
Lemma simpl_cos_n : forall n:nat, cos_n (S n) / cos_n n = - / INR (2 * S n * (2 * n + 1)).
Lemma archimed_cor1 : forall eps:R, 0 < eps ->  exists N : nat, / INR N < eps /\ (0 < N)%nat.
Lemma Alembert_cos : Un_cv (fun n:nat => Rabs (cos_n (S n) / cos_n n)) 0.
Lemma cosn_no_R0 : forall n:nat, cos_n n <> 0.
Lemma exist_cos : forall x:R, { l:R | cos_in x l }.
Lemma simpl_sin_n : forall n:nat, sin_n (S n) / sin_n n = - / INR ((2 * S n + 1) * (2 * S n)).
Lemma Alembert_sin : Un_cv (fun n:nat => Rabs (sin_n (S n) / sin_n n)) 0.
Lemma sin_no_R0 : forall n:nat, sin_n n <> 0.
Lemma exist_sin : forall x:R, { l:R | sin_in x l }.
Lemma cos_sym : forall x:R, cos x = cos (- x).
Lemma sin_antisym : forall x:R, sin (- x) = - sin x.
Lemma sin_0 : sin 0 = 0.
Lemma exist_cos0 : { l:R | cos_in 0 l }.
Lemma cos_0 : cos 0 = 1.
Lemma Zdivide_opp_r a b : (a | b) -> (a | - b).
Lemma Zdivide_opp_r_rev a b : (a | - b) -> (a | b).
Lemma Zdivide_opp_l a b : (a | b) -> (- a | b).
Lemma Zdivide_opp_l_rev a b : (- a | b) -> (a | b).
Lemma Zmult_one x y : x >= 0 -> x * y = 1 -> x = 1.
Lemma Zdivide_bounds a b : (a | b) -> b <> 0 -> Z.abs a <= Z.abs b.
Lemma Zmod_divide : forall a b, b<>0 -> a mod b = 0 -> (b | a).
Lemma Zdivide_mod : forall a b, (b | a) -> a mod b = 0.
Lemma Zdivide_dec a b : {(a | b)} + {~ (a | b)}.
Lemma Zmod_div_mod n m a: 0 < n -> 0 < m -> (n | m) -> a mod n = (a mod m) mod n.
Lemma Zmod_divide_minus a b c: 0 < b -> a mod b = c -> (b | a - c).
Lemma Zdivide_mod_minus a b c: 0 <= c < b -> (b | a - c) -> a mod b = c.
Lemma Zis_gcd_sym : forall a b d, Zis_gcd a b d -> Zis_gcd b a d.
Lemma Zis_gcd_0 : forall a, Zis_gcd a 0 a.
Lemma Zis_gcd_1 : forall a, Zis_gcd a 1 1.
Lemma Zis_gcd_refl : forall a, Zis_gcd a a a.
Lemma Zis_gcd_minus : forall a b d, Zis_gcd a (- b) d -> Zis_gcd b a d.
Lemma Zis_gcd_opp : forall a b d, Zis_gcd a b d -> Zis_gcd b a (- d).
Lemma Zis_gcd_0_abs a : Zis_gcd 0 a (Z.abs a).
Lemma Zis_gcd_for_euclid : forall a b d q:Z, Zis_gcd b (a - q * b) d -> Zis_gcd a b d.
Lemma Zis_gcd_for_euclid2 : forall b d q r:Z, Zis_gcd r b d -> Zis_gcd b (b * q + r) d.
Lemma euclid_rec :   forall v3:Z,     0 <= v3 ->     forall u1 u2 u3 v1 v2:Z, u1 * a + u2 * b = u3 -> v1 * a + v2 * b = v3 -> (forall d:Z, Zis_gcd u3 v3 d -> Zis_gcd a b d) -> Euclid.
Lemma euclid : Euclid.
Lemma Zis_gcd_bezout : forall a b d:Z, Zis_gcd a b d -> Bezout a b d.
Lemma Zis_gcd_mult : forall a b c d:Z, Zis_gcd a b d -> Zis_gcd (c * a) (c * b) (c * d).
Lemma rel_prime_bezout : forall a b:Z, rel_prime a b -> Bezout a b 1.
Lemma bezout_rel_prime : forall a b:Z, Bezout a b 1 -> rel_prime a b.
Lemma rel_prime_mult : forall a b c:Z, rel_prime a b -> rel_prime a c -> rel_prime a (b * c).
Lemma rel_prime_cross_prod : forall a b c d:Z,   rel_prime a b ->   rel_prime c d -> b > 0 -> d > 0 -> a * d = b * c -> a = c /\ b = d.
Lemma Zis_gcd_rel_prime : forall a b g:Z,   b > 0 -> g >= 0 -> Zis_gcd a b g -> rel_prime (a / g) (b / g).
Lemma prime_divisors : forall p:Z,   prime p -> forall a:Z, (a | p) -> a = -1 \/ a = 1 \/ a = p \/ a = - p.
Lemma prime_rel_prime : forall p:Z, prime p -> forall a:Z, ~ (p | a) -> rel_prime p a.
Lemma prime_mult : forall p:Z, prime p -> forall a b:Z, (p | a * b) -> (p | a) \/ (p | b).
Lemma not_prime_0: ~ prime 0.
Lemma not_prime_1: ~ prime 1.
Lemma prime_2: prime 2.
Lemma Z_0_1_more x : 0<=x -> x=0 \/ x=1 \/ 1<x.
Lemma Zgcd_is_gcd : forall a b, Zis_gcd a b (Z.gcd a b).
Lemma Zgcd_ass a b c : Z.gcd (Z.gcd a b) c = Z.gcd a (Z.gcd b c).
Lemma iszero_eq0 : forall x, iszero x = true -> x=0.
Lemma iszero_not_eq0 : forall x, iszero x = false -> x<>0.
Lemma sneakl_shiftr : forall x, x = sneakl (firstr x) (shiftr x).
Lemma sneakr_shiftl : forall x, x = sneakr (firstl x) (shiftl x).
Lemma twice_zero : forall x, twice x = 0 <-> twice_plus_one x = 1.
Lemma twice_or_twice_plus_one : forall x, x = twice (shiftr x) \/ x = twice_plus_one (shiftr x).
Lemma nshiftr_S : forall n x, nshiftr (S n) x = shiftr (nshiftr n x).
Lemma nshiftr_S_tail : forall n x, nshiftr (S n) x = nshiftr n (shiftr x).
Lemma nshiftr_n_0 : forall n, nshiftr n 0 = 0.
Lemma nshiftr_size : forall x, nshiftr size x = 0.
Lemma nshiftr_above_size : forall k x, size<=k -> nshiftr k x = 0.
Lemma nshiftl_S : forall n x, nshiftl (S n) x = shiftl (nshiftl n x).
Lemma nshiftl_S_tail : forall n x, nshiftl (S n) x = nshiftl n (shiftl x).
Lemma nshiftl_n_0 : forall n, nshiftl n 0 = 0.
Lemma nshiftl_size : forall x, nshiftl size x = 0.
Lemma nshiftl_above_size : forall k x, size<=k -> nshiftl k x = 0.
Lemma firstr_firstl : forall x, firstr x = firstl (nshiftl (pred size) x).
Lemma firstl_firstr : forall x, firstl x = firstr (nshiftr (pred size) x).
Lemma nshiftr_predsize_0_firstl : forall x, nshiftr (pred size) x = 0 -> firstl x = D0.
Lemma nshiftr_0_propagates : forall n p x, n <= p -> nshiftr n x = 0 -> nshiftr p x = 0.
Lemma nshiftr_0_firstl : forall n x, n < size -> nshiftr n x = 0 -> firstl x = D0.
Lemma int31_ind_sneakl : forall P : int31->Prop, P 0 -> (forall x d, P x -> P (sneakl d x)) -> forall x, P x.
Lemma int31_ind_twice : forall P : int31->Prop, P 0 -> (forall x, P x -> P (twice x)) -> (forall x, P x -> P (twice_plus_one x)) -> forall x, P x.
Lemma recr_aux_eqn : forall n x, iszero x = false ->  recr_aux (S n) A case0 caserec x =  caserec (firstr x) (shiftr x) (recr_aux n A case0 caserec (shiftr x)).
Lemma recr_aux_converges : forall n p x, n <= size -> n <= p -> recr_aux n A case0 caserec (nshiftr (size - n) x) = recr_aux p A case0 caserec (nshiftr (size - n) x).
Lemma recr_eqn : forall x, iszero x = false -> recr A case0 caserec x = caserec (firstr x) (shiftr x) (recr A case0 caserec (shiftr x)).
Lemma recrbis_aux_equiv : forall n x,  recrbis_aux n A case0 caserec x = recr_aux n A case0 caserec x.
Lemma recrbis_equiv : forall x,  recrbis A case0 caserec x = recr A case0 caserec x.
Lemma incrbis_aux_equiv : forall x, incrbis_aux size x = incr x.
Lemma incr_eqn1 : forall x, firstr x = D0 -> incr x = twice_plus_one (shiftr x).
Lemma incr_eqn2 : forall x, firstr x = D1 -> incr x = twice (incr (shiftr x)).
Lemma incr_twice : forall x, incr (twice x) = twice_plus_one x.
Lemma incr_twice_plus_one_firstl : forall x, firstl x = D0 -> incr (twice_plus_one x) = twice (incr x).
Lemma phibis_aux_equiv : forall x, phibis_aux size x = phi x.
Lemma phi_eqn1 : forall x, firstr x = D0 -> phi x = Z.double (phi (shiftr x)).
Lemma phi_eqn2 : forall x, firstr x = D1 -> phi x = Z.succ_double (phi (shiftr x)).
Lemma phi_twice_firstl : forall x, firstl x = D0 -> phi (twice x) = Z.double (phi x).
Lemma phi_twice_plus_one_firstl : forall x, firstl x = D0 -> phi (twice_plus_one x) = Z.succ_double (phi x).
Lemma phibis_aux_pos : forall n x, (0 <= phibis_aux n x)%Z.
Lemma phibis_aux_bounded : forall n x, n <= size -> (phibis_aux n (nshiftr (size-n) x) < 2 ^ (Z.of_nat n))%Z.
Lemma phi_bounded  : forall x, (0 <= phi x < 2 ^ (Z.of_nat size))%Z.
Lemma phibis_aux_lowerbound : forall n x, firstr (nshiftr n x) = D1 -> (2 ^ Z.of_nat n <= phibis_aux (S n) x)%Z.
Lemma phi_lowerbound : forall x, firstl x = D1 -> (2^(Z.of_nat (pred size)) <= phi x)%Z.
Lemma EqShiftL_zero : forall x y, EqShiftL O x y <-> x = y.
Lemma EqShiftL_size : forall k x y, size<=k -> EqShiftL k x y.
Lemma EqShiftL_le : forall k k' x y, k <= k' ->  EqShiftL k x y -> EqShiftL k' x y.
Lemma EqShiftL_firstr : forall k x y, k < size -> EqShiftL k x y -> firstr x = firstr y.
Lemma EqShiftL_twice : forall k x y, EqShiftL k (twice x) (twice y) <-> EqShiftL (S k) x y.
Lemma i2l_length : forall x, length (i2l x) = size.
Lemma l2i_i2l : forall x, l2i (i2l x) = x.
Lemma i2l_sneakr : forall x d,  i2l (sneakr d x) = tail (i2l x) ++ d::nil.
Lemma i2l_sneakl : forall x d,  i2l (sneakl d x) = d :: removelast (i2l x).
Lemma i2l_l2i : forall l, length l = size -> i2l (l2i l) = l.
Lemma i2l_nshiftl : forall n x, n<=size -> i2l (nshiftl n x) = cstlist _ D0 n ++ firstn (size-n) (i2l x).
Lemma EqShiftL_i2l : forall k x y,  EqShiftL k x y  <-> firstn (size-k) (i2l x) = firstn (size-k) (i2l y).
Lemma EqShiftL_twice_plus_one : forall k x y, EqShiftL k (twice_plus_one x) (twice_plus_one y) <-> EqShiftL (S k) x y.
Lemma EqShiftL_shiftr : forall k x y, EqShiftL k x y -> EqShiftL (S k) (shiftr x) (shiftr y).
Lemma EqShiftL_incrbis : forall n k x y, n<=size -> (n+k=S size)%nat -> EqShiftL k x y -> EqShiftL k (incrbis_aux n x) (incrbis_aux n y).
Lemma EqShiftL_incr : forall x y, EqShiftL 1 x y -> EqShiftL 1 (incr x) (incr y).
Lemma incr_twice_plus_one : forall x, incr (twice_plus_one x) = twice (incr x).
Lemma incr_firstr : forall x, firstr (incr x) <> firstr x.
Lemma incr_inv : forall x y, incr x = twice_plus_one y -> x = twice y.
Lemma phi_inv_double_plus_one : forall z,  phi_inv (Z.succ_double z) = twice_plus_one (phi_inv z).
Lemma phi_inv_double : forall z,  phi_inv (Z.double z) = twice (phi_inv z).
Lemma phi_inv_incr : forall z, phi_inv (Z.succ z) = incr (phi_inv z).
Lemma phi_inv_phi_aux : forall n x, n <= size ->  phi_inv (phibis_aux n (nshiftr (size-n) x)) =  nshiftr (size-n) x.
Lemma phi_inv_phi : forall x, phi_inv (phi x) = x.
Lemma p2ibis_bounded : forall n p, nshiftr n (snd (p2ibis n p)) = 0.
Lemma p2ibis_spec : forall n p, (n<=size)%nat ->   Zpos p = (Z.of_N (fst (p2ibis n p)))*2^(Z.of_nat n) +
Lemma phi_inv_positive_p2ibis : forall n p, (n<=size)%nat -> EqShiftL (size-n) (phi_inv_positive p) (snd (p2ibis n p)).
Lemma phi_phi_inv_positive : forall p, phi (phi_inv_positive p) = (Zpos p) mod (2^(Z.of_nat size)).
Lemma double_twice_firstl : forall x, firstl x = D0 -> (Twon*x = twice x)%int31.
Lemma double_twice_plus_one_firstl : forall x, firstl x = D0 -> (Twon*x+In = twice_plus_one x)%int31.
Lemma p2i_p2ibis : forall n p, (n<=size)%nat -> p2i n p = p2ibis n p.
Lemma positive_to_int31_phi_inv_positive : forall p,  snd (positive_to_int31 p) = phi_inv_positive p.
Lemma positive_to_int31_spec : forall p,   Zpos p = (Z.of_N (fst (positive_to_int31 p)))*2^(Z.of_nat size) +
Lemma phi_twice : forall x,  phi (twice x) = (Z.double (phi x)) mod 2^(Z.of_nat size).
Lemma phi_twice_plus_one : forall x,  phi (twice_plus_one x) = (Z.succ_double (phi x)) mod 2^(Z.of_nat size).
Lemma phi_incr : forall x,  phi (incr x) = (Z.succ (phi x)) mod 2^(Z.of_nat size).
Lemma phi_phi_inv_negative : forall p, phi (incr (complement_negative p)) = (Zneg p) mod 2^(Z.of_nat size).
Lemma phi_phi_inv : forall z, phi (phi_inv z) = z mod 2 ^ (Z.of_nat size).
Lemma wB_pos : wB > 0.
Lemma spec_zdigits : [| 31 |] = 31.
Lemma spec_more_than_1_digit: 1 < 31.
Lemma spec_0   : [| 0 |] = 0.
Lemma spec_1   : [| 1 |] = 1.
Lemma spec_m1 : [| Tn |] = wB - 1.
Lemma spec_compare : forall x y,  (x ?= y)%int31 = ([|x|] ?= [|y|]).
Lemma spec_add_c  : forall x y, [+|add31c x y|] = [|x|] + [|y|].
Lemma spec_succ_c : forall x, [+|add31c x 1|] = [|x|] + 1.
Lemma spec_add_carry_c : forall x y, [+|add31carryc x y|] = [|x|] + [|y|] + 1.
Lemma spec_add : forall x y, [|x+y|] = ([|x|] + [|y|]) mod wB.
Lemma spec_add_carry :  forall x y, [|x+y+1|] = ([|x|] + [|y|] + 1) mod wB.
Lemma spec_succ : forall x, [|x+1|] = ([|x|] + 1) mod wB.
Lemma spec_sub_c : forall x y, [-|sub31c x y|] = [|x|] - [|y|].
Lemma spec_sub_carry_c : forall x y, [-|sub31carryc x y|] = [|x|] - [|y|] - 1.
Lemma spec_sub : forall x y, [|x-y|] = ([|x|] - [|y|]) mod wB.
Lemma spec_sub_carry :  forall x y, [|x-y-1|] = ([|x|] - [|y|] - 1) mod wB.
Lemma spec_opp_c : forall x, [-|sub31c 0 x|] = -[|x|].
Lemma spec_opp : forall x, [|0 - x|] = (-[|x|]) mod wB.
Lemma spec_opp_carry : forall x, [|0 - x - 1|] = wB - [|x|] - 1.
Lemma spec_pred_c : forall x, [-|sub31c x 1|] = [|x|] - 1.
Lemma spec_pred : forall x, [|x-1|] = ([|x|] - 1) mod wB.
Lemma phi2_phi_inv2 : forall x, [||phi_inv2 x||] = x mod (wB^2).
Lemma spec_mul_c : forall x y, [|| mul31c x y ||] = [|x|] * [|y|].
Lemma spec_mul : forall x y, [|x*y|] = ([|x|] * [|y|]) mod wB.
Lemma spec_square_c : forall x, [|| mul31c x x ||] = [|x|] * [|x|].
Lemma spec_div21 : forall a1 a2 b,     wB/2 <= [|b|] ->     [|a1|] < [|b|] ->     let (q,r) := div3121 a1 a2 b in     [|a1|] *wB+ [|a2|] = [|q|] * [|b|] + [|r|] /\     0 <= [|r|] < [|b|].
Lemma spec_div : forall a b, 0 < [|b|] ->     let (q,r) := div31 a b in     [|a|] = [|q|] * [|b|] + [|r|] /\     0 <= [|r|] < [|b|].
Lemma spec_mod :  forall a b, 0 < [|b|] ->     [|let (_,r) := (a/b)%int31 in r|] = [|a|] mod [|b|].
Lemma phi_gcd : forall i j, [|gcd31 i j|] = Zgcdn (2*size) [|j|] [|i|].
Lemma spec_gcd : forall a b, Zis_gcd [|a|] [|b|] [|gcd31 a b|].
Lemma iter_int31_iter_nat : forall A f i a, iter_int31 i A f a = iter_nat (Z.abs_nat [|i|]) A f a.
Lemma addmuldiv31_equiv : forall p x y, addmuldiv31 p x y = addmuldiv31_alt (Z.abs_nat [|p|]) x y.
Lemma spec_add_mul_div : forall x y p, [|p|] <= Zpos 31 ->  [| addmuldiv31 p x y |] =  ([|x|] * (2 ^ [|p|]) + [|y|] / (2 ^ ((Zpos 31) - [|p|]))) mod wB.
Lemma spec_pos_mod : forall w p,      [|ZnZ.pos_mod p w|] = [|w|] mod (2 ^ [|p|]).
Lemma spec_head00:  forall x, [|x|] = 0 -> [|head031 x|] = Zpos 31.
Lemma head031_equiv :  forall x, [|head031 x|] = Z.of_nat (head031_alt size x).
Lemma phi_nz : forall x, 0 < [|x|] <-> x <> 0%int31.
Lemma spec_head0  : forall x,  0 < [|x|] ->  wB/ 2 <= 2 ^ ([|head031 x|]) * [|x|] < wB.
Lemma spec_tail00:  forall x, [|x|] = 0 -> [|tail031 x|] = Zpos 31.
Lemma tail031_equiv :  forall x, [|tail031 x|] = Z.of_nat (tail031_alt size x).
Lemma spec_tail0  : forall x, 0 < [|x|] ->        exists y, 0 <= y /\ [|x|] = (2 * y + 1) * (2 ^ [|tail031 x|]).
Lemma quotient_by_2 a: a - 1 <= (a/2) + (a/2).
Lemma sqrt_main_trick j k: 0 <= j -> 0 <= k ->  (j * k) + j <= ((j + k)/2 + 1)  ^ 2.
Lemma sqrt_main i j: 0 <= i -> 0 < j -> i < ((j + (i/j))/2 + 1) ^ 2.
Lemma sqrt_init i: 1 < i -> i < (i/2 + 1) ^ 2.
Lemma sqrt_test_true i j: 0 <= i -> 0 < j -> i/j >= j -> j ^ 2 <= i.
Lemma sqrt_test_false i j: 0 <= i -> 0 < j -> i/j < j ->  (j + (i/j))/2 < j.
Lemma sqrt31_step_def rec i j:  sqrt31_step rec i j =  match (fst (i/j) ?= j)%int31 with    Lt => rec i (fst ((j + fst(i/j))/2))%int31  | _ =>  j  end.
Lemma div31_phi i j: 0 < [|j|] -> [|fst (i/j)%int31|] = [|i|]/[|j|].
Lemma sqrt31_step_correct rec i j: 0 < [|i|] -> 0 < [|j|] -> [|i|] < ([|j|] + 1) ^ 2 ->  2 * [|j|] < wB -> (forall j1 : int31,   0 < [|j1|] < [|j|] -> [|i|] < ([|j1|] + 1) ^ 2 ->   [|rec i j1|] ^ 2 <= [|i|] < ([|rec i j1|] + 1) ^ 2) -> [|sqrt31_step rec i j|] ^ 2 <= [|i|] < ([|sqrt31_step rec i j|] + 1) ^ 2.
Lemma iter31_sqrt_correct n rec i j: 0 < [|i|] -> 0 < [|j|] -> [|i|] < ([|j|] + 1) ^ 2 -> 2 * [|j|] < 2 ^ (Z.of_nat size) ->
Lemma spec_sqrt : forall x,      [|sqrt31 x|] ^ 2 <= [|x|] < ([|sqrt31 x|] + 1) ^ 2.
Lemma sqrt312_step_def rec ih il j:  sqrt312_step rec ih il j =  match (ih ?= j)%int31 with     Eq => j   | Gt => j   | _ =>      match (fst (div3121 ih il j) ?= j)%int31 with        Lt => let m := match j +c fst (div3121 ih il j) with                      C0 m1 => fst (m1/2)%int31                    | C1 m1 => (fst (m1/2) + v30)%int31                    end in rec ih il m      | _ =>  j      end  end.
Lemma sqrt312_lower_bound ih il j:  phi2 ih  il  < ([|j|] + 1) ^ 2 -> [|ih|] <= [|j|].
Lemma div312_phi ih il j: (2^30 <= [|j|] -> [|ih|] < [|j|] -> [|fst (div3121 ih il j)|] = phi2 ih il/[|j|])%Z.
Lemma sqrt312_step_correct rec ih il j: 2 ^ 29 <= [|ih|] -> 0 < [|j|] -> phi2 ih il < ([|j|] + 1) ^ 2 -> (forall j1, 0 < [|j1|] < [|j|] ->  phi2 ih il < ([|j1|] + 1) ^ 2 ->    [|rec ih il j1|] ^ 2 <= phi2 ih il < ([|rec ih il j1|] + 1) ^ 2) -> [|sqrt312_step rec ih il  j|] ^ 2 <= phi2 ih il     < ([|sqrt312_step rec ih il j|] + 1) ^  2.
Lemma iter312_sqrt_correct n rec ih il j: 2^29 <= [|ih|] ->  0 < [|j|] -> phi2 ih il < ([|j|] + 1) ^ 2 -> (forall j1, 0 < [|j1|] -> 2^(Z.of_nat n) + [|j1|] <= [|j|] ->
Lemma spec_sqrt2 : forall x y,      wB/ 4 <= [|x|] ->      let (s,r) := sqrt312 x y in         [||WW x y||] = [|s|] ^ 2 + [+|r|] /\         [+|r|] <= 2 * [|s|].
Lemma spec_eq0 : forall x, ZnZ.eq0 x = true -> [|x|] = 0.
Lemma spec_is_even : forall x,     if ZnZ.is_even x then [|x|] mod 2 = 0 else [|x|] mod 2 = 1.
Lemma eucl_dev : forall n, n > 0 -> forall m:nat, diveucl m n.
Lemma quotient : forall n,   n > 0 ->   forall m:nat, {q : nat |  exists r : nat, m = q * n + r /\ n > r}.
Lemma modulo : forall n,   n > 0 ->   forall m:nat, {r : nat |  exists q : nat, m = q * n + r /\ n > r}.
Lemma Req_dec : forall r1 r2:R, {r1 = r2} + {r1 <> r2}.
Lemma Reqb_eq : forall r1 r2, Reqb r1 r2 = true <-> r1=r2.
Lemma Rcompare_spec : forall x y, CompareSpec (x=y) (x<y) (y<x) (Rcompare x y).
Lemma le_lteq : forall x y, x <= y <-> x < y \/ x = y.
Lemma Zlt0_not_eq : forall n, 0<n -> n<>0.
Lemma beta_mult : forall h l beta,  0 <= h < beta -> 0 <= l < beta -> 0 <= h*beta+l < beta^2.
Lemma Zmult_lt_b :  forall b x y, 0 <= x < b -> 0 <= y < b -> 0 <= x * y <= b^2 - 2*b + 1.
Lemma sum_mul_carry : forall xh xl yh yl wc cc beta,  1 < beta ->  0 <= wc < beta ->  0 <= xh < beta ->  0 <= xl < beta ->  0 <= yh < beta ->  0 <= yl < beta ->  0 <= cc < beta^2 ->  wc*beta^2 + cc = xh*yl + xl*yh ->  0 <= wc <= 1.
Lemma shift_unshift_mod : forall n p a,    0 <= a < 2^n ->    0 <= p <= n ->    a * 2^p = a / 2^(n - p) * 2^n + (a*2^p) mod 2^n.
Lemma shift_unshift_mod_2 : forall n p a, 0 <= p <= n ->  ((a * 2 ^ (n - p)) mod (2^n) / 2 ^ (n - p)) mod (2^n) =  a mod 2 ^ p.
Lemma div_le_0 : forall p x, 0 <= x -> 0 <= x / 2 ^ p.
Lemma div_lt : forall p x y, 0 <= x < y -> x / 2^p < y.
Lemma Zdiv_gcd_zero : forall a b, b / Z.gcd a b = 0 -> b <> 0 ->
Lemma Zgcd_mult_rel_prime : forall a b c, Z.gcd a c = 1 -> Z.gcd b c = 1 -> Z.gcd (a*b) c = 1.
Lemma Zcompare_gt : forall (A:Type)(a a':A)(p q:Z), match (p?=q)%Z with Gt => a | _ => a' end = if Z_le_gt_dec p q then a' else a.
Lemma Zsquare_le x : x <= x*x.
Lemma Acc_union :   commut A R1 R2 ->   (forall x:A, Acc R2 x -> Acc R1 x) -> forall a:A, Acc R2 a -> Acc Union a.
Lemma make_new_approximant :   forall A X:Ensemble U,     ~ Finite U A -> Approximant U A X -> Inhabited U (Setminus U A X).
Lemma approximants_grow :   forall A X:Ensemble U,     ~ Finite U A ->     forall n:nat, cardinal U X n -> Included U X A ->  exists Y : _, cardinal U Y (S n) /\ Included U Y A.
Lemma approximants_grow' :   forall A X:Ensemble U,     ~ Finite U A ->     forall n:nat, cardinal U X n -> Approximant U A X -> exists Y : _, cardinal U Y (S n) /\ Approximant U A Y.
Lemma approximant_can_be_any_size :   forall A X:Ensemble U,     ~ Finite U A ->     forall n:nat,  exists Y : _, cardinal U Y n /\ Approximant U A Y.
Lemma not_all_ex_not : forall P:U -> Prop, ~ (forall n:U, P n) ->  exists n : U, ~ P n.
Lemma not_all_not_ex : forall P:U -> Prop, ~ (forall n:U, ~ P n) ->  exists n : U, P n.
Lemma not_ex_all_not : forall P:U -> Prop, ~ (exists n : U, P n) -> forall n:U, ~ P n.
Lemma not_ex_not_all : forall P:U -> Prop, ~ (exists n : U, ~ P n) -> forall n:U, P n.
Lemma ex_not_not_all : forall P:U -> Prop, (exists n : U, ~ P n) -> ~ (forall n:U, P n).
Lemma all_not_not_ex : forall P:U -> Prop, (forall n:U, ~ P n) -> ~ (exists n : U, P n).
Lemma Even_or_Odd : forall x, Even x \/ Odd x.
Lemma double_below : forall n m, n<=m -> 2*n < 2*m+1.
Lemma double_above : forall n m, n<m -> 2*n+1 < 2*m.
Lemma Even_Odd_False : forall x, Even x -> Odd x -> False.
Lemma orb_even_odd : forall n, orb (even n) (odd n) = true.
Lemma negb_odd : forall n, negb (odd n) = even n.
Lemma negb_even : forall n, negb (even n) = odd n.
Lemma even_0 : even 0 = true.
Lemma odd_0 : odd 0 = false.
Lemma odd_1 : odd 1 = true.
Lemma even_1 : even 1 = false.
Lemma even_2 : even 2 = true.
Lemma odd_2 : odd 2 = false.
Lemma Odd_succ : forall n, Odd (S n) <-> Even n.
Lemma odd_succ : forall n, odd (S n) = even n.
Lemma even_succ : forall n, even (S n) = odd n.
Lemma Even_succ : forall n, Even (S n) <-> Odd n.
Lemma Even_succ_succ : forall n, Even (S (S n)) <-> Even n.
Lemma Odd_succ_succ : forall n, Odd (S (S n)) <-> Odd n.
Lemma even_succ_succ : forall n, even (S (S n)) = even n.
Lemma odd_succ_succ : forall n, odd (S (S n)) = odd n.
Lemma even_add : forall n m, even (n+m) = Bool.eqb (even n) (even m).
Lemma odd_add : forall n m, odd (n+m) = xorb (odd n) (odd m).
Lemma even_mul : forall n m, even (mul n m) = even n || even m.
Lemma odd_mul : forall n m, odd (mul n m) = odd n && odd m.
Lemma even_add_even : forall n m, Even m -> even (n+m) = even n.
Lemma odd_add_even : forall n m, Even m -> odd (n+m) = odd n.
Lemma even_add_mul_even : forall n m p, Even m -> even (n+m*p) = even n.
Lemma odd_add_mul_even : forall n m p, Even m -> odd (n+m*p) = odd n.
Lemma even_add_mul_2 : forall n m, even (n+2*m) = even n.
Lemma odd_add_mul_2 : forall n m, odd (n+2*m) = odd n.
Lemma height_non_negative : forall (s : t elt), avl s -> height s >= 0.
Lemma avl_node : forall x e l r, avl l -> avl r -> -(2) <= height l - height r <= 2 -> avl (Node l x e r (max (height l) (height r) + 1)).
Lemma height_0 : forall l, avl l -> height l = 0 -> l = Leaf _.
Lemma empty_avl : avl (empty elt).
Lemma create_avl : forall l x e r, avl l -> avl r ->  -(2) <= height l - height r <= 2 -> avl (create l x e r).
Lemma create_height : forall l x e r, avl l -> avl r ->  -(2) <= height l - height r <= 2 -> height (create l x e r) = max (height l) (height r) + 1.
Lemma bal_avl : forall l x e r, avl l -> avl r -> -(3) <= height l - height r <= 3 -> avl (bal l x e r).
Lemma bal_height_1 : forall l x e r, avl l -> avl r -> -(3) <= height l - height r <= 3 -> 0 <= height (bal l x e r) - max (height l) (height r) <= 1.
Lemma bal_height_2 : forall l x e r, avl l -> avl r -> -(2) <= height l - height r <= 2 -> height (bal l x e r) == max (height l) (height r) +1.
Lemma add_avl_1 :  forall m x e, avl m -> avl (add x e m) /\ 0 <= height (add x e m) - height m <= 1.
Lemma add_avl : forall m x e, avl m -> avl (add x e m).
Lemma remove_min_avl_1 : forall l x e r h, avl (Node l x e r h) -> avl (remove_min l x e r)#1 /\ 0 <= height (Node l x e r h) - height (remove_min l x e r)#1 <= 1.
Lemma remove_min_avl : forall l x e r h, avl (Node l x e r h) ->   avl (remove_min l x e r)#1.
Lemma merge_avl_1 : forall m1 m2, avl m1 -> avl m2 -> -(2) <= height m1 - height m2 <= 2 -> avl (merge m1 m2) /\ 0<= height (merge m1 m2) - max (height m1) (height m2) <=1.
Lemma merge_avl : forall m1 m2, avl m1 -> avl m2 -> -(2) <= height m1 - height m2 <= 2 -> avl (merge m1 m2).
Lemma remove_avl_1 : forall m x, avl m -> avl (remove x m) /\ 0 <= height m - height (remove x m) <= 1.
Lemma remove_avl : forall m x, avl m -> avl (remove x m).
Lemma join_avl_1 : forall l x d r, avl l -> avl r -> avl (join l x d r) /\ 0<= height (join l x d r) - max (height l) (height r) <= 1.
Lemma join_avl : forall l x d r, avl l -> avl r -> avl (join l x d r).
Lemma concat_avl : forall m1 m2, avl m1 -> avl m2 -> avl (concat m1 m2).
Lemma split_avl : forall m x, avl m -> avl (split x m)#l /\ avl (split x m)#r.
Lemma map_height : forall m, height (map f m) = height m.
Lemma map_avl : forall m, avl m -> avl (map f m).
Lemma mapi_height : forall m, height (mapi f m) = height m.
Lemma mapi_avl : forall m, avl m -> avl (mapi f m).
Lemma map_option_avl : forall m, avl m -> avl (map_option f m).
Lemma map2_opt_avl : forall m1 m2, avl m1 -> avl m2 -> avl (map2_opt m1 m2).
Lemma map2_avl : forall m1 m2, avl m1 -> avl m2 -> avl (map2 f m1 m2).
Lemma MapsTo_1 : forall m x y e, E.eq x y -> MapsTo x e m -> MapsTo y e m.
Lemma mem_1 : forall m x, In x m -> mem x m = true.
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Lemma empty_1 : Empty empty.
Lemma is_empty_1 : forall m, Empty m -> is_empty m = true.
Lemma is_empty_2 : forall m, is_empty m = true -> Empty m.
Lemma add_1 : forall m x y e, E.eq x y -> MapsTo y e (add x e m).
Lemma add_2 : forall m x y e e', ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Lemma add_3 : forall m x y e e', ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Lemma remove_1 : forall m x y, E.eq x y -> ~ In y (remove x m).
Lemma remove_2 : forall m x y e, ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Lemma remove_3 : forall m x y e, MapsTo y e (remove x m) -> MapsTo y e m.
Lemma find_1 : forall m x e, MapsTo x e m -> find x m = Some e.
Lemma find_2 : forall m x e, find x m = Some e -> MapsTo x e m.
Lemma fold_1 : forall m (A : Type) (i : A) (f : key -> elt -> A -> A),       fold f m i = fold_left (fun a p => f (fst p) (snd p) a) (elements m) i.
Lemma elements_1 : forall m x e,  MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Lemma elements_2 : forall m x e,  InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Lemma elements_3 : forall m, sort lt_key (elements m).
Lemma elements_3w : forall m, NoDupA eq_key (elements m).
Lemma cardinal_1 : forall m, cardinal m = length (elements m).
Lemma Equivb_Equivb : forall cmp m m', Equivb cmp m m' <-> Raw.Proofs.Equivb cmp m m'.
Lemma equal_1 : forall m m' cmp,  Equivb cmp m m' -> equal cmp m m' = true.
Lemma equal_2 : forall m m' cmp,  equal cmp m m' = true -> Equivb cmp m m'.
Lemma map_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)(f:elt->elt'),       MapsTo x e m -> MapsTo x (f e) (map f m).
Lemma map_2 : forall (elt elt':Type)(m:t elt)(x:key)(f:elt->elt'), In x (map f m) -> In x m.
Lemma mapi_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)       (f:key->elt->elt'), MapsTo x e m ->       exists y, E.eq y x /\ MapsTo x (f y e) (mapi f m).
Lemma mapi_2 : forall (elt elt':Type)(m: t elt)(x:key)       (f:key->elt->elt'), In x (mapi f m) -> In x m.
Lemma map2_1 : forall (elt elt' elt'':Type)(m: t elt)(m': t elt')   (x:key)(f:option elt->option elt'->option elt''),   In x m \/ In x m' ->   find x (map2 f m m') = f (find x m) (find x m').
Lemma map2_2 : forall (elt elt' elt'':Type)(m: t elt)(m': t elt')    (x:key)(f:option elt->option elt'->option elt''),    In x (map2 f m m') -> In x m \/ In x m'.
Lemma cons_cardinal_e : forall m e,  cardinal_e (Raw.cons m e) = (Raw.cardinal m + cardinal_e e)%nat.
Lemma cons_Cmp : forall c x1 x2 d1 d2 l1 l2,  X.eq x1 x2 -> D.eq d1 d2 ->
Lemma compare_aux_Cmp : forall e,  Cmp (compare_aux e) (flatten_e (fst e)) (flatten_e (snd e)).
Lemma compare_Cmp : forall m1 m2,   Cmp (compare_aux (Raw.cons m1 (Raw.End _), Raw.cons m2 (Raw.End _)))
Lemma eq_seq : forall m1 m2, eq m1 m2 <-> seq m1 m2.
Lemma lt_slt : forall m1 m2, lt m1 m2 <-> slt m1 m2.
Lemma eq_1 : forall (m m' : t), MapS.Equivb cmp m m' -> eq m m'.
Lemma eq_2 : forall m m', eq m m' -> MapS.Equivb cmp m m'.
Lemma eq_refl : forall m : t, eq m m.
Lemma eq_sym : forall m1 m2 : t, eq m1 m2 -> eq m2 m1.
Lemma eq_trans : forall m1 m2 m3 : t, eq m1 m2 -> eq m2 m3 -> eq m1 m3.
Lemma lt_trans : forall m1 m2 m3 : t, lt m1 m2 -> lt m2 m3 -> lt m1 m3.
Lemma lt_not_eq : forall m1 m2 : t, lt m1 m2 -> ~ eq m1 m2.
Lemma identity_sym : identity x y -> identity y x.
Lemma identity_trans : identity x y -> identity y z -> identity x z.
Lemma identity_congr : identity x y -> identity (f x) (f y).
Lemma not_identity_sym : notT (identity x y) -> notT (identity y x).
Lemma BigNring : semi_ring_theory 0 1 BigN.add BigN.mul BigN.eq.
Lemma BigNeqb_correct : forall x y, (x =? y) = true -> x==y.
Lemma BigNpower : power_theory 1 BigN.mul BigN.eq BigN.of_N BigN.pow.
Lemma BigNdiv : div_theory BigN.eq BigN.add BigN.mul (@id _)
Lemma pow_twice_r a b : a^(2*b) == a^b * a^b.
Lemma even_pow : forall a b, 0<b -> even (a^b) = even a.
Lemma odd_pow : forall a b, 0<b -> odd (a^b) = odd a.
Lemma pow_opp_even : forall a b, Even b -> (-a)^b == a^b.
Lemma pow_opp_odd : forall a b, Odd b -> (-a)^b == -(a^b).
Lemma pow_even_abs : forall a b, Even b -> a^b == (abs a)^b.
Lemma pow_even_nonneg : forall a b, Even b -> 0 <= a^b.
Lemma pow_odd_abs_sgn : forall a b, Odd b -> a^b == sgn a * (abs a)^b.
Lemma pow_odd_sgn : forall a b, 0<=b -> Odd b -> sgn (a^b) == sgn a.
Lemma abs_pow : forall a b, abs (a^b) == (abs a)^b.
Lemma lt_wf : well_founded lt.
Lemma lt_wf_rec1 : forall n (P:nat -> Set), (forall n, (forall m, m < n -> P m) -> P n) -> P n.
Lemma lt_wf_rec : forall n (P:nat -> Set), (forall n, (forall m, m < n -> P m) -> P n) -> P n.
Lemma lt_wf_ind : forall n (P:nat -> Prop), (forall n, (forall m, m < n -> P m) -> P n) -> P n.
Lemma gt_wf_rec : forall n (P:nat -> Set), (forall n, (forall m, n > m -> P m) -> P n) -> P n.
Lemma gt_wf_ind : forall n (P:nat -> Prop), (forall n, (forall m, n > m -> P m) -> P n) -> P n.
Lemma lt_wf_double_rec : forall P:nat -> nat -> Set,  (forall n m,    (forall p q, p < n -> P p q) ->    (forall p, p < m -> P n p) -> P n m) -> forall n m, P n m.
Lemma lt_wf_double_ind : forall P:nat -> nat -> Prop,   (forall n m,     (forall p (q:nat), p < n -> P p q) ->     (forall p, p < m -> P n p) -> P n m) -> forall n m, P n m.
Lemma well_founded_inv_rel_inv_lt_rel : forall (A:Set) (F:A -> nat -> Prop), well_founded (inv_lt_rel A F).
Lemma dec_inh_nat_subset_has_unique_least_element : forall P:nat->Prop, (forall n, P n \/ ~ P n) ->   (exists n, P n) -> has_unique_least_element le P.
Lemma minus_neq_O : forall n i:nat, (i < n)%nat -> (n - i)%nat <> 0%nat.
Lemma le_minusni_n : forall n i:nat, (i <= n)%nat -> (n - i <= n)%nat.
Lemma lt_minus_O_lt : forall m n:nat, (m < n)%nat -> (0 < n - m)%nat.
Lemma even_odd_cor : forall n:nat,  exists p : nat, n = (2 * p)%nat \/ n = S (2 * p).
Lemma le_double : forall m n:nat, (2 * m <= 2 * n)%nat -> (m <= n)%nat.
Lemma euclidian_division : forall x y:R,   y <> 0 ->   exists k : Z, (exists r : R, x = IZR k * y + r /\ 0 <= r < Rabs y).
Lemma tech8 : forall n i:nat, (n <= S n + i)%nat.
Lemma Rmin_case : forall r1 r2 (P:R -> Type), P r1 -> P r2 -> P (Rmin r1 r2).
Lemma Rmin_case_strong : forall r1 r2 (P:R -> Type),  (r1 <= r2 -> P r1) -> (r2 <= r1 -> P r2) -> P (Rmin r1 r2).
Lemma Rmin_Rgt_l : forall r1 r2 r, Rmin r1 r2 > r -> r1 > r /\ r2 > r.
Lemma Rmin_Rgt_r : forall r1 r2 r, r1 > r /\ r2 > r -> Rmin r1 r2 > r.
Lemma Rmin_Rgt : forall r1 r2 r, Rmin r1 r2 > r <-> r1 > r /\ r2 > r.
Lemma Rmin_l : forall x y:R, Rmin x y <= x.
Lemma Rmin_r : forall x y:R, Rmin x y <= y.
Lemma Rmin_left : forall x y, x <= y -> Rmin x y = x.
Lemma Rmin_right : forall x y, y <= x -> Rmin x y = y.
Lemma Rle_min_compat_r : forall x y z, x <= y -> Rmin x z <= Rmin y z.
Lemma Rle_min_compat_l : forall x y z, x <= y -> Rmin z x <= Rmin z y.
Lemma Rmin_comm : forall x y:R, Rmin x y = Rmin y x.
Lemma Rmin_stable_in_posreal : forall x y:posreal, 0 < Rmin x y.
Lemma Rmin_pos : forall x y:R, 0 < x -> 0 < y -> 0 < Rmin x y.
Lemma Rmin_glb : forall x y z:R, z <= x -> z <= y -> z <= Rmin x y.
Lemma Rmin_glb_lt : forall x y z:R, z < x -> z < y -> z < Rmin x y.
Lemma Rmax_case : forall r1 r2 (P:R -> Type), P r1 -> P r2 -> P (Rmax r1 r2).
Lemma Rmax_case_strong : forall r1 r2 (P:R -> Type), (r2 <= r1 -> P r1) -> (r1 <= r2 -> P r2) -> P (Rmax r1 r2).
Lemma Rmax_Rle : forall r1 r2 r, r <= Rmax r1 r2 <-> r <= r1 \/ r <= r2.
Lemma Rmax_comm : forall x y:R, Rmax x y = Rmax y x.
Lemma Rmax_l : forall x y:R, x <= Rmax x y.
Lemma Rmax_r : forall x y:R, y <= Rmax x y.
Lemma Rmax_left : forall x y, y <= x -> Rmax x y = x.
Lemma Rmax_right : forall x y, x <= y -> Rmax x y = y.
Lemma Rle_max_compat_r : forall x y z, x <= y -> Rmax x z <= Rmax y z.
Lemma Rle_max_compat_l : forall x y z, x <= y -> Rmax z x <= Rmax z y.
Lemma RmaxRmult : forall (p q:R) r, 0 <= r -> Rmax (r * p) (r * q) = r * Rmax p q.
Lemma Rmax_stable_in_negreal : forall x y:negreal, Rmax x y < 0.
Lemma Rmax_lub : forall x y z:R, x <= z -> y <= z -> Rmax x y <= z.
Lemma Rmax_lub_lt : forall x y z:R, x < z -> y < z -> Rmax x y < z.
Lemma Rmax_neg : forall x y:R, x < 0 -> y < 0 -> Rmax x y < 0.
Lemma Rcase_abs : forall r, {r < 0} + {r >= 0}.
Lemma Rabs_R0 : Rabs 0 = 0.
Lemma Rabs_R1 : Rabs 1 = 1.
Lemma Rabs_no_R0 : forall r, r <> 0 -> Rabs r <> 0.
Lemma Rabs_left : forall r, r < 0 -> Rabs r = - r.
Lemma Rabs_right : forall r, r >= 0 -> Rabs r = r.
Lemma Rabs_left1 : forall a:R, a <= 0 -> Rabs a = - a.
Lemma Rabs_pos : forall x:R, 0 <= Rabs x.
Lemma Rle_abs : forall x:R, x <= Rabs x.
Lemma Rabs_pos_eq : forall x:R, 0 <= x -> Rabs x = x.
Lemma Rabs_Rabsolu : forall x:R, Rabs (Rabs x) = Rabs x.
Lemma Rabs_pos_lt : forall x:R, x <> 0 -> 0 < Rabs x.
Lemma Rabs_minus_sym : forall x y:R, Rabs (x - y) = Rabs (y - x).
Lemma Rabs_mult : forall x y:R, Rabs (x * y) = Rabs x * Rabs y.
Lemma Rabs_Rinv : forall r, r <> 0 -> Rabs (/ r) = / Rabs r.
Lemma Rabs_Ropp : forall x:R, Rabs (- x) = Rabs x.
Lemma Rabs_triang : forall a b:R, Rabs (a + b) <= Rabs a + Rabs b.
Lemma Rabs_triang_inv : forall a b:R, Rabs a - Rabs b <= Rabs (a - b).
Lemma Rabs_triang_inv2 : forall a b:R, Rabs (Rabs a - Rabs b) <= Rabs (a - b).
Lemma Rabs_def1 : forall x a:R, x < a -> - a < x -> Rabs x < a.
Lemma Rabs_def2 : forall x a:R, Rabs x < a -> x < a /\ - a < x.
Lemma RmaxAbs : forall (p q:R) r, p <= q -> q <= r -> Rabs q <= Rmax (Rabs p) (Rabs r).
Lemma Rabs_Zabs : forall z:Z, Rabs (IZR z) = IZR (Z.abs z).
Lemma abs_IZR : forall z, IZR (Z.abs z) = Rabs (IZR z).
Lemma lt_antirefl : forall x, ~ lt x x.
Lemma lt_eq : forall x y z, lt x y -> eq y z -> lt x z.
Lemma eq_lt : forall x y z, eq x y -> lt y z -> lt x z.
Lemma lt_total : forall x y, lt x y \/ eq x y \/ lt y x.
Lemma le_lteq x y : TO.le x y <-> lt x y \/ eq x y.
Lemma le_eq x y z : ~lt x y -> eq y z -> ~lt x z. Proof. order. Qed.
Lemma eq_le x y z : eq x y -> ~lt y z -> ~lt x z. Proof. order. Qed.
Lemma neq_eq x y z : ~eq x y -> eq y z -> ~eq x z. Proof. order. Qed.
Lemma eq_neq x y z : eq x y -> ~eq y z -> ~eq x z. Proof. order. Qed.
Lemma le_lt_trans x y z : ~lt y x -> lt y z -> lt x z. Proof. order. Qed.
Lemma lt_le_trans x y z : lt x y -> ~lt z y -> lt x z. Proof. order. Qed.
Lemma le_neq x y : ~lt x y -> ~eq x y -> lt y x. Proof. order. Qed.
Lemma le_trans x y z : ~lt y x -> ~lt z y -> ~lt z x. Proof. order. Qed.
Lemma le_antisym x y : ~lt y x -> ~lt x y -> eq x y. Proof. order. Qed.
Lemma neq_sym x y : ~eq x y -> ~eq y x. Proof. order. Qed.
Lemma lt_le x y : lt x y -> ~lt y x. Proof. order. Qed.
Lemma gt_not_eq x y : lt y x -> ~ eq x y. Proof. order. Qed.
Lemma eq_not_lt x y : eq x y -> ~ lt x y. Proof. order. Qed.
Lemma eq_not_gt x y : eq x y -> ~ lt y x. Proof. order. Qed.
Lemma lt_not_gt x y : lt x y -> ~ lt y x. Proof. order. Qed.
Lemma elim_compare_eq :  forall x y : t,  eq x y -> exists H : eq x y, compare x y = EQ H.
Lemma elim_compare_lt :  forall x y : t,  lt x y -> exists H : lt x y, compare x y = LT H.
Lemma elim_compare_gt :  forall x y : t,  lt y x -> exists H : lt y x, compare x y = GT H.
Lemma lt_dec : forall x y : t, {lt x y} + {~ lt x y}.
Lemma eqb_alt :   forall x y, eqb x y = match compare x y with EQ _ => true | _ => false end.
Lemma In_eq : forall l x y, eq x y -> In x l -> In y l.
Lemma ListIn_In : forall l x, List.In x l -> In x l.
Lemma Inf_lt : forall l x y, lt x y -> Inf y l -> Inf x l.
Lemma Inf_eq : forall l x y, eq x y -> Inf y l -> Inf x l.
Lemma Sort_Inf_In : forall l x a, Sort l -> Inf a l -> In x l -> lt a x.
Lemma ListIn_Inf : forall l x, (forall y, List.In y l -> lt x y) -> Inf x l.
Lemma In_Inf : forall l x, (forall y, In y l -> lt x y) -> Inf x l.
Lemma Inf_alt : forall l x, Sort l -> (Inf x l <-> (forall y, In y l -> lt x y)).
Lemma Sort_NoDup : forall l, Sort l -> NoDup l.
Lemma eqke_eqk : forall x x', eqke x x' -> eqk x x'.
Lemma ltk_right_r : forall x k e e', ltk x (k,e) -> ltk x (k,e').
Lemma ltk_right_l : forall x k e e', ltk (k,e) x -> ltk (k,e') x.
Lemma eqk_refl : forall e, eqk e e.
Lemma eqke_refl : forall e, eqke e e.
Lemma eqk_sym : forall e e', eqk e e' -> eqk e' e.
Lemma eqke_sym : forall e e', eqke e e' -> eqke e' e.
Lemma eqk_trans : forall e e' e'', eqk e e' -> eqk e' e'' -> eqk e e''.
Lemma eqke_trans : forall e e' e'', eqke e e' -> eqke e' e'' -> eqke e e''.
Lemma ltk_trans : forall e e' e'', ltk e e' -> ltk e' e'' -> ltk e e''.
Lemma ltk_not_eqk : forall e e', ltk e e' -> ~ eqk e e'.
Lemma ltk_not_eqke : forall e e', ltk e e' -> ~eqke e e'.
Lemma eqk_not_ltk : forall x x', eqk x x' -> ~ltk x x'.
Lemma ltk_eqk : forall e e' e'', ltk e e' -> eqk e' e'' -> ltk e e''.
Lemma eqk_ltk : forall e e' e'', eqk e e' -> ltk e' e'' -> ltk e e''.
Lemma InA_eqke_eqk :    forall x m, InA eqke x m -> InA eqk x m.
Lemma In_alt : forall k l, In k l <-> exists e, InA eqk (k,e) l.
Lemma MapsTo_eq : forall l x y e, eq x y -> MapsTo x e l -> MapsTo y e l.
Lemma In_eq : forall l x y, eq x y -> In x l -> In y l.
Lemma Inf_eq : forall l x x', eqk x x' -> Inf x' l -> Inf x l.
Lemma Inf_lt : forall l x x', ltk x x' -> Inf x' l -> Inf x l.
Lemma Sort_Inf_In :     forall l p q, Sort l -> Inf q l -> InA eqk p l -> ltk q p.
Lemma Sort_Inf_NotIn :     forall l k e, Sort l -> Inf (k,e) l ->  ~In k l.
Lemma Sort_NoDupA: forall l, Sort l -> NoDupA eqk l.
Lemma Sort_In_cons_1 : forall e l e', Sort (e::l) -> InA eqk e' l -> ltk e e'.
Lemma Sort_In_cons_2 : forall l e e', Sort (e::l) -> InA eqk e' (e::l) ->     ltk e e' \/ eqk e e'.
Lemma Sort_In_cons_3 :   forall x l k e, Sort ((k,e)::l) -> In x l -> ~eq x k.
Lemma In_inv : forall k k' e l, In k ((k',e) :: l) -> eq k k' \/ In k l.
Lemma In_inv_2 : forall k k' e e' l,     InA eqk (k, e) ((k', e') :: l) -> ~ eq k k' -> InA eqk (k, e) l.
Lemma In_inv_3 : forall x x' l,     InA eqke x (x' :: l) -> ~ eqk x x' -> InA eqke x l.
Lemma mod_eq : forall a b, b~=0 -> a mod b == a - b*(a/b).
Lemma mod_bound_abs : forall a b, b~=0 -> abs (a mod b) < abs b.
Lemma div_opp_opp : forall a b, b~=0 -> -a/-b == a/b.
Lemma mod_opp_opp : forall a b, b~=0 -> (-a) mod (-b) == - (a mod b).
Lemma div_opp_l_z : forall a b, b~=0 -> a mod b == 0 -> (-a)/b == -(a/b).
Lemma div_opp_l_nz : forall a b, b~=0 -> a mod b ~= 0 -> (-a)/b == -(a/b)-1.
Lemma mod_opp_l_z : forall a b, b~=0 -> a mod b == 0 -> (-a) mod b == 0.
Lemma mod_opp_l_nz : forall a b, b~=0 -> a mod b ~= 0 -> (-a) mod b == b - a mod b.
Lemma div_opp_r_z : forall a b, b~=0 -> a mod b == 0 -> a/(-b) == -(a/b).
Lemma div_opp_r_nz : forall a b, b~=0 -> a mod b ~= 0 -> a/(-b) == -(a/b)-1.
Lemma mod_opp_r_z : forall a b, b~=0 -> a mod b == 0 -> a mod (-b) == 0.
Lemma mod_opp_r_nz : forall a b, b~=0 -> a mod b ~= 0 -> a mod (-b) == (a mod b) - b.
Lemma mod_sign_nz : forall a b, b~=0 -> a mod b ~= 0 -> sgn (a mod b) == sgn b.
Lemma mod_sign : forall a b, b~=0 -> sgn (a mod b) ~= -sgn b.
Lemma mod_sign_mul : forall a b, b~=0 -> 0 <= (a mod b) * b.
Lemma div_same : forall a, a~=0 -> a/a == 1.
Lemma mod_same : forall a, a~=0 -> a mod a == 0.
Lemma div_0_l: forall a, a~=0 -> 0/a == 0.
Lemma mod_0_l: forall a, a~=0 -> 0 mod a == 0.
Lemma div_1_r: forall a, a/1 == a.
Lemma mod_1_r: forall a, a mod 1 == 0.
Lemma div_1_l: forall a, 1<a -> 1/a == 0.
Lemma mod_1_l: forall a, 1<a -> 1 mod a == 1.
Lemma div_mul : forall a b, b~=0 -> (a*b)/b == a.
Lemma mod_mul : forall a b, b~=0 -> (a*b) mod b == 0.
Lemma div_str_pos : forall a b, 0<b<=a -> 0 < a/b.
Lemma div_small_iff : forall a b, b~=0 -> (a/b==0 <-> 0<=a<b \/ b<a<=0).
Lemma mod_small_iff : forall a b, b~=0 -> (a mod b == a <-> 0<=a<b \/ b<a<=0).
Lemma div_lt : forall a b, 0<a -> 1<b -> a/b < a.
Lemma div_le_mono : forall a b c, 0<c -> a<=b -> a/c <= b/c.
Lemma mul_div_le : forall a b, 0<b -> b*(a/b) <= a.
Lemma mul_div_ge : forall a b, b<0 -> a <= b*(a/b).
Lemma mul_succ_div_gt: forall a b, 0<b -> a < b*(S (a/b)).
Lemma mul_succ_div_lt: forall a b, b<0 -> b*(S (a/b)) < a.
Lemma div_exact : forall a b, b~=0 -> (a == b*(a/b) <-> a mod b == 0).
Lemma div_le_compat_l: forall p q r, 0<=p -> 0<q<=r -> p/r <= p/q.
Lemma mod_add : forall a b c, c~=0 -> (a + b * c) mod c == a mod c.
Lemma div_add : forall a b c, c~=0 -> (a + b * c) / c == a / c + b.
Lemma div_add_l: forall a b c, b~=0 -> (a * b + c) / b == a + c / b.
Lemma div_mul_cancel_r : forall a b c, b~=0 -> c~=0 -> (a*c)/(b*c) == a/b.
Lemma div_mul_cancel_l : forall a b c, b~=0 -> c~=0 -> (c*a)/(c*b) == a/b.
Lemma mul_mod_distr_l: forall a b c, b~=0 -> c~=0 -> (c*a) mod (c*b) == c * (a mod b).
Lemma mul_mod_distr_r: forall a b c, b~=0 -> c~=0 -> (a*c) mod (b*c) == (a mod b) * c.
Lemma mul_mod_idemp_l : forall a b n, n~=0 -> ((a mod n)*b) mod n == (a*b) mod n.
Lemma mul_mod_idemp_r : forall a b n, n~=0 -> (a*(b mod n)) mod n == (a*b) mod n.
Lemma add_mod_idemp_l : forall a b n, n~=0 -> ((a mod n)+b) mod n == (a+b) mod n.
Lemma add_mod_idemp_r : forall a b n, n~=0 -> (a+(b mod n)) mod n == (a+b) mod n.
Lemma div_div : forall a b c, b~=0 -> 0<c -> (a/b)/c == a/(b*c).
Lemma rem_mul_r : forall a b c, b~=0 -> 0<c -> a mod (b*c) == a mod b + b*((a/b) mod c).
Lemma acc_A_sum : forall x:A, Acc leA x -> Acc Le_AsB (inl B x).
Lemma acc_B_sum :   well_founded leA -> forall x:B, Acc leB x -> Acc Le_AsB (inr A x).
Lemma wf_disjoint_sum :   well_founded leA -> well_founded leB -> well_founded Le_AsB.
Lemma f_incr_implies_g_incr_interv : forall f g:R->R, forall lb ub,      lb < ub ->      (forall x y, lb <= x -> x < y -> y <= ub -> f x < f y) ->      (forall x, f lb <= x -> x <= f ub -> (comp f g) x = id x) ->      (forall x , f lb <= x -> x <= f ub -> lb <= g x <= ub) ->      (forall x y, f lb <= x -> x < y -> y <= f ub -> g x < g y).
Lemma derivable_pt_id_interv : forall (lb ub x:R),      lb <= x <= ub ->      derivable_pt id x.
Lemma pr_nu_var2_interv : forall (f g : R -> R) (lb ub x : R) (pr1 : derivable_pt f x)      (pr2 : derivable_pt g x),      lb < ub ->      lb < x < ub ->      (forall h : R, lb < h < ub -> f h = g h) -> derive_pt f x pr1 = derive_pt g x pr2.
Lemma leftinv_is_rightinv : forall (f g:R->R),      (forall x y, x < y -> f x < f y) ->      (forall x, (comp f g) x = id x) ->      (forall x, (comp g f) x = id x).
Lemma leftinv_is_rightinv_interv : forall (f g:R->R) (lb ub:R),      (forall x y, lb <= x -> x < y -> y <= ub -> f x < f y) ->      (forall y, f lb <= y -> y <= f ub -> (comp f g) y = id y) ->      (forall x, f lb <= x -> x <= f ub -> lb <= g x <= ub) ->      forall x,      lb <= x <= ub ->      (comp g f) x = id x.
Lemma IVT_interv_prelim0 : forall (x y:R) (P:R->bool) (N:nat),      x < y ->      x <= Dichotomy_ub x y P N <= y /\ x <= Dichotomy_lb x y P N <= y.
Lemma IVT_interv_prelim1 : forall (x y x0:R) (D : R -> bool),      x < y ->      Un_cv (dicho_up x y D) x0 ->      x <= x0 <= y.
Lemma IVT_interv : forall (f : R -> R) (x y : R),      (forall a, x <= a <= y -> continuity_pt f a) ->      x < y ->      f x < 0 ->      0 < f y ->      {z : R | x <= z <= y /\ f z = 0}.
Lemma f_interv_is_interv : forall (f:R->R) (lb ub y:R),      lb < ub ->      f lb <= y <= f ub ->      (forall x, lb <=  x <= ub -> continuity_pt f x) ->      {x | lb <= x <= ub /\ f x = y}.
Lemma continuity_pt_recip_prelim : forall (f g:R->R) (lb ub : R) (Pr1:lb < ub),      (forall x y, lb <= x -> x < y -> y <= ub -> f x < f y) ->      (forall x, lb <= x <= ub -> (comp g f) x = id x) ->      (forall a, lb <= a <= ub -> continuity_pt f a) ->      forall b,      f lb < b < f ub ->      continuity_pt g b.
Lemma continuity_pt_recip_interv : forall (f g:R->R) (lb ub : R) (Pr1:lb < ub),      (forall x y, lb <= x -> x < y -> y <= ub -> f x < f y) ->      (forall x, f lb <= x -> x <= f ub -> (comp f g) x = id x) ->      (forall x, f lb <= x -> x <= f ub -> lb <= g x <= ub) ->      (forall a, lb <= a <= ub -> continuity_pt f a) ->      forall b,      f lb < b < f ub ->      continuity_pt g b.
Lemma derivable_pt_lim_recip_interv : forall (f g:R->R) (lb ub x:R)      (Prf:forall a : R, g lb <= a <= g ub -> derivable_pt f a) (Prg : continuity_pt g x),      lb < ub ->      lb < x < ub ->      forall (Prg_incr:g lb <= g x <= g ub),      (forall x, lb <= x <= ub -> (comp f g) x = id x) ->      derive_pt f (g x) (Prf (g x) Prg_incr) <> 0 ->      derivable_pt_lim g x (1 / derive_pt f (g x) (Prf (g x) Prg_incr)).
Lemma derivable_pt_recip_interv_prelim0 : forall (f g : R -> R) (lb ub x : R)      (Prf : forall a : R, g lb <= a <= g ub -> derivable_pt f a),      continuity_pt g x ->      lb < ub ->      lb < x < ub ->      forall Prg_incr : g lb <= g x <= g ub,      (forall x0 : R, lb <= x0 <= ub -> comp f g x0 = id x0) ->      derive_pt f (g x) (Prf (g x) Prg_incr) <> 0 ->      derivable_pt g x.
Lemma derivable_pt_recip_interv_prelim1 :forall (f g:R->R) (lb ub x : R),        lb < ub ->        f lb < x < f ub ->        (forall x : R, f lb <= x -> x <= f ub -> comp f g x = id x) ->        (forall x : R, f lb <= x -> x <= f ub -> lb <= g x <= ub) ->        (forall x y : R, lb <= x -> x < y -> y <= ub -> f x < f y) ->        (forall a : R, lb <= a <= ub -> derivable_pt f a) ->        derivable_pt f (g x).
Lemma derivable_pt_recip_interv : forall (f g:R->R) (lb ub x : R)        (lb_lt_ub:lb < ub) (x_encad:f lb < x < f ub)        (f_eq_g:forall x : R, f lb <= x -> x <= f ub -> comp f g x = id x)        (g_wf:forall x : R, f lb <= x -> x <= f ub -> lb <= g x <= ub)        (f_incr:forall x y : R, lb <= x -> x < y -> y <= ub -> f x < f y)        (f_derivable:forall a : R, lb <= a <= ub -> derivable_pt f a),        derive_pt f (g x)             (derivable_pt_recip_interv_prelim1 f g lb ub x lb_lt_ub             x_encad f_eq_g g_wf f_incr f_derivable)        <> 0 ->        derivable_pt g x.
Lemma derive_pt_recip_interv_prelim0 : forall (f g:R->R) (lb ub x:R)      (Prf:derivable_pt f (g x)) (Prg:derivable_pt g x),      lb < ub ->      lb < x < ub ->      (forall x, lb < x < ub -> (comp f g) x = id x) ->      derive_pt f (g x) Prf <> 0 ->      derive_pt g x Prg = 1 / (derive_pt f (g x) Prf).
Lemma derive_pt_recip_interv_prelim1_0 : forall (f g:R->R) (lb ub x:R),       lb < ub ->      f lb < x < f ub ->      (forall x y : R, lb <= x -> x < y -> y <= ub -> f x < f y) ->      (forall x : R, f lb <= x -> x <= f ub -> lb <= g x <= ub) ->      (forall x, f lb <= x -> x <= f ub -> (comp f g) x = id x) ->      lb < g x < ub.
Lemma derive_pt_recip_interv_prelim1_1 : forall (f g:R->R) (lb ub x:R),       lb < ub ->      f lb < x < f ub ->      (forall x y : R, lb <= x -> x < y -> y <= ub -> f x < f y) ->      (forall x : R, f lb <= x -> x <= f ub -> lb <= g x <= ub) ->      (forall x, f lb <= x -> x <= f ub -> (comp f g) x = id x) ->      lb <= g x <= ub.
Lemma derive_pt_recip_interv : forall (f g:R->R) (lb ub x:R)      (lb_lt_ub:lb < ub) (x_encad:f lb < x < f ub)      (f_incr:forall x y : R, lb <= x -> x < y -> y <= ub -> f x < f y)      (g_wf:forall x : R, f lb <= x -> x <= f ub -> lb <= g x <= ub)      (Prf:forall a : R, lb <= a <= ub -> derivable_pt f a)      (f_eq_g:forall x, f lb <= x -> x <= f ub -> (comp f g) x = id x)      (Df_neq:derive_pt f (g x) (derivable_pt_recip_interv_prelim1 f g lb ub x                lb_lt_ub x_encad f_eq_g g_wf f_incr Prf) <> 0),      derive_pt g x (derivable_pt_recip_interv f g lb ub x lb_lt_ub x_encad f_eq_g                g_wf f_incr Prf Df_neq)      =      1 / (derive_pt f (g x) (Prf (g x) (derive_pt_recip_interv_prelim1_1 f g lb ub x      lb_lt_ub x_encad f_incr g_wf f_eq_g))).
Lemma ub_lt_2_pos : forall x ub lb, lb < x -> x < ub -> 0 < (ub-lb)/2.
Lemma Ball_in_inter : forall c1 c2 r1 r2 x, Boule c1 r1 x -> Boule c2 r2 x -> {r3 : posreal | forall y, Boule x r3 y -> Boule c1 r1 y /\ Boule c2 r2 y}.
Lemma Boule_center : forall x r, Boule x r x.
Lemma derivable_pt_lim_CVU : forall (fn fn':nat -> R -> R) (f g:R->R)     (x:R) c r, Boule c r x ->     (forall y n, Boule c r y -> derivable_pt_lim (fn n) y (fn' n y)) ->     (forall y, Boule c r y -> Un_cv (fun n => fn n y) (f y)) ->     (CVU fn' g c r) ->     (forall y, Boule c r y -> continuity_pt g y) ->     derivable_pt_lim f x (g x).
Lemma eqke_eqk : forall x x', eqke x x' -> eqk x x'.
Lemma eqk_refl : forall e, eqk e e.
Lemma eqke_refl : forall e, eqke e e.
Lemma eqk_sym : forall e e', eqk e e' -> eqk e' e.
Lemma eqke_sym : forall e e', eqke e e' -> eqke e' e.
Lemma eqk_trans : forall e e' e'', eqk e e' -> eqk e' e'' -> eqk e e''.
Lemma eqke_trans : forall e e' e'', eqke e e' -> eqke e' e'' -> eqke e e''.
Lemma InA_eqke_eqk :    forall x m, InA eqke x m -> InA eqk x m.
Lemma InA_eqk : forall p q m, eqk p q -> InA eqk p m -> InA eqk q m.
Lemma In_alt : forall k l, In k l <-> exists e, InA eqk (k,e) l.
Lemma MapsTo_eq : forall l x y e, eq x y -> MapsTo x e l -> MapsTo y e l.
Lemma In_eq : forall l x y, eq x y -> In x l -> In y l.
Lemma In_inv : forall k k' e l, In k ((k',e) :: l) -> eq k k' \/ In k l.
Lemma In_inv_2 : forall k k' e e' l,     InA eqk (k, e) ((k', e') :: l) -> ~ eq k k' -> InA eqk (k, e) l.
Lemma In_inv_3 : forall x x' l,     InA eqke x (x' :: l) -> ~ eqk x x' -> InA eqke x l.
Lemma Strict_inclusion_is_transitive_with_inclusion : forall x y z:Ensemble U,  Strict_Included U x y -> Included U y z -> Strict_Included U x z.
Lemma Strict_inclusion_is_transitive_with_inclusion_left : forall x y z:Ensemble U,  Included U x y -> Strict_Included U y z -> Strict_Included U x z.
Lemma Strict_inclusion_is_transitive : Transitive (Ensemble U) (Strict_Included U).
Lemma Zsqrt_equiv : forall n, Zsqrt_plain n = Z.sqrt n.
Lemma Alembert_C1 : forall An:nat -> R,   (forall n:nat, 0 < An n) ->   Un_cv (fun n:nat => Rabs (An (S n) / An n)) 0 ->   { l:R | Un_cv (fun N:nat => sum_f_R0 An N) l }.
Lemma Alembert_C2 : forall An:nat -> R,   (forall n:nat, An n <> 0) ->   Un_cv (fun n:nat => Rabs (An (S n) / An n)) 0 ->   { l:R | Un_cv (fun N:nat => sum_f_R0 An N) l }.
Lemma AlembertC3_step1 : forall (An:nat -> R) (x:R),   x <> 0 ->   (forall n:nat, An n <> 0) ->   Un_cv (fun n:nat => Rabs (An (S n) / An n)) 0 ->   { l:R | Pser An x l }.
Lemma AlembertC3_step2 : forall (An:nat -> R) (x:R), x = 0 -> { l:R | Pser An x l }.
Lemma Alembert_C4 : forall (An:nat -> R) (k:R),   0 <= k < 1 ->   (forall n:nat, 0 < An n) ->   Un_cv (fun n:nat => Rabs (An (S n) / An n)) k ->   { l:R | Un_cv (fun N:nat => sum_f_R0 An N) l }.
Lemma Alembert_C5 : forall (An:nat -> R) (k:R),   0 <= k < 1 ->   (forall n:nat, An n <> 0) ->   Un_cv (fun n:nat => Rabs (An (S n) / An n)) k ->   { l:R | Un_cv (fun N:nat => sum_f_R0 An N) l }.
Lemma Alembert_C6 : forall (An:nat -> R) (x k:R),   0 < k ->   (forall n:nat, An n <> 0) ->   Un_cv (fun n:nat => Rabs (An (S n) / An n)) k ->   Rabs x < / k -> { l:R | Pser An x l }.
Lemma spec_WO : forall h,  zn2z_to_Z wB to_Z (WO h) = (to_Z h)*wB.
Lemma spec_OW : forall l,  zn2z_to_Z wB to_Z (OW l) = to_Z l.
Lemma spec_WW : forall h l, zn2z_to_Z wB to_Z (WW h l) = (to_Z h)*wB + to_Z l.
Lemma add_0_l : forall x, 0 + x == x.
Lemma add_comm : forall x y, x + y == y + x.
Lemma add_assoc : forall x y z, x + (y + z) == x + y + z.
Lemma mul_1_l : forall x, 1 * x == x.
Lemma mul_comm : forall x y, x * y == y * x.
Lemma mul_assoc : forall x y z, x * (y * z) == x * y * z.
Lemma mul_add_distr_r : forall x y z, (x+y)*z == x*z + y*z.
Lemma add_opp_r : forall x y, x + - y == x-y.
Lemma add_opp_diag_r : forall x, x + - x == 0.
Lemma CyclicRing : ring_theory 0 1 ZnZ.add ZnZ.mul ZnZ.sub ZnZ.opp eq.
Lemma eqb_eq : forall x y, eqb x y = true <-> x == y.
Lemma eqb_correct : forall x y, eqb x y = true -> x==y.
Lemma append_assoc_0 : forall (i j : positive), append i (xO j) = append (append i (xO xH)) j.
Lemma append_assoc_1 : forall (i j : positive), append i (xI j) = append (append i (xI xH)) j.
Lemma append_neutral_r : forall (i : positive), append i xH = i.
Lemma append_neutral_l : forall (i : positive), append xH i = i.
Lemma gleaf : forall (i : positive), find i (Leaf : t A) = None.
Lemma rleaf : forall (i : positive), remove i (Leaf : t A) = Leaf.
Lemma xelements_correct:     forall (m: t A) (i j : positive) (v: A),     find i m = Some v -> List.In (append j i, v) (xelements m j).
Lemma xfind_left :     forall (j i : positive) (m1 m2 : t A) (o : option A) (v : A),     xfind i (append j (xO xH)) m1 = Some v -> xfind i j (Node m1 o m2) = Some v.
Lemma xelements_ii :     forall (m: t A) (i j : positive) (v: A),     List.In (xI i, v) (xelements m (xI j)) -> List.In (i, v) (xelements m j).
Lemma xelements_io :     forall (m: t A) (i j : positive) (v: A),     ~List.In (xI i, v) (xelements m (xO j)).
Lemma xelements_oo :     forall (m: t A) (i j : positive) (v: A),     List.In (xO i, v) (xelements m (xO j)) -> List.In (i, v) (xelements m j).
Lemma xelements_oi :     forall (m: t A) (i j : positive) (v: A),     ~List.In (xO i, v) (xelements m (xI j)).
Lemma xelements_ih :     forall (m1 m2: t A) (o: option A) (i : positive) (v: A),     List.In (xI i, v) (xelements (Node m1 o m2) xH) -> List.In (i, v) (xelements m2 xH).
Lemma xelements_oh :     forall (m1 m2: t A) (o: option A) (i : positive) (v: A),     List.In (xO i, v) (xelements (Node m1 o m2) xH) -> List.In (i, v) (xelements m1 xH).
Lemma xelements_hi :     forall (m: t A) (i : positive) (v: A),     ~List.In (xH, v) (xelements m (xI i)).
Lemma xelements_ho :     forall (m: t A) (i : positive) (v: A),     ~List.In (xH, v) (xelements m (xO i)).
Lemma find_xfind_h :     forall (m: t A) (i: positive), find i m = xfind i xH m.
Lemma xelements_complete:     forall (i j : positive) (m: t A) (v: A),     List.In (i, v) (xelements m j) -> xfind i j m = Some v.
Lemma cardinal_1 :  forall (m: t A), cardinal m = length (elements m).
Lemma mem_find :   forall m x, mem x m = match find x m with None => false | _ => true end.
Lemma Empty_alt : forall m, Empty m <-> forall a, find a m = None.
Lemma Empty_Node : forall l o r, Empty (Node l o r) <-> o=None /\ Empty l /\ Empty r.
Lemma mem_1 : forall m x, In x m -> mem x m = true.
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Lemma MapsTo_1 : E.eq x y -> MapsTo x e m -> MapsTo y e m.
Lemma find_1 : MapsTo x e m -> find x m = Some e.
Lemma find_2 : find x m = Some e -> MapsTo x e m.
Lemma empty_1 : Empty empty.
Lemma is_empty_1 : Empty m -> is_empty m = true.
Lemma is_empty_2 : is_empty m = true -> Empty m.
Lemma add_1 : E.eq x y -> MapsTo y e (add x e m).
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Lemma remove_1 : E.eq x y -> ~ In y (remove x m).
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Lemma remove_3 : MapsTo y e (remove x m) -> MapsTo y e m.
Lemma elements_1 :    MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Lemma elements_2 :    InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Lemma xelements_bits_lt_1 : forall p p0 q m v,    List.In (p0,v) (xelements m (append p (xO q))) -> E.bits_lt p0 p.
Lemma xelements_bits_lt_2 : forall p p0 q m v,    List.In (p0,v) (xelements m (append p (xI q))) -> E.bits_lt p p0.
Lemma xelements_sort : forall p, sort lt_key (xelements m p).
Lemma elements_3 : sort lt_key (elements m).
Lemma elements_3w : NoDupA eq_key (elements m).
Lemma xgmapi:     forall (A B: Type) (f: positive -> A -> B) (i j : positive) (m: t A),     find i (xmapi f m j) = option_map (f (append j i)) (find i m).
Lemma mapi_1 :   forall (elt elt':Type)(m: t elt)(x:key)(e:elt)(f:key->elt->elt'),   MapsTo x e m ->   exists y, E.eq y x /\ MapsTo x (f y e) (mapi f m).
Lemma mapi_2 :   forall (elt elt':Type)(m: t elt)(x:key)(f:key->elt->elt'),   In x (mapi f m) -> In x m.
Lemma map_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)(f:elt->elt'),   MapsTo x e m -> MapsTo x (f e) (map f m).
Lemma map_2 : forall (elt elt':Type)(m: t elt)(x:key)(f:elt->elt'),   In x (map f m) -> In x m.
Lemma xgmap2_l : forall (i : positive) (m : t A),         f None None = None -> find i (xmap2_l m) = f (find i m) None.
Lemma xgmap2_r : forall (i : positive) (m : t B),         f None None = None -> find i (xmap2_r m) = f None (find i m).
Lemma gmap2: forall (i: positive)(m1:t A)(m2: t B),     f None None = None ->     find i (_map2 m1 m2) = f (find i m1) (find i m2).
Lemma map2_1 : forall (elt elt' elt'':Type)(m: t elt)(m': t elt')   (x:key)(f:option elt->option elt'->option elt''),   In x m \/ In x m' ->   find x (map2 f m m') = f (find x m) (find x m').
Lemma  map2_2 : forall (elt elt' elt'':Type)(m: t elt)(m': t elt')   (x:key)(f:option elt->option elt'->option elt''),   In x (map2 f m m') -> In x m \/ In x m'.
Lemma xfoldi_1 :     forall m v i,     xfoldi m v i = fold_left (fun a p => f (fst p) (snd p) a) (xelements m i) v.
Lemma fold_1 :   forall (A:Type)(m:t A)(B:Type)(i : B) (f : key -> A -> B -> B),   fold f m i = fold_left (fun a p => f (fst p) (snd p) a) (elements m) i.
Lemma equal_1 : forall (A:Type)(m m':t A)(cmp:A->A->bool),   Equivb cmp m m' -> equal cmp m m' = true.
Lemma equal_2 : forall (A:Type)(m m':t A)(cmp:A->A->bool),   equal cmp m m' = true -> Equivb cmp m m'.
Lemma xmap2_lr :     forall (A B : Type)(f g: option A -> option A -> option B)(m : t A),     (forall (i j : option A), f i j = g j i) ->     xmap2_l f m = xmap2_r g m.
Lemma EUn_noempty :  exists r : R, EUn r.
Lemma Un_in_EUn : forall n:nat, EUn (Un n).
Lemma Un_bound_imp :   forall x:R, (forall n:nat, Un n <= x) -> is_upper_bound EUn x.
Lemma growing_prop :   forall n m:nat, Un_growing -> (n >= m)%nat -> Un n >= Un m.
Lemma Un_cv_crit_lub : Un_growing -> forall l, is_lub EUn l -> Un_cv l.
Lemma Un_cv_crit : Un_growing -> bound EUn ->  exists l : R, Un_cv l.
Lemma finite_greater :   forall N:nat,  exists M : R, (forall n:nat, (n <= N)%nat -> Un n <= M).
Lemma cauchy_bound : Cauchy_crit -> bound EUn.
Lemma GP_infinite : forall x:R, Rabs x < 1 -> Pser (fun n:nat => 1) x (/ (1 - x)).
Lemma Zle_cases n m : if n <=? m then n <= m else n > m.
Lemma Zlt_cases n m : if n <? m then n < m else n >= m.
Lemma Zge_cases n m : if n >=? m then n >= m else n < m.
Lemma Zgt_cases n m : if n >? m then n > m else n <= m.
Lemma Zle_bool_imp_le n m : (n <=? m) = true -> (n <= m).
Lemma Zle_imp_le_bool n m : (n <= m) -> (n <=? m) = true.
Lemma Zle_bool_antisym n m : (n <=? m) = true -> (m <=? n) = true -> n = m.
Lemma Zle_bool_trans n m p : (n <=? m) = true -> (m <=? p) = true -> (n <=? p) = true.
Lemma Zle_bool_plus_mono n m p q : (n <=? m) = true -> (p <=? q) = true -> (n + p <=? m + q) = true.
Lemma Zone_pos : 1 <=? 0 = false.
Lemma Zone_min_pos n : (n <=? 0) = false -> (1 <=? n) = true.
Lemma Zle_is_le_bool n m : (n <= m) <-> (n <=? m) = true.
Lemma Zge_is_le_bool n m : (n >= m) <-> (m <=? n) = true.
Lemma Zlt_is_lt_bool n m : (n < m) <-> (n <? m) = true.
Lemma Zgt_is_gt_bool n m : (n > m) <-> (n >? m) = true.
Lemma Zlt_is_le_bool n m : (n < m) <-> (n <=? m - 1) = true.
Lemma Zgt_is_le_bool n m : (n > m) <-> (m <=? n - 1) = true.
Lemma Zeq_is_eq_bool x y : x = y <-> Zeq_bool x y = true.
Lemma Zeq_bool_eq x y : Zeq_bool x y = true -> x = y.
Lemma Zeq_bool_neq x y : Zeq_bool x y = false -> x <> y.
Lemma Zeq_bool_if x y : if Zeq_bool x y then x=y else x<>y.
Lemma Qabs_case : forall (x:Q) (P : Q -> Type), (0 <= x -> P x) -> (x <= 0 -> P (- x)) -> P (Qabs x).
Lemma Qabs_pos : forall x, 0 <= x -> Qabs x == x.
Lemma Qabs_neg : forall x, x <= 0 -> Qabs x == - x.
Lemma Qabs_nonneg : forall x, 0 <= (Qabs x).
Lemma Zabs_Qabs : forall n d, (Z.abs n#d)==Qabs (n#d).
Lemma Qabs_opp : forall x, Qabs (-x) == Qabs x.
Lemma Qabs_triangle : forall x y, Qabs (x+y) <= Qabs x + Qabs y.
Lemma Qabs_Qmult : forall a b, Qabs (a*b) == (Qabs a)*(Qabs b).
Lemma Qabs_Qminus x y: Qabs (x - y) = Qabs (y - x).
Lemma Qle_Qabs : forall a, a <= Qabs a.
Lemma Qabs_triangle_reverse : forall x y, Qabs x - Qabs y <= Qabs (x - y).
Lemma Qabs_Qle_condition x y: Qabs x <= y <-> -y <= x <= y.
Lemma Qabs_diff_Qle_condition x y r: Qabs (x - y) <= r <-> x - r <= y <= x + r.
Lemma mod_divide : forall a b, b~=0 -> (a mod b == 0 <-> (b|a)).
Lemma divide_div_mul_exact : forall a b c, b~=0 -> (b|a) -> (c*a)/b == c*(a/b).
Lemma gcd_div_factor : forall a b c, c~=0 -> (c|a) -> (c|b) -> gcd (a/c) (b/c) == (gcd a b)/c.
Lemma gcd_div_gcd : forall a b g, g~=0 -> g == gcd a b -> gcd (a/g) (b/g) == 1.
Lemma gcd_mod : forall a b, b~=0 -> gcd (a mod b) b == gcd b a.
Lemma lcm_equiv1 : forall a b, gcd a b ~= 0 -> a * (b / gcd a b) == (a*b)/gcd a b.
Lemma lcm_equiv2 : forall a b, gcd a b ~= 0 -> (a / gcd a b) * b == (a*b)/gcd a b.
Lemma gcd_div_swap : forall a b, (a / gcd a b) * b == a * (b / gcd a b).
Lemma divide_lcm_l : forall a b, (a | lcm a b).
Lemma divide_lcm_r : forall a b, (b | lcm a b).
Lemma divide_div : forall a b c, a~=0 -> (a|b) -> (b|c) -> (b/a|c/a).
Lemma lcm_least : forall a b c, (a | c) -> (b | c) -> (lcm a b | c).
Lemma lcm_comm : forall a b, lcm a b == lcm b a.
Lemma lcm_divide_iff : forall n m p, (lcm n m | p) <-> (n | p) /\ (m | p).
Lemma lcm_unique : forall n m p, 0<=p -> (n|p) -> (m|p) -> (forall q, (n|q) -> (m|q) -> (p|q)) -> lcm n m == p.
Lemma lcm_unique_alt : forall n m p, 0<=p -> (forall q, (p|q) <-> (n|q) /\ (m|q)) -> lcm n m == p.
Lemma lcm_assoc : forall n m p, lcm n (lcm m p) == lcm (lcm n m) p.
Lemma lcm_0_l : forall n, lcm 0 n == 0.
Lemma lcm_0_r : forall n, lcm n 0 == 0.
Lemma lcm_1_l : forall n, lcm 1 n == n.
Lemma lcm_1_r : forall n, lcm n 1 == n.
Lemma lcm_diag : forall n, lcm n n == n.
Lemma lcm_eq_0 : forall n m, lcm n m == 0 <-> n == 0 \/ m == 0.
Lemma divide_lcm_eq_r : forall n m, (n|m) -> lcm n m == m.
Lemma divide_lcm_iff : forall n m, (n|m) <-> lcm n m == m.
Lemma lcm_mul_mono_l : forall n m p, lcm (p * n) (p * m) == p * lcm n m.
Lemma lcm_mul_mono_r : forall n m p, lcm (n * p) (m * p) == lcm n m * p.
Lemma gcd_1_lcm_mul : forall n m, n~=0 -> m~=0 -> (gcd n m == 1 <-> lcm n m == n*m).
Lemma spec_split : forall (n : nat) (x : zn2z (word w n)),      let (h, l) := double_split w_0 n x in      [!S n | x!] = [!n | h!] * double_wB w_digits n + [!n | l!].
Lemma spec_double_divn1_0 : forall n r a,   [|r|] < [|b2p|] ->   let (q,r') := double_divn1_0 n r a in   [|r|] * double_wB w_digits n + [!n|a!] = [!n|q!] * [|b2p|] + [|r'|] /\   0 <= [|r'|] < [|b2p|].
Lemma spec_double_modn1_0 : forall n r x,    double_modn1_0 n r x = snd (double_divn1_0 n r x).
Lemma spec_add_mul_divp : forall x y,   [| w_add_mul_div p x y |] =      ([|x|] * (2 ^ [|p|]) +         [|y|] / (2 ^ ((Zpos w_digits) - [|p|]))) mod wB.
Lemma p_lt_double_digits : forall n, [|p|] <= Zpos (w_digits << n).
Lemma spec_double_divn1_p : forall n r h l,   [|r|] < [|b2p|] ->   let (q,r') := double_divn1_p n r h l in   [|r|] * double_wB w_digits n +     ([!n|h!]*2^[|p|] +       [!n|l!] / (2^(Zpos(w_digits << n) - [|p|])))       mod double_wB w_digits n = [!n|q!] * [|b2p|] + [|r'|] /\   0 <= [|r'|] < [|b2p|].
Lemma spec_double_modn1_p : forall n r h l ,   double_modn1_p n r h l = snd (double_divn1_p n r h l).
Lemma spec_double_digits:forall n, Zpos w_digits <= Zpos (w_digits << n).
Lemma spec_high : forall n (x:word w n),  [|high n x|] = [!n|x!] / 2^(Zpos (w_digits << n) - Zpos w_digits).
Lemma spec_double_divn1 : forall n a b,   0 < [|b|] ->   let (q,r) := double_divn1 n a b in   [!n|a!] = [!n|q!] * [|b|] + [|r|] /\   0 <= [|r|] < [|b|].
Lemma spec_double_modn1_aux : forall n a b,   double_modn1 n a b = snd (double_divn1 n a b).
Lemma spec_double_modn1 : forall n a b, 0 < [|b|] -> [|double_modn1 n a b|] = [!n|a!] mod [|b|].
Lemma eps2_Rgt_R0 : forall eps:R, eps > 0 -> eps * / 2 > 0.
Lemma eps2 : forall eps:R, eps * / 2 + eps * / 2 = eps.
Lemma eps4 : forall eps:R, eps * / (2 + 2) + eps * / (2 + 2) = eps * / 2.
Lemma Rlt_eps2_eps : forall eps:R, eps > 0 -> eps * / 2 < eps.
Lemma Rlt_eps4_eps : forall eps:R, eps > 0 -> eps * / (2 + 2) < eps.
Lemma prop_eps : forall r:R, (forall eps:R, eps > 0 -> r < eps) -> r <= 0.
Lemma mul_factor_wd : forall l l':R, 1 + (Rabs l + Rabs l') <> 0.
Lemma mul_factor_gt : forall eps l l':R, eps > 0 -> eps * mul_factor l l' > 0.
Lemma mul_factor_gt_f : forall eps l l':R, eps > 0 -> Rmin 1 (eps * mul_factor l l') > 0.
Lemma tech_limit : forall (f:R -> R) (D:R -> Prop) (l x0:R),   D x0 -> limit1_in f D l x0 -> l = f x0.
Lemma tech_limit_contr : forall (f:R -> R) (D:R -> Prop) (l x0:R),   D x0 -> l <> f x0 -> ~ limit1_in f D l x0.
Lemma lim_x : forall (D:R -> Prop) (x0:R), limit1_in (fun x:R => x) D x0 x0.
Lemma limit_plus : forall (f g:R -> R) (D:R -> Prop) (l l' x0:R),   limit1_in f D l x0 ->   limit1_in g D l' x0 -> limit1_in (fun x:R => f x + g x) D (l + l') x0.
Lemma limit_Ropp : forall (f:R -> R) (D:R -> Prop) (l x0:R),   limit1_in f D l x0 -> limit1_in (fun x:R => - f x) D (- l) x0.
Lemma limit_minus : forall (f g:R -> R) (D:R -> Prop) (l l' x0:R),   limit1_in f D l x0 ->   limit1_in g D l' x0 -> limit1_in (fun x:R => f x - g x) D (l - l') x0.
Lemma limit_free : forall (f:R -> R) (D:R -> Prop) (x x0:R),   limit1_in (fun h:R => f x) D (f x) x0.
Lemma limit_mul : forall (f g:R -> R) (D:R -> Prop) (l l' x0:R),   limit1_in f D l x0 ->   limit1_in g D l' x0 -> limit1_in (fun x:R => f x * g x) D (l * l') x0.
Lemma single_limit : forall (f:R -> R) (D:R -> Prop) (l l' x0:R),   adhDa D x0 -> limit1_in f D l x0 -> limit1_in f D l' x0 -> l = l'.
Lemma limit_comp : forall (f g:R -> R) (Df Dg:R -> Prop) (l l' x0:R),   limit1_in f Df l x0 ->   limit1_in g Dg l' l -> limit1_in (fun x:R => g (f x)) (Dgf Df Dg f) l' x0.
Lemma limit_inv : forall (f:R -> R) (D:R -> Prop) (l x0:R),   limit1_in f D l x0 -> l <> 0 -> limit1_in (fun x:R => / f x) D (/ l) x0.
Lemma atan_sub_correct : forall u v, 1 + u * v <> 0 -> -PI/2 < atan u - atan v < PI/2 ->  -PI/2 < atan (atan_sub u v) < PI/2 ->  atan u = atan v + atan (atan_sub u v).
Lemma tech : forall x y , -1 <= x <= 1 -> -1 < y < 1 ->  -PI/2 < atan x - atan y < PI/2.
Lemma Machin_2_3 : PI/4 = atan(/2) + atan(/3).
Lemma Machin_4_5_239 : PI/4 = 4 * atan (/5) - atan(/239).
Lemma Machin_2_3_7 : PI/4 = 2 * atan(/3) + (atan (/7)).
Lemma PI_2_3_7_ineq : forall N : nat,   sum_f_R0 (tg_alt PI_2_3_7_tg) (S (2 * N)) <= PI / 4 <=   sum_f_R0 (tg_alt PI_2_3_7_tg) (2 * N).
Lemma spec_N_of_Z z : (0<=z)%Z -> [N_of_Z z] = z.
Lemma B0 : B 0.
Lemma BS : forall z : Z, (0 <= z)%Z -> B z -> B (z + 1).
Lemma B_holds : forall z : Z, (0 <= z)%Z -> B z.
Lemma eqb_eq x y : eqb x y = true <-> x == y.
Lemma leb_le x y : leb x y = true <-> x <= y.
Lemma ltb_lt x y : ltb x y = true <-> x < y.
Lemma compare_eq_iff n m : compare n m = Eq <-> n == m.
Lemma compare_lt_iff n m : compare n m = Lt <-> n < m.
Lemma compare_le_iff n m : compare n m <> Gt <-> n <= m.
Lemma compare_antisym n m : compare m n = CompOpp (compare n m).
Lemma pow_0_r : forall a, a^0 == 1.
Lemma pow_succ_r : forall a b, 0<=b -> a^(succ b) == a * a^b.
Lemma pow_neg_r : forall a b, b<0 -> a^b == 0.
Lemma pow_pow_N : forall a b, a^b == pow_N a (to_N b).
Lemma pow_N_pow : forall a b, pow_N a b == a^(of_N b).
Lemma pow_pos_N : forall a p, pow_pos a p == pow_N a (Npos p).
Lemma square_spec n : square n == n * n.
Lemma sqrt_spec : forall n, 0<=n -> (sqrt n)*(sqrt n) <= n /\ n < (succ (sqrt n))*(succ (sqrt n)).
Lemma sqrt_neg : forall n, n<0 -> sqrt n == 0.
Lemma log2_spec : forall n, 0<n -> 2^(log2 n) <= n /\ n < 2^(succ (log2 n)).
Lemma log2_nonpos : forall n, n<=0 -> log2 n == 0.
Lemma even_spec n : even n = true <-> Even n.
Lemma odd_spec n : odd n = true <-> Odd n.
Lemma spec_divide : forall n m, (n|m) <-> Z.divide [n] [m].
Lemma gcd_divide_l : forall n m, (gcd n m | n).
Lemma gcd_divide_r : forall n m, (gcd n m | m).
Lemma gcd_greatest : forall n m p, (p|n) -> (p|m) -> (p|gcd n m).
Lemma gcd_nonneg : forall n m, 0 <= gcd n m.
Lemma testbit_odd_0 : forall a, testbit (2*a+1) 0 = true.
Lemma testbit_even_0 : forall a, testbit (2*a) 0 = false.
Lemma testbit_odd_succ : forall a n, 0<=n -> testbit (2*a+1) (succ n) = testbit a n.
Lemma testbit_even_succ : forall a n, 0<=n -> testbit (2*a) (succ n) = testbit a n.
Lemma testbit_neg_r : forall a n, n<0 -> testbit a n = false.
Lemma shiftr_spec : forall a n m, 0<=m -> testbit (shiftr a n) m = testbit a (m+n).
Lemma shiftl_spec_high : forall a n m, 0<=m -> n<=m -> testbit (shiftl a n) m = testbit a (m-n).
Lemma shiftl_spec_low : forall a n m, m<n -> testbit (shiftl a n) m = false.
Lemma land_spec : forall a b n, testbit (land a b) n = testbit a n && testbit b n.
Lemma lor_spec : forall a b n, testbit (lor a b) n = testbit a n || testbit b n.
Lemma ldiff_spec : forall a b n, testbit (ldiff a b) n = testbit a n && negb (testbit b n).
Lemma lxor_spec : forall a b n, testbit (lxor a b) n = xorb (testbit a n) (testbit b n).
Lemma div2_spec : forall a, div2 a == shiftr a 1.
Lemma zerob_true_intro : forall n:nat, n = 0 -> zerob n = true.
Lemma zerob_true_elim : forall n:nat, zerob n = true -> n = 0.
Lemma zerob_false_intro : forall n:nat, n <> 0 -> zerob n = false.
Lemma zerob_false_elim : forall n:nat, zerob n = false -> n <> 0.
Lemma binary_value : forall n:nat, Bvector n -> Z.
Lemma two_compl_value : forall n:nat, Bvector (S n) -> Z.
Lemma Zmod2_twice :   forall z:Z, z = (2 * Zmod2 z + bit_value (Z.odd z))%Z.
Lemma Z_to_binary : forall n:nat, Z -> Bvector n.
Lemma Z_to_two_compl : forall n:nat, Z -> Bvector (S n).
Lemma binary_value_Sn :   forall (n:nat) (b:bool) (bv:Bvector n),     binary_value (S n) ( b :: bv) =     (bit_value b + 2 * binary_value n bv)%Z.
Lemma Z_to_binary_Sn :   forall (n:nat) (b:bool) (z:Z),     (z >= 0)%Z ->     Z_to_binary (S n) (bit_value b + 2 * z) = Bcons b n (Z_to_binary n z).
Lemma binary_value_pos :   forall (n:nat) (bv:Bvector n), (binary_value n bv >= 0)%Z.
Lemma two_compl_value_Sn :   forall (n:nat) (bv:Bvector (S n)) (b:bool),     two_compl_value (S n) (Bcons b (S n) bv) =     (bit_value b + 2 * two_compl_value n bv)%Z.
Lemma Z_to_two_compl_Sn :   forall (n:nat) (b:bool) (z:Z),     Z_to_two_compl (S n) (bit_value b + 2 * z) =     Bcons b (S n) (Z_to_two_compl n z).
Lemma Z_to_binary_Sn_z :   forall (n:nat) (z:Z),     Z_to_binary (S n) z =     Bcons (Z.odd z) n (Z_to_binary n (Z.div2 z)).
Lemma Z_div2_value :   forall z:Z,     (z >= 0)%Z -> (bit_value (Z.odd z) + 2 * Z.div2 z)%Z = z.
Lemma Pdiv2 : forall z:Z, (z >= 0)%Z -> (Z.div2 z >= 0)%Z.
Lemma Zdiv2_two_power_nat :   forall (z:Z) (n:nat),     (z >= 0)%Z ->     (z < two_power_nat (S n))%Z -> (Z.div2 z < two_power_nat n)%Z.
Lemma Z_to_two_compl_Sn_z :   forall (n:nat) (z:Z),     Z_to_two_compl (S n) z =     Bcons (Z.odd z) (S n) (Z_to_two_compl n (Zmod2 z)).
Lemma Zeven_bit_value :   forall z:Z, Zeven.Zeven z -> bit_value (Z.odd z) = 0%Z.
Lemma Zodd_bit_value :   forall z:Z, Zeven.Zodd z -> bit_value (Z.odd z) = 1%Z.
Lemma Zge_minus_two_power_nat_S :   forall (n:nat) (z:Z),     (z >= - two_power_nat (S n))%Z -> (Zmod2 z >= - two_power_nat n)%Z.
Lemma Zlt_two_power_nat_S :   forall (n:nat) (z:Z),     (z < two_power_nat (S n))%Z -> (Zmod2 z < two_power_nat n)%Z.
Lemma binary_to_Z_to_binary :   forall (n:nat) (bv:Bvector n), Z_to_binary n (binary_value n bv) = bv.
Lemma two_compl_to_Z_to_two_compl :   forall (n:nat) (bv:Bvector n) (b:bool),     Z_to_two_compl n (two_compl_value n (Bcons b n bv)) = Bcons b n bv.
Lemma Z_to_binary_to_Z :   forall (n:nat) (z:Z),     (z >= 0)%Z ->     (z < two_power_nat n)%Z -> binary_value n (Z_to_binary n z) = z.
Lemma Z_to_two_compl_to_Z :   forall (n:nat) (z:Z),     (z >= - two_power_nat n)%Z ->     (z < two_power_nat n)%Z -> two_compl_value n (Z_to_two_compl n z) = z.
Lemma plus_max_distr_l : forall n m p, Qmax (p + n) (p + m) == p + Qmax n m.
Lemma plus_max_distr_r : forall n m p, Qmax (n + p) (m + p) == Qmax n m + p.
Lemma plus_min_distr_l : forall n m p, Qmin (p + n) (p + m) == p + Qmin n m.
Lemma plus_min_distr_r : forall n m p, Qmin (n + p) (m + p) == Qmin n m + p.
Lemma Permutation_app_tail : forall (l l' tl : list A), Permutation l l' -> Permutation (l++tl) (l'++tl).
Lemma Permutation_app_head : forall (l tl tl' : list A), Permutation tl tl' -> Permutation (l++tl) (l++tl').
Lemma Permutation_add_inside : forall a (l l' tl tl' : list A), Permutation l l' -> Permutation tl tl' -> Permutation (l ++ a :: tl) (l' ++ a :: tl').
Lemma Permutation_cons_append : forall (l : list A) x, Permutation (x :: l) (l ++ x :: nil).
Lemma Permutation_length_1_inv: forall a l, Permutation [a] l -> l = [a].
Lemma Permutation_length_1: forall a b, Permutation [a] [b] -> a = b.
Lemma Permutation_length_2_inv : forall a1 a2 l, Permutation [a1;a2] l -> l = [a1;a2] \/ l = [a2;a1].
Lemma Permutation_length_2 : forall a1 a2 b1 b2, Permutation [a1;a2] [b1;b2] ->   a1 = b1 /\ a2 = b2 \/ a1 = b2 /\ a2 = b1.
Lemma NoDup_Permutation : forall l l', NoDup l -> NoDup l' -> (forall x:A, In x l <-> In x l') -> Permutation l l'.
Lemma Permutation_map : forall l l', Permutation l l' -> Permutation (map f l) (map f l').
Lemma compare_spec : forall x y, CompSpec eq lt x y (compare x y).
Lemma mult_0_r : forall n, n * 0 = 0.
Lemma mult_0_l : forall n, 0 * n = 0.
Lemma mult_1_l : forall n, 1 * n = n.
Lemma mult_1_r : forall n, n * 1 = n.
Lemma mult_comm : forall n m, n * m = m * n.
Lemma mult_plus_distr_r : forall n m p, (n + m) * p = n * p + m * p.
Lemma mult_plus_distr_l : forall n m p, n * (m + p) = n * m + n * p.
Lemma mult_minus_distr_r : forall n m p, (n - m) * p = n * p - m * p.
Lemma mult_minus_distr_l : forall n m p, n * (m - p) = n * m - n * p.
Lemma mult_assoc_reverse : forall n m p, n * m * p = n * (m * p).
Lemma mult_assoc : forall n m p, n * (m * p) = n * m * p.
Lemma mult_is_O : forall n m, n * m = 0 -> n = 0 \/ m = 0.
Lemma mult_is_one : forall n m, n * m = 1 -> n = 1 /\ m = 1.
Lemma mult_succ_l : forall n m:nat, S n * m = n * m + m.
Lemma mult_succ_r : forall n m:nat, n * S m = n * m + n.
Lemma mult_O_le : forall n m, m = 0 \/ n <= m * n.
Lemma mult_le_compat_l : forall n m p, n <= m -> p * n <= p * m.
Lemma mult_le_compat_r : forall n m p, n <= m -> n * p <= m * p.
Lemma mult_le_compat : forall n m p (q:nat), n <= m -> p <= q -> n * p <= m * q.
Lemma mult_S_lt_compat_l : forall n m p, m < p -> S n * m < S n * p.
Lemma mult_lt_compat_l : forall n m p, n < m -> 0 < p -> p * n < p * m.
Lemma mult_lt_compat_r : forall n m p, n < m -> 0 < p -> n * p < m * p.
Lemma mult_S_le_reg_l : forall n m p, S n * m <= S n * p -> m <= p.
Lemma mult_acc_aux : forall n m p, m + n * p = mult_acc m p n.
Lemma mult_tail_mult : forall n m, n * m = tail_mult n m.
Lemma Acc_inverse_image : forall x:A, Acc R (f x) -> Acc Rof x.
Lemma Acc_inverse_rel : forall b:B, Acc R b -> forall x:A, F x b -> Acc RoF x.
Lemma succ_max_distr : forall n m, S (max n m) == max (S n) (S m).
Lemma succ_min_distr : forall n m, S (min n m) == min (S n) (S m).
Lemma pred_max_distr : forall n m, P (max n m) == max (P n) (P m).
Lemma pred_min_distr : forall n m, P (min n m) == min (P n) (P m).
Lemma add_max_distr_l : forall n m p, max (p + n) (p + m) == p + max n m.
Lemma add_max_distr_r : forall n m p, max (n + p) (m + p) == max n m + p.
Lemma add_min_distr_l : forall n m p, min (p + n) (p + m) == p + min n m.
Lemma add_min_distr_r : forall n m p, min (n + p) (m + p) == min n m + p.
Lemma opp_max_distr : forall n m, -(max n m) == min (-n) (-m).
Lemma opp_min_distr : forall n m, -(min n m) == max (-n) (-m).
Lemma sub_max_distr_l : forall n m p, max (p - n) (p - m) == p - min n m.
Lemma sub_max_distr_r : forall n m p, max (n - p) (m - p) == max n m - p.
Lemma sub_min_distr_l : forall n m p, min (p - n) (p - m) == p - max n m.
Lemma sub_min_distr_r : forall n m p, min (n - p) (m - p) == min n m - p.
Lemma mul_max_distr_nonneg_l : forall n m p, 0 <= p -> max (p * n) (p * m) == p * max n m.
Lemma mul_max_distr_nonneg_r : forall n m p, 0 <= p -> max (n * p) (m * p) == max n m * p.
Lemma mul_min_distr_nonneg_l : forall n m p, 0 <= p -> min (p * n) (p * m) == p * min n m.
Lemma mul_min_distr_nonneg_r : forall n m p, 0 <= p -> min (n * p) (m * p) == min n m * p.
Lemma mul_max_distr_nonpos_l : forall n m p, p <= 0 -> max (p * n) (p * m) == p * min n m.
Lemma mul_max_distr_nonpos_r : forall n m p, p <= 0 -> max (n * p) (m * p) == min n m * p.
Lemma mul_min_distr_nonpos_l : forall n m p, p <= 0 -> min (p * n) (p * m) == p * max n m.
Lemma mul_min_distr_nonpos_r : forall n m p, p <= 0 -> min (n * p) (m * p) == max n m * p.
Lemma unfold_Stream : forall x:Stream, x = match x with                     | Cons a s => Cons a s                     end.
Lemma tl_nth_tl : forall (n:nat) (s:Stream), tl (Str_nth_tl n s) = Str_nth_tl n (tl s).
Lemma Str_nth_tl_plus : forall (n m:nat) (s:Stream),  Str_nth_tl n (Str_nth_tl m s) = Str_nth_tl (n + m) s.
Lemma Str_nth_plus : forall (n m:nat) (s:Stream), Str_nth n (Str_nth_tl m s) = Str_nth (n + m) s.
Lemma ForAll_Str_nth_tl : forall m x, ForAll x -> ForAll (Str_nth_tl m x).
Lemma Str_nth_tl_map : forall n s, Str_nth_tl n (map s)= map (Str_nth_tl n s).
Lemma Str_nth_map : forall n s, Str_nth n (map s)= f (Str_nth n s).
Lemma ForAll_map : forall (P:Stream B -> Prop) (S:Stream A), ForAll (fun s => P (map s)) S <-> ForAll P (map S).
Lemma Exists_map : forall (P:Stream B -> Prop) (S:Stream A), Exists (fun s => P (map s)) S -> Exists P (map S).
Lemma Str_nth_tl_zipWith : forall n (a:Stream A) (b:Stream B), Str_nth_tl n (zipWith a b)= zipWith (Str_nth_tl n a) (Str_nth_tl n b).
Lemma Str_nth_zipWith : forall n (a:Stream A) (b:Stream B), Str_nth n (zipWith a b)= f (Str_nth n a) (Str_nth n b).
Lemma constructive_indefinite_description : forall (A : Type) (P : A->Prop),   (exists x, P x) -> { x : A | P x }.
Lemma small_drinkers'_paradox : forall (A:Type) (P:A -> Prop), inhabited A ->   exists x, (exists x, P x) -> P x.
Lemma constructive_definite_description : forall (A : Type) (P : A->Prop),   (exists! x, P x) -> { x : A | P x }.
Lemma Pdiv_eucl_remainder a b : snd (Pdiv_eucl a b) < Npos b.
Lemma Zwf_well_founded : well_founded (Zwf c).
Lemma Zwf_up_well_founded : well_founded (Zwf_up c).
Lemma Acc_incl : inclusion A R1 R2 -> forall z:A, Acc R2 z -> Acc R1 z.
Lemma sqrt_spec_nonneg : forall b, b² < (S b)² -> 0 <= b.
Lemma sqrt_nonneg : forall a, 0<=√a.
Lemma sqrt_unique : forall a b, b² <= a < (S b)² -> √a == b.
Lemma sqrt_spec_alt : forall a, 0<=a -> exists r, a == (√a)² + r /\ 0 <= r <= 2*√a.
Lemma sqrt_unique' : forall a b c, 0<=c<=2*b -> a == b² + c -> √a == b.
Lemma sqrt_square : forall a, 0<=a -> √(a²) == a.
Lemma sqrt_pred_square : forall a, 0<a -> √(P a²) == P a.
Lemma sqrt_le_mono : forall a b, a <= b -> √a <= √b.
Lemma sqrt_lt_cancel : forall a b, √a < √b -> a < b.
Lemma sqrt_le_square : forall a b, 0<=a -> 0<=b -> (b²<=a <-> b <= √a).
Lemma sqrt_lt_square : forall a b, 0<=a -> 0<=b -> (a<b² <-> √a < b).
Lemma sqrt_0 : √0 == 0.
Lemma sqrt_1 : √1 == 1.
Lemma sqrt_2 : √2 == 1.
Lemma sqrt_pos : forall a, 0 < √a <-> 0 < a.
Lemma sqrt_lt_lin : forall a, 1<a -> √a<a.
Lemma sqrt_le_lin : forall a, 0<=a -> √a<=a.
Lemma sqrt_mul_below : forall a b, √a * √b <= √(a*b).
Lemma sqrt_mul_above : forall a b, 0<=a -> 0<=b -> √(a*b) < S (√a) * S (√b).
Lemma sqrt_succ_le : forall a, 0<=a -> √(S a) <= S (√a).
Lemma sqrt_succ_or : forall a, 0<=a -> √(S a) == S (√a) \/ √(S a) == √a.
Lemma sqrt_eq_succ_iff_square : forall a, 0<=a -> (√(S a) == S (√a) <-> exists b, 0<b /\ S a == b²).
Lemma sqrt_add_le : forall a b, √(a+b) <= √a + √b.
Lemma add_sqrt_le : forall a b, 0<=a -> 0<=b -> √a + √b <= √(2*(a+b)).
Lemma sqrt_up_eqn0 : forall a, a<=0 -> √°a == 0.
Lemma sqrt_up_eqn : forall a, 0<a -> √°a == S √(P a).
Lemma sqrt_up_spec : forall a, 0<a -> (P √°a)² < a <= (√°a)².
Lemma sqrt_up_nonneg : forall a, 0<=√°a.
Lemma sqrt_up_unique : forall a b, 0<b -> (P b)² < a <= b² -> √°a == b.
Lemma sqrt_up_square : forall a, 0<=a -> √°(a²) == a.
Lemma sqrt_up_succ_square : forall a, 0<=a -> √°(S a²) == S a.
Lemma sqrt_up_0 : √°0 == 0.
Lemma sqrt_up_1 : √°1 == 1.
Lemma sqrt_up_2 : √°2 == 2.
Lemma le_sqrt_sqrt_up : forall a, √a <= √°a.
Lemma le_sqrt_up_succ_sqrt : forall a, √°a <= S (√a).
Lemma sqrt_sqrt_up_spec : forall a, 0<=a -> (√a)² <= a <= (√°a)².
Lemma sqrt_sqrt_up_exact : forall a, 0<=a -> (√a == √°a <-> exists b, 0<=b /\ a == b²).
Lemma sqrt_up_le_mono : forall a b, a <= b -> √°a <= √°b.
Lemma sqrt_up_lt_cancel : forall a b, √°a < √°b -> a < b.
Lemma sqrt_up_lt_square : forall a b, 0<=a -> 0<=b -> (b² < a <-> b < √°a).
Lemma sqrt_up_le_square : forall a b, 0<=a -> 0<=b -> (a <= b² <-> √°a <= b).
Lemma sqrt_up_pos : forall a, 0 < √°a <-> 0 < a.
Lemma sqrt_up_lt_lin : forall a, 2<a -> √°a < a.
Lemma sqrt_up_le_lin : forall a, 0<=a -> √°a<=a.
Lemma sqrt_up_mul_above : forall a b, 0<=a -> 0<=b -> √°(a*b) <= √°a * √°b.
Lemma sqrt_up_mul_below : forall a b, 0<a -> 0<b -> (P √°a)*(P √°b) < √°(a*b).
Lemma sqrt_up_succ_le : forall a, 0<=a -> √°(S a) <= S (√°a).
Lemma sqrt_up_succ_or : forall a, 0<=a -> √°(S a) == S (√°a) \/ √°(S a) == √°a.
Lemma sqrt_up_eq_succ_iff_square : forall a, 0<=a -> (√°(S a) == S (√°a) <-> exists b, 0<=b /\ a == b²).
Lemma sqrt_up_add_le : forall a b, √°(a+b) <= √°a + √°b.
Lemma add_sqrt_up_le : forall a b, 0<=a -> 0<=b -> √°a + √°b <= S √°(2*(a+b)).
Lemma P_implies_acc : forall x : nat, P x -> acc x.
Lemma P_eventually_implies_acc : forall (x : nat) (n : nat), P (n + x) -> acc x.
Lemma P'_decidable : forall n : nat, {P' n} + {~ P' n}.
Lemma constructive_indefinite_ground_description : (exists x : A, P x) -> {x : A | P x}.
Lemma constructive_definite_ground_description : (exists! x : A, P x) -> {x : A | P x}.
Lemma acc_A_B_lexprod :   forall x:A,     Acc leA x ->     (forall x0:A, clos_trans A leA x0 x -> well_founded (leB x0)) ->     forall y:B x, Acc (leB x) y -> Acc LexProd (existT B x y).
Lemma Acc_symprod :   forall x:A, Acc leA x -> forall y:B, Acc leB y -> Acc Symprod (x, y).
Lemma wf_symprod :   well_founded leA -> well_founded leB -> well_founded Symprod.
Lemma swap_Acc : forall x y:A, Acc SwapProd (x, y) -> Acc SwapProd (y, x).
Lemma Acc_swapprod :   forall x y:A, Acc R x -> Acc R y -> Acc SwapProd (x, y).
Lemma wf_swapprod : well_founded R -> well_founded SwapProd.
Lemma Piter_mul_acc : forall f, (forall x y:Z, (f x)*y = f (x*y)) -> forall p k, Pos.iter p f k = (Pos.iter p f 1)*k.
Lemma Piter_op_square : forall p a, Pos.iter_op Z.mul p (a*a) = (Pos.iter_op Z.mul p a)*(Pos.iter_op Z.mul p a).
Lemma Zpower_equiv a b : a^^b = a^b.
Lemma Zpower_alt_0_r n : n^^0 = 1.
Lemma Zpower_alt_succ_r a b : 0<=b -> a^^(Z.succ b) = a * a^^b.
Lemma Zpower_alt_neg_r a b : b<0 -> a^^b = 0.
Lemma Zpower_alt_Ppow p q : (Zpos p)^^(Zpos q) = Zpos (p^q).
Lemma cauchy_crit_geometric_dec_fun : Cauchy_crit_series f.
Lemma forall_dec : {forall n, P n} + {~forall n, P n}.
Lemma sig_forall_dec :  {n | ~P n}+{forall n, P n}.
Lemma eq_nth_iff A n (v1 v2: t A n): (forall p1 p2, p1 = p2 -> v1 [@ p1 ] = v2 [@ p2 ]) <-> v1 = v2.
Lemma nth_order_last A: forall n (v: t A (S n)) (H: n < S n), nth_order v H = last v.
Lemma shiftin_nth A a n (v: t A n) k1 k2 (eq: k1 = k2): nth (shiftin a v) (Fin.L_R 1 k1) = nth v k2.
Lemma shiftin_last A a n (v: t A n): last (shiftin a v) = a.
Lemma shiftrepeat_nth A: forall n k (v: t A (S n)), nth (shiftrepeat v) (Fin.L_R 1 k) = nth v k.
Lemma shiftrepeat_last A: forall n (v: t A (S n)), last (shiftrepeat v) = last v.
Lemma const_nth A (a: A) n (p: Fin.t n): (const a n)[@ p] = a.
Lemma nth_map {A B} (f: A -> B) {n} v (p1 p2: Fin.t n) (eq: p1 = p2):
Lemma nth_map2 {A B C} (f: A -> B -> C) {n} v w (p1 p2 p3: Fin.t n):
Lemma fold_left_right_assoc_eq {A B} {f: A -> B -> A} (assoc: forall a b c, f (f a b) c = f (f a c) b) {n} (v: t B n): forall a, fold_left f a v = fold_right (fun x y => f y x) v a.
Lemma to_list_of_list_opp {A} (l: list A): to_list (of_list l) = l.
Lemma add_le_mul : forall a b, 1<a -> 1<b -> a+b <= a*b.
Lemma square_nonneg : forall a, 0 <= a * a.
Lemma crossmul_le_addsquare : forall a b, 0<=a -> 0<=b -> b*a+a*b <= a*a+b*b.
Lemma add_square_le : forall a b, 0<=a -> 0<=b -> a*a + b*b <= (a+b)*(a+b).
Lemma square_add_le : forall a b, 0<=a -> 0<=b -> (a+b)*(a+b) <= 2*(a*a + b*b).
Lemma quadmul_le_squareadd : forall a b, 0<=a -> 0<=b -> 2*2*a*b <= (a+b)*(a+b).
Lemma prop_ext : forall A B:Prop, (A <-> B) -> A = B.
Lemma proof_irrel : forall (A:Prop) (a1 a2:A), a1 = a2.
Lemma guarded_rel_choice : GuardedRelationalChoice.
Lemma AC_bool_subset_to_bool : exists R : (bool -> Prop) -> bool -> Prop,  (forall P:bool -> Prop,     (exists b : bool, P b) ->      exists b : bool, P b /\ R P b /\ (forall b':bool, R P b' -> b = b')).
Lemma projT1_injective : a1=a2 -> a1'=a2'.
Lemma decide : forall x:A', exists y:bool , (projT1 x = a1 /\ y = true ) \/ (projT1 x = a2 /\ y = false).
Lemma proof_irrel_rel_choice_imp_eq_dec' : a1=a2 \/ ~a1=a2.
Lemma sqrt_spec' : forall a, √a*√a <= a < S (√a) * S (√a).
Lemma sqrt_square : forall a, √(a*a) == a.
Lemma sqrt_le_square : forall a b, b*b<=a <-> b <= √a.
Lemma sqrt_lt_square : forall a b, a<b*b <-> √a < b.
Lemma sqrt_le_lin : forall a, √a<=a.
Lemma sqrt_mul_above : forall a b, √(a*b) < S (√a) * S (√b).
Lemma sqrt_succ_le : forall a, √(S a) <= S (√a).
Lemma sqrt_succ_or : forall a, √(S a) == S (√a) \/ √(S a) == √a.
Lemma add_sqrt_le : forall a b, √a + √b <= √(2*(a+b)).
Lemma S_pred : forall n m, m < n -> n = S (pred n).
Lemma lt_pred : forall n m, S n < m -> n < pred m.
Lemma lt_pred_n_n : forall n, 0 < n -> pred n < n.
Lemma eq_eq_nat : forall n m, n = m -> eq_nat n m.
Lemma eq_nat_eq : forall n m, eq_nat n m -> n = m.
Lemma beq_nat_refl : forall n, true = beq_nat n n.
Lemma beq_nat_true : forall x y, beq_nat x y = true -> x=y.
Lemma beq_nat_false : forall x y, beq_nat x y = false -> x<>y.
Lemma beq_nat_true_iff : forall x y, beq_nat x y = true <-> x=y.
Lemma beq_nat_false_iff : forall x y, beq_nat x y = false <-> x<>y.
Lemma compose_id_left : forall A B (f : A -> B), id ∘ f = f.
Lemma compose_id_right : forall A B (f : A -> B), f ∘ id = f.
Lemma compose_assoc : forall A B C D (f : A -> B) (g : B -> C) (h : C -> D), h ∘ g ∘ f = h ∘ (g ∘ f).
Lemma flip_flip : forall A B C, @flip A B C ∘ flip = id.
Lemma prod_uncurry_curry : forall A B C, @prod_uncurry A B C ∘ prod_curry = id.
Lemma prod_curry_uncurry : forall A B C, @prod_curry A B C ∘ prod_uncurry = id.
Lemma tech1 : forall (An:nat -> R) (N:nat),   (forall n:nat, (n <= N)%nat -> 0 < An n) -> 0 < sum_f_R0 An N.
Lemma tech2 : forall (An:nat -> R) (m n:nat),   (m < n)%nat ->   sum_f_R0 An n =   sum_f_R0 An m + sum_f_R0 (fun i:nat => An (S m + i)%nat) (n - S m).
Lemma tech3 : forall (k:R) (N:nat),   k <> 1 -> sum_f_R0 (fun i:nat => k ^ i) N = (1 - k ^ S N) / (1 - k).
Lemma tech4 : forall (An:nat -> R) (k:R) (N:nat),   0 <= k -> (forall i:nat, An (S i) < k * An i) -> An N <= An 0%nat * k ^ N.
Lemma tech5 : forall (An:nat -> R) (N:nat), sum_f_R0 An (S N) = sum_f_R0 An N + An (S N).
Lemma tech6 : forall (An:nat -> R) (k:R) (N:nat),   0 <= k ->   (forall i:nat, An (S i) < k * An i) ->   sum_f_R0 An N <= An 0%nat * sum_f_R0 (fun i:nat => k ^ i) N.
Lemma tech7 : forall r1 r2:R, r1 <> 0 -> r2 <> 0 -> r1 <> r2 -> / r1 <> / r2.
Lemma tech11 : forall (An Bn Cn:nat -> R) (N:nat),   (forall i:nat, An i = Bn i - Cn i) ->   sum_f_R0 An N = sum_f_R0 Bn N - sum_f_R0 Cn N.
Lemma tech12 : forall (An:nat -> R) (x l:R),   Un_cv (fun N:nat => sum_f_R0 (fun i:nat => An i * x ^ i) N) l ->   Pser An x l.
Lemma scal_sum : forall (An:nat -> R) (N:nat) (x:R),   x * sum_f_R0 An N = sum_f_R0 (fun i:nat => An i * x) N.
Lemma decomp_sum : forall (An:nat -> R) (N:nat),   (0 < N)%nat ->   sum_f_R0 An N = An 0%nat + sum_f_R0 (fun i:nat => An (S i)) (pred N).
Lemma plus_sum : forall (An Bn:nat -> R) (N:nat),   sum_f_R0 (fun i:nat => An i + Bn i) N = sum_f_R0 An N + sum_f_R0 Bn N.
Lemma sum_eq : forall (An Bn:nat -> R) (N:nat),   (forall i:nat, (i <= N)%nat -> An i = Bn i) ->   sum_f_R0 An N = sum_f_R0 Bn N.
Lemma uniqueness_sum : forall (An:nat -> R) (l1 l2:R),   infinite_sum An l1 -> infinite_sum An l2 -> l1 = l2.
Lemma minus_sum : forall (An Bn:nat -> R) (N:nat),   sum_f_R0 (fun i:nat => An i - Bn i) N = sum_f_R0 An N - sum_f_R0 Bn N.
Lemma sum_decomposition : forall (An:nat -> R) (N:nat),   sum_f_R0 (fun l:nat => An (2 * l)%nat) (S N) +   sum_f_R0 (fun l:nat => An (S (2 * l))) N = sum_f_R0 An (2 * S N).
Lemma sum_Rle : forall (An Bn:nat -> R) (N:nat),   (forall n:nat, (n <= N)%nat -> An n <= Bn n) ->   sum_f_R0 An N <= sum_f_R0 Bn N.
Lemma Rsum_abs : forall (An:nat -> R) (N:nat),   Rabs (sum_f_R0 An N) <= sum_f_R0 (fun l:nat => Rabs (An l)) N.
Lemma sum_cte : forall (x:R) (N:nat), sum_f_R0 (fun _:nat => x) N = x * INR (S N).
Lemma sum_growing : forall (An Bn:nat -> R) (N:nat),   (forall n:nat, An n <= Bn n) -> sum_f_R0 An N <= sum_f_R0 Bn N.
Lemma Rabs_triang_gen : forall (An:nat -> R) (N:nat),   Rabs (sum_f_R0 An N) <= sum_f_R0 (fun i:nat => Rabs (An i)) N.
Lemma cond_pos_sum : forall (An:nat -> R) (N:nat),   (forall n:nat, 0 <= An n) -> 0 <= sum_f_R0 An N.
Lemma cauchy_abs : forall An:nat -> R,   Cauchy_crit_series (fun i:nat => Rabs (An i)) -> Cauchy_crit_series An.
Lemma cv_cauchy_1 : forall An:nat -> R,   { l:R | Un_cv (fun N:nat => sum_f_R0 An N) l } ->   Cauchy_crit_series An.
Lemma cv_cauchy_2 : forall An:nat -> R,   Cauchy_crit_series An ->   { l:R | Un_cv (fun N:nat => sum_f_R0 An N) l }.
Lemma sum_eq_R0 : forall (An:nat -> R) (N:nat),   (forall n:nat, (n <= N)%nat -> An n = 0) -> sum_f_R0 An N = 0.
Lemma sum_incr : forall (An:nat -> R) (N:nat) (l:R),   Un_cv (fun n:nat => sum_f_R0 An n) l ->   (forall n:nat, 0 <= An n) -> sum_f_R0 An N <= l.
Lemma sum_cv_maj : forall (An:nat -> R) (fn:nat -> R -> R) (x l1 l2:R),   Un_cv (fun n:nat => SP fn n x) l1 ->   Un_cv (fun n:nat => sum_f_R0 An n) l2 ->   (forall n:nat, Rabs (fn n x) <= An n) -> Rabs l1 <= l2.
Lemma sqrt_var_maj : forall h:R, Rabs h <= 1 -> Rabs (sqrt (1 + h) - 1) <= Rabs h.
Lemma sqrt_continuity_pt_R1 : continuity_pt sqrt 1.
Lemma sqrt_continuity_pt : forall x:R, 0 < x -> continuity_pt sqrt x.
Lemma derivable_pt_lim_sqrt : forall x:R, 0 < x -> derivable_pt_lim sqrt x (/ (2 * sqrt x)).
Lemma derivable_pt_sqrt : forall x:R, 0 < x -> derivable_pt sqrt x.
Lemma derive_pt_sqrt : forall (x:R) (pr:0 < x),   derive_pt sqrt x (derivable_pt_sqrt _ pr) = / (2 * sqrt x).
Lemma continuity_pt_sqrt : forall x:R, 0 <= x -> continuity_pt sqrt x.
Lemma phi_sequence_prop : forall (un:nat -> posreal) (f:R -> R) (a b:R) (pr:Riemann_integrable f a b)   (N:nat),   { psi:StepFun a b |     (forall t:R,       Rmin a b <= t <= Rmax a b ->       Rabs (f t - phi_sequence un pr N t) <= psi t) /\     Rabs (RiemannInt_SF psi) < un N }.
Lemma RiemannInt_P1 : forall (f:R -> R) (a b:R),   Riemann_integrable f a b -> Riemann_integrable f b a.
Lemma RiemannInt_P2 : forall (f:R -> R) (a b:R) (un:nat -> posreal) (vn wn:nat -> StepFun a b),   Un_cv un 0 ->   a <= b ->   (forall n:nat,     (forall t:R, Rmin a b <= t <= Rmax a b -> Rabs (f t - vn n t) <= wn n t) /\     Rabs (RiemannInt_SF (wn n)) < un n) ->   { l:R | Un_cv (fun N:nat => RiemannInt_SF (vn N)) l }.
Lemma RiemannInt_P3 : forall (f:R -> R) (a b:R) (un:nat -> posreal) (vn wn:nat -> StepFun a b),   Un_cv un 0 ->   (forall n:nat,     (forall t:R, Rmin a b <= t <= Rmax a b -> Rabs (f t - vn n t) <= wn n t) /\     Rabs (RiemannInt_SF (wn n)) < un n) ->   { l:R | Un_cv (fun N:nat => RiemannInt_SF (vn N)) l }.
Lemma RiemannInt_exists : forall (f:R -> R) (a b:R) (pr:Riemann_integrable f a b)   (un:nat -> posreal),   Un_cv un 0 ->   { l:R | Un_cv (fun N:nat => RiemannInt_SF (phi_sequence un pr N)) l }.
Lemma RiemannInt_P4 : forall (f:R -> R) (a b l:R) (pr1 pr2:Riemann_integrable f a b)   (un vn:nat -> posreal),   Un_cv un 0 ->   Un_cv vn 0 ->   Un_cv (fun N:nat => RiemannInt_SF (phi_sequence un pr1 N)) l ->   Un_cv (fun N:nat => RiemannInt_SF (phi_sequence vn pr2 N)) l.
Lemma RinvN_pos : forall n:nat, 0 < / (INR n + 1).
Lemma RinvN_cv : Un_cv RinvN 0.
Lemma RiemannInt_P5 : forall (f:R -> R) (a b:R) (pr1 pr2:Riemann_integrable f a b),   RiemannInt pr1 = RiemannInt pr2.
Lemma maxN : forall (a b:R) (del:posreal),   a < b -> { n:nat | a + INR n * del < b /\ b <= a + INR (S n) * del }.
Lemma Heine_cor1 : forall (f:R -> R) (a b:R),   a < b ->   (forall x:R, a <= x <= b -> continuity_pt f x) ->   forall eps:posreal,     { delta:posreal |       delta <= b - a /\       (forall x y:R,         a <= x <= b ->         a <= y <= b -> Rabs (x - y) < delta -> Rabs (f x - f y) < eps) }.
Lemma Heine_cor2 : forall (f:R -> R) (a b:R),   (forall x:R, a <= x <= b -> continuity_pt f x) ->   forall eps:posreal,     { delta:posreal |       forall x y:R,         a <= x <= b ->         a <= y <= b -> Rabs (x - y) < delta -> Rabs (f x - f y) < eps }.
Lemma SubEqui_P1 : forall (a b:R) (del:posreal) (h:a < b), pos_Rl (SubEqui del h) 0 = a.
Lemma SubEqui_P2 : forall (a b:R) (del:posreal) (h:a < b),   pos_Rl (SubEqui del h) (pred (Rlength (SubEqui del h))) = b.
Lemma SubEqui_P3 : forall (N:nat) (a b:R) (del:posreal), Rlength (SubEquiN N a b del) = S N.
Lemma SubEqui_P4 : forall (N:nat) (a b:R) (del:posreal) (i:nat),   (i < S N)%nat -> pos_Rl (SubEquiN (S N) a b del) i = a + INR i * del.
Lemma SubEqui_P5 : forall (a b:R) (del:posreal) (h:a < b),   Rlength (SubEqui del h) = S (S (max_N del h)).
Lemma SubEqui_P6 : forall (a b:R) (del:posreal) (h:a < b) (i:nat),   (i < S (max_N del h))%nat -> pos_Rl (SubEqui del h) i = a + INR i * del.
Lemma SubEqui_P7 : forall (a b:R) (del:posreal) (h:a < b), ordered_Rlist (SubEqui del h).
Lemma SubEqui_P8 : forall (a b:R) (del:posreal) (h:a < b) (i:nat),   (i < Rlength (SubEqui del h))%nat -> a <= pos_Rl (SubEqui del h) i <= b.
Lemma SubEqui_P9 : forall (a b:R) (del:posreal) (f:R -> R) (h:a < b),   { g:StepFun a b |     g b = f b /\     (forall i:nat,       (i < pred (Rlength (SubEqui del h)))%nat ->       constant_D_eq g       (co_interval (pos_Rl (SubEqui del h) i)         (pos_Rl (SubEqui del h) (S i)))       (f (pos_Rl (SubEqui del h) i))) }.
Lemma RiemannInt_P6 : forall (f:R -> R) (a b:R),   a < b ->   (forall x:R, a <= x <= b -> continuity_pt f x) -> Riemann_integrable f a b.
Lemma RiemannInt_P7 : forall (f:R -> R) (a:R), Riemann_integrable f a a.
Lemma continuity_implies_RiemannInt : forall (f:R -> R) (a b:R),   a <= b ->   (forall x:R, a <= x <= b -> continuity_pt f x) -> Riemann_integrable f a b.
Lemma RiemannInt_P8 : forall (f:R -> R) (a b:R) (pr1:Riemann_integrable f a b)   (pr2:Riemann_integrable f b a), RiemannInt pr1 = - RiemannInt pr2.
Lemma RiemannInt_P9 : forall (f:R -> R) (a:R) (pr:Riemann_integrable f a a), RiemannInt pr = 0.
Lemma Req_EM_T : forall r1 r2:R, {r1 = r2} + {r1 <> r2}.
Lemma RiemannInt_P10 : forall (f g:R -> R) (a b l:R),   Riemann_integrable f a b ->   Riemann_integrable g a b ->   Riemann_integrable (fun x:R => f x + l * g x) a b.
Lemma RiemannInt_P11 : forall (f:R -> R) (a b l:R) (un:nat -> posreal)   (phi1 phi2 psi1 psi2:nat -> StepFun a b),   Un_cv un 0 ->   (forall n:nat,     (forall t:R,       Rmin a b <= t <= Rmax a b -> Rabs (f t - phi1 n t) <= psi1 n t) /\     Rabs (RiemannInt_SF (psi1 n)) < un n) ->   (forall n:nat,     (forall t:R,       Rmin a b <= t <= Rmax a b -> Rabs (f t - phi2 n t) <= psi2 n t) /\     Rabs (RiemannInt_SF (psi2 n)) < un n) ->   Un_cv (fun N:nat => RiemannInt_SF (phi1 N)) l ->   Un_cv (fun N:nat => RiemannInt_SF (phi2 N)) l.
Lemma RiemannInt_P12 : forall (f g:R -> R) (a b l:R) (pr1:Riemann_integrable f a b)   (pr2:Riemann_integrable g a b)   (pr3:Riemann_integrable (fun x:R => f x + l * g x) a b),   a <= b -> RiemannInt pr3 = RiemannInt pr1 + l * RiemannInt pr2.
Lemma RiemannInt_P13 : forall (f g:R -> R) (a b l:R) (pr1:Riemann_integrable f a b)   (pr2:Riemann_integrable g a b)   (pr3:Riemann_integrable (fun x:R => f x + l * g x) a b),   RiemannInt pr3 = RiemannInt pr1 + l * RiemannInt pr2.
Lemma RiemannInt_P14 : forall a b c:R, Riemann_integrable (fct_cte c) a b.
Lemma RiemannInt_P15 : forall (a b c:R) (pr:Riemann_integrable (fct_cte c) a b),   RiemannInt pr = c * (b - a).
Lemma RiemannInt_P16 : forall (f:R -> R) (a b:R),   Riemann_integrable f a b -> Riemann_integrable (fun x:R => Rabs (f x)) a b.
Lemma Rle_cv_lim : forall (Un Vn:nat -> R) (l1 l2:R),   (forall n:nat, Un n <= Vn n) -> Un_cv Un l1 -> Un_cv Vn l2 -> l1 <= l2.
Lemma RiemannInt_P17 : forall (f:R -> R) (a b:R) (pr1:Riemann_integrable f a b)   (pr2:Riemann_integrable (fun x:R => Rabs (f x)) a b),   a <= b -> Rabs (RiemannInt pr1) <= RiemannInt pr2.
Lemma RiemannInt_P18 : forall (f g:R -> R) (a b:R) (pr1:Riemann_integrable f a b)   (pr2:Riemann_integrable g a b),   a <= b ->   (forall x:R, a < x < b -> f x = g x) -> RiemannInt pr1 = RiemannInt pr2.
Lemma RiemannInt_P19 : forall (f g:R -> R) (a b:R) (pr1:Riemann_integrable f a b)   (pr2:Riemann_integrable g a b),   a <= b ->   (forall x:R, a < x < b -> f x <= g x) -> RiemannInt pr1 <= RiemannInt pr2.
Lemma FTC_P1 : forall (f:R -> R) (a b:R),   a <= b ->   (forall x:R, a <= x <= b -> continuity_pt f x) ->   forall x:R, a <= x -> x <= b -> Riemann_integrable f a x.
Lemma RiemannInt_P20 : forall (f:R -> R) (a b:R) (h:a <= b)   (pr:forall x:R, a <= x -> x <= b -> Riemann_integrable f a x)   (pr0:Riemann_integrable f a b),   RiemannInt pr0 = primitive h pr b - primitive h pr a.
Lemma RiemannInt_P21 : forall (f:R -> R) (a b c:R),   a <= b ->   b <= c ->   Riemann_integrable f a b ->   Riemann_integrable f b c -> Riemann_integrable f a c.
Lemma RiemannInt_P22 : forall (f:R -> R) (a b c:R),   Riemann_integrable f a b -> a <= c <= b -> Riemann_integrable f a c.
Lemma RiemannInt_P23 : forall (f:R -> R) (a b c:R),   Riemann_integrable f a b -> a <= c <= b -> Riemann_integrable f c b.
Lemma RiemannInt_P24 : forall (f:R -> R) (a b c:R),   Riemann_integrable f a b ->   Riemann_integrable f b c -> Riemann_integrable f a c.
Lemma RiemannInt_P25 : forall (f:R -> R) (a b c:R) (pr1:Riemann_integrable f a b)   (pr2:Riemann_integrable f b c) (pr3:Riemann_integrable f a c),   a <= b -> b <= c -> RiemannInt pr1 + RiemannInt pr2 = RiemannInt pr3.
Lemma RiemannInt_P26 : forall (f:R -> R) (a b c:R) (pr1:Riemann_integrable f a b)   (pr2:Riemann_integrable f b c) (pr3:Riemann_integrable f a c),   RiemannInt pr1 + RiemannInt pr2 = RiemannInt pr3.
Lemma RiemannInt_P27 : forall (f:R -> R) (a b x:R) (h:a <= b)   (C0:forall x:R, a <= x <= b -> continuity_pt f x),   a < x < b -> derivable_pt_lim (primitive h (FTC_P1 h C0)) x (f x).
Lemma RiemannInt_P28 : forall (f:R -> R) (a b x:R) (h:a <= b)   (C0:forall x:R, a <= x <= b -> continuity_pt f x),   a <= x <= b -> derivable_pt_lim (primitive h (FTC_P1 h C0)) x (f x).
Lemma RiemannInt_P29 : forall (f:R -> R) a b (h:a <= b)   (C0:forall x:R, a <= x <= b -> continuity_pt f x),   antiderivative f (primitive h (FTC_P1 h C0)) a b.
Lemma RiemannInt_P30 : forall (f:R -> R) (a b:R),   a <= b ->   (forall x:R, a <= x <= b -> continuity_pt f x) ->   { g:R -> R | antiderivative f g a b }.
Lemma RiemannInt_P31 : forall (f:C1_fun) (a b:R),   a <= b -> antiderivative (derive f (diff0 f)) f a b.
Lemma RiemannInt_P32 : forall (f:C1_fun) (a b:R), Riemann_integrable (derive f (diff0 f)) a b.
Lemma RiemannInt_P33 : forall (f:C1_fun) (a b:R) (pr:Riemann_integrable (derive f (diff0 f)) a b),   a <= b -> RiemannInt pr = f b - f a.
Lemma FTC_Riemann : forall (f:C1_fun) (a b:R) (pr:Riemann_integrable (derive f (diff0 f)) a b),   RiemannInt pr = f b - f a.
Lemma growing_cv : forall Un:nat -> R, Un_growing Un -> has_ub Un -> { l:R | Un_cv Un l }.
Lemma decreasing_growing : forall Un:nat -> R, Un_decreasing Un -> Un_growing (opp_seq Un).
Lemma decreasing_cv : forall Un:nat -> R, Un_decreasing Un -> has_lb Un -> { l:R | Un_cv Un l }.
Lemma ub_to_lub : forall Un:nat -> R, has_ub Un -> { l:R | is_lub (EUn Un) l }.
Lemma lb_to_glb : forall Un:nat -> R, has_lb Un -> { l:R | is_lub (EUn (opp_seq Un)) l }.
Lemma maj_ss : forall (Un:nat -> R) (k:nat),   has_ub Un -> has_ub (fun i:nat => Un (k + i)%nat).
Lemma min_ss : forall (Un:nat -> R) (k:nat),   has_lb Un -> has_lb (fun i:nat => Un (k + i)%nat).
Lemma Wn_decreasing : forall (Un:nat -> R) (pr:has_ub Un), Un_decreasing (sequence_ub Un pr).
Lemma Vn_growing : forall (Un:nat -> R) (pr:has_lb Un), Un_growing (sequence_lb Un pr).
Lemma Vn_Un_Wn_order : forall (Un:nat -> R) (pr1:has_ub Un) (pr2:has_lb Un)   (n:nat), sequence_lb Un pr2 n <= Un n <= sequence_ub Un pr1 n.
Lemma min_maj : forall (Un:nat -> R) (pr1:has_ub Un) (pr2:has_lb Un),   has_ub (sequence_lb Un pr2).
Lemma maj_min : forall (Un:nat -> R) (pr1:has_ub Un) (pr2:has_lb Un),   has_lb (sequence_ub Un pr1).
Lemma cauchy_maj : forall Un:nat -> R, Cauchy_crit Un -> has_ub Un.
Lemma cauchy_opp : forall Un:nat -> R, Cauchy_crit Un -> Cauchy_crit (opp_seq Un).
Lemma cauchy_min : forall Un:nat -> R, Cauchy_crit Un -> has_lb Un.
Lemma maj_cv : forall (Un:nat -> R) (pr:Cauchy_crit Un),   { l:R | Un_cv (sequence_ub Un (cauchy_maj Un pr)) l }.
Lemma min_cv : forall (Un:nat -> R) (pr:Cauchy_crit Un),   { l:R | Un_cv (sequence_lb Un (cauchy_min Un pr)) l }.
Lemma cond_eq : forall x y:R, (forall eps:R, 0 < eps -> Rabs (x - y) < eps) -> x = y.
Lemma not_Rlt : forall r1 r2:R, ~ r1 < r2 -> r1 >= r2.
Lemma approx_maj : forall (Un:nat -> R) (pr:has_ub Un) (eps:R),   0 < eps ->  exists k : nat, Rabs (lub Un pr - Un k) < eps.
Lemma approx_min : forall (Un:nat -> R) (pr:has_lb Un) (eps:R),   0 < eps ->  exists k : nat, Rabs (glb Un pr - Un k) < eps.
Lemma UL_sequence : forall (Un:nat -> R) (l1 l2:R), Un_cv Un l1 -> Un_cv Un l2 -> l1 = l2.
Lemma CV_plus : forall (An Bn:nat -> R) (l1 l2:R),   Un_cv An l1 -> Un_cv Bn l2 -> Un_cv (fun i:nat => An i + Bn i) (l1 + l2).
Lemma cv_cvabs : forall (Un:nat -> R) (l:R),   Un_cv Un l -> Un_cv (fun i:nat => Rabs (Un i)) (Rabs l).
Lemma CV_Cauchy : forall Un:nat -> R, { l:R | Un_cv Un l } -> Cauchy_crit Un.
Lemma maj_by_pos : forall Un:nat -> R,   { l:R | Un_cv Un l } ->   exists l : R, 0 < l /\ (forall n:nat, Rabs (Un n) <= l).
Lemma CV_mult : forall (An Bn:nat -> R) (l1 l2:R),   Un_cv An l1 -> Un_cv Bn l2 -> Un_cv (fun i:nat => An i * Bn i) (l1 * l2).
Lemma tech9 : forall Un:nat -> R,   Un_growing Un -> forall m n:nat, (m <= n)%nat -> Un m <= Un n.
Lemma tech13 : forall (An:nat -> R) (k:R),   0 <= k < 1 ->   Un_cv (fun n:nat => Rabs (An (S n) / An n)) k ->   exists k0 : R,     k < k0 < 1 /\     (exists N : nat,       (forall n:nat, (N <= n)%nat -> Rabs (An (S n) / An n) < k0)).
Lemma growing_ineq : forall (Un:nat -> R) (l:R),   Un_growing Un -> Un_cv Un l -> forall n:nat, Un n <= l.
Lemma CV_opp : forall (An:nat -> R) (l:R), Un_cv An l -> Un_cv (opp_seq An) (- l).
Lemma decreasing_ineq : forall (Un:nat -> R) (l:R),   Un_decreasing Un -> Un_cv Un l -> forall n:nat, l <= Un n.
Lemma CV_minus : forall (An Bn:nat -> R) (l1 l2:R),   Un_cv An l1 -> Un_cv Bn l2 -> Un_cv (fun i:nat => An i - Bn i) (l1 - l2).
Lemma cv_infty_cv_R0 : forall Un:nat -> R,   (forall n:nat, Un n <> 0) -> cv_infty Un -> Un_cv (fun n:nat => / Un n) 0.
Lemma decreasing_prop : forall (Un:nat -> R) (m n:nat),   Un_decreasing Un -> (m <= n)%nat -> Un n <= Un m.
Lemma cv_speed_pow_fact : forall x:R, Un_cv (fun n:nat => x ^ n / INR (fact n)) 0.
Lemma interior_P1 : forall D:R -> Prop, included (interior D) D.
Lemma interior_P2 : forall D:R -> Prop, open_set D -> included D (interior D).
Lemma adherence_P1 : forall D:R -> Prop, included D (adherence D).
Lemma included_trans : forall D1 D2 D3:R -> Prop,   included D1 D2 -> included D2 D3 -> included D1 D3.
Lemma interior_P3 : forall D:R -> Prop, open_set (interior D).
Lemma complementary_P1 : forall D:R -> Prop,   ~ (exists y : R, intersection_domain D (complementary D) y).
Lemma adherence_P2 : forall D:R -> Prop, closed_set D -> included (adherence D) D.
Lemma adherence_P3 : forall D:R -> Prop, closed_set (adherence D).
Lemma open_set_P1 : forall D:R -> Prop, open_set D <-> D =_D interior D.
Lemma closed_set_P1 : forall D:R -> Prop, closed_set D <-> D =_D adherence D.
Lemma neighbourhood_P1 : forall (D1 D2:R -> Prop) (x:R),   included D1 D2 -> neighbourhood D1 x -> neighbourhood D2 x.
Lemma open_set_P2 : forall D1 D2:R -> Prop,   open_set D1 -> open_set D2 -> open_set (union_domain D1 D2).
Lemma open_set_P3 : forall D1 D2:R -> Prop,   open_set D1 -> open_set D2 -> open_set (intersection_domain D1 D2).
Lemma open_set_P4 : open_set (fun x:R => False).
Lemma open_set_P5 : open_set (fun x:R => True).
Lemma disc_P1 : forall (x:R) (del:posreal), open_set (disc x del).
Lemma continuity_P1 : forall (f:R -> R) (x:R),   continuity_pt f x <->   (forall W:R -> Prop,     neighbourhood W (f x) ->     exists V : R -> Prop,       neighbourhood V x /\ (forall y:R, V y -> W (f y))).
Lemma continuity_P2 : forall (f:R -> R) (D:R -> Prop),   continuity f -> open_set D -> open_set (image_rec f D).
Lemma continuity_P3 : forall f:R -> R,   continuity f <->   (forall D:R -> Prop, open_set D -> open_set (image_rec f D)).
Lemma restriction_family : forall (f:family) (D:R -> Prop) (x:R),   (exists y : R, (fun z1 z2:R => f z1 z2 /\ D z1) x y) ->   intersection_domain (ind f) D x.
Lemma family_P1 : forall (f:family) (D:R -> Prop),   family_open_set f -> family_open_set (subfamily f D).
Lemma open_set_P6 : forall D1 D2:R -> Prop, open_set D1 -> D1 =_D D2 -> open_set D2.
Lemma compact_P1 : forall X:R -> Prop, compact X -> bounded X.
Lemma compact_P2 : forall X:R -> Prop, compact X -> closed_set X.
Lemma compact_EMP : compact (fun _:R => False).
Lemma compact_eqDom : forall X1 X2:R -> Prop, compact X1 -> X1 =_D X2 -> compact X2.
Lemma compact_P3 : forall a b:R, compact (fun c:R => a <= c <= b).
Lemma compact_P4 : forall X F:R -> Prop, compact X -> closed_set F -> included F X -> compact F.
Lemma compact_P5 : forall X:R -> Prop, closed_set X -> bounded X -> compact X.
Lemma compact_carac : forall X:R -> Prop, compact X <-> closed_set X /\ bounded X.
Lemma continuity_compact : forall (f:R -> R) (X:R -> Prop),   (forall x:R, continuity_pt f x) -> compact X -> compact (image_dir f X).
Lemma Rlt_Rminus : forall a b:R, a < b -> 0 < b - a.
Lemma prolongement_C0 : forall (f:R -> R) (a b:R),   a <= b ->   (forall c:R, a <= c <= b -> continuity_pt f c) ->   exists g : R -> R,     continuity g /\ (forall c:R, a <= c <= b -> g c = f c).
Lemma continuity_ab_maj : forall (f:R -> R) (a b:R),   a <= b ->   (forall c:R, a <= c <= b -> continuity_pt f c) ->   exists Mx : R, (forall c:R, a <= c <= b -> f c <= f Mx) /\ a <= Mx <= b.
Lemma continuity_ab_min : forall (f:R -> R) (a b:R),   a <= b ->   (forall c:R, a <= c <= b -> continuity_pt f c) ->   exists mx : R, (forall c:R, a <= c <= b -> f mx <= f c) /\ a <= mx <= b.
Lemma ValAdh_un_exists : forall (un:nat -> R) (D:=fun x:R =>  exists n : nat, x = INR n)   (f:=     fun x:R =>       adherence       (fun y:R => (exists p : nat, y = un p /\ x <= INR p) /\ D x))   (x:R), (exists y : R, f x y) -> D x.
Lemma ValAdh_un_prop : forall (un:nat -> R) (x:R), ValAdh un x <-> ValAdh_un un x.
Lemma adherence_P4 : forall F G:R -> Prop, included F G -> included (adherence F) (adherence G).
Lemma compact_P6 : forall X:R -> Prop,   compact X ->   (exists z : R, X z) ->   forall g:family,     family_closed_set g ->     intersection_vide_in X g ->     exists D : R -> Prop, intersection_vide_finite_in X (subfamily g D).
Lemma is_lub_u : forall (E:R -> Prop) (x y:R), is_lub E x -> is_lub E y -> x = y.
Lemma domain_P1 : forall X:R -> Prop,   ~ (exists y : R, X y) \/   (exists y : R, X y /\ (forall x:R, X x -> x = y)) \/   (exists x : R, (exists y : R, X x /\ X y /\ x <> y)).
Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.
Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
Lemma lt_trans : forall x y z, x<y -> y<z -> x<z.
Lemma lt_not_eq : forall x y, x<y -> ~ x=y.
Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
Lemma eq_refl : forall x : t, eq x x.
Lemma eq_sym : forall x y : t, eq x y -> eq y x.
Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.
Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.
Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
Lemma bits_lt_trans :   forall x y z : positive, bits_lt x y -> bits_lt y z -> bits_lt x z.
Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.
Lemma bits_lt_antirefl : forall x : positive, ~ bits_lt x x.
Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
Lemma eq_dec (x y: positive): {x = y} + {x <> y}.
Lemma eq_bool_alt : forall b b', b=b' <-> (b=true <-> b'=true).
Lemma eq_option_alt : forall (elt:Type)(o o':option elt), o=o' <-> (forall e, o=Some e <-> o'=Some e).
Lemma MapsTo_fun : forall (elt:Type) m x (e e':elt), MapsTo x e m -> MapsTo x e' m -> e=e'.
Lemma In_iff : forall m x y, E.eq x y -> (In x m <-> In y m).
Lemma MapsTo_iff : forall m x y e, E.eq x y -> (MapsTo x e m <-> MapsTo y e m).
Lemma mem_in_iff : forall m x, In x m <-> mem x m = true.
Lemma not_mem_in_iff : forall m x, ~In x m <-> mem x m = false.
Lemma In_dec : forall m x, { In x m } + { ~ In x m }.
Lemma find_mapsto_iff : forall m x e, MapsTo x e m <-> find x m = Some e.
Lemma not_find_in_iff : forall m x, ~In x m <-> find x m = None.
Lemma in_find_iff : forall m x, In x m <-> find x m <> None.
Lemma equal_iff : forall m m' cmp, Equivb cmp m m' <-> equal cmp m m' = true.
Lemma empty_mapsto_iff : forall x e, MapsTo x e (empty elt) <-> False.
Lemma empty_in_iff : forall x, In x (empty elt) <-> False.
Lemma is_empty_iff : forall m, Empty m <-> is_empty m = true.
Lemma add_mapsto_iff : forall m x y e e', MapsTo y e' (add x e m) <->    (E.eq x y /\ e=e') \/
Lemma add_in_iff : forall m x y e, In y (add x e m) <-> E.eq x y \/ In y m.
Lemma add_neq_mapsto_iff : forall m x y e e', ~ E.eq x y -> (MapsTo y e' (add x e m)  <-> MapsTo y e' m).
Lemma add_neq_in_iff : forall m x y e, ~ E.eq x y -> (In y (add x e m)  <-> In y m).
Lemma remove_mapsto_iff : forall m x y e, MapsTo y e (remove x m) <-> ~E.eq x y /\ MapsTo y e m.
Lemma remove_in_iff : forall m x y, In y (remove x m) <-> ~E.eq x y /\ In y m.
Lemma remove_neq_mapsto_iff : forall m x y e, ~ E.eq x y -> (MapsTo y e (remove x m)  <-> MapsTo y e m).
Lemma remove_neq_in_iff : forall m x y, ~ E.eq x y -> (In y (remove x m)  <-> In y m).
Lemma elements_mapsto_iff : forall m x e, MapsTo x e m <-> InA (@eq_key_elt _) (x,e) (elements m).
Lemma elements_in_iff : forall m x, In x m <-> exists e, InA (@eq_key_elt _) (x,e) (elements m).
Lemma map_mapsto_iff : forall m x b (f : elt -> elt'), MapsTo x b (map f m) <-> exists a, b = f a /\ MapsTo x a m.
Lemma map_in_iff : forall m x (f : elt -> elt'), In x (map f m) <-> In x m.
Lemma mapi_in_iff : forall m x (f:key->elt->elt'), In x (mapi f m) <-> In x m.
Lemma mapi_inv : forall m x b (f : key -> elt -> elt'), MapsTo x b (mapi f m) -> exists a y, E.eq y x /\ b = f y a /\ MapsTo x a m.
Lemma mapi_1bis : forall m x e (f:key->elt->elt'), (forall x y e, E.eq x y -> f x e = f y e) ->
Lemma mapi_mapsto_iff : forall m x b (f:key->elt->elt'), (forall x y e, E.eq x y -> f x e = f y e) ->
Lemma mem_find_b : forall (elt:Type)(m:t elt)(x:key), mem x m = if find x m then true else false.
Lemma mem_b : forall m x y, E.eq x y -> mem x m = mem y m.
Lemma find_o : forall m x y, E.eq x y -> find x m = find y m.
Lemma empty_o : forall x, find x (empty elt) = None.
Lemma empty_a : forall x, mem x (empty elt) = false.
Lemma add_eq_o : forall m x y e, E.eq x y -> find y (add x e m) = Some e.
Lemma add_neq_o : forall m x y e, ~ E.eq x y -> find y (add x e m) = find y m.
Lemma add_o : forall m x y e, find y (add x e m) = if eq_dec x y then Some e else find y m.
Lemma add_eq_b : forall m x y e, E.eq x y -> mem y (add x e m) = true.
Lemma add_neq_b : forall m x y e, ~E.eq x y -> mem y (add x e m) = mem y m.
Lemma add_b : forall m x y e, mem y (add x e m) = eqb x y || mem y m.
Lemma remove_eq_o : forall m x y, E.eq x y -> find y (remove x m) = None.
Lemma remove_neq_o : forall m x y, ~ E.eq x y -> find y (remove x m) = find y m.
Lemma remove_o : forall m x y, find y (remove x m) = if eq_dec x y then None else find y m.
Lemma remove_eq_b : forall m x y, E.eq x y -> mem y (remove x m) = false.
Lemma remove_neq_b : forall m x y, ~ E.eq x y -> mem y (remove x m) = mem y m.
Lemma remove_b : forall m x y, mem y (remove x m) = negb (eqb x y) && mem y m.
Lemma map_o : forall m x (f:elt->elt'), find x (map f m) = option_map f (find x m).
Lemma map_b : forall m x (f:elt->elt'), mem x (map f m) = mem x m.
Lemma mapi_b : forall m x (f:key->elt->elt'), mem x (mapi f m) = mem x m.
Lemma mapi_o : forall m x (f:key->elt->elt'), (forall x y e, E.eq x y -> f x e = f y e) ->
Lemma map2_1bis : forall (m: t elt)(m': t elt') x (f:option elt->option elt'->option elt''), f None None = None -> find x (map2 f m m') = f (find x m) (find x m').
Lemma elements_o : forall m x, find x m = findA (eqb x) (elements m).
Lemma elements_b : forall m x, mem x m = existsb (fun p => eqb x (fst p)) (elements m).
Lemma Equal_mapsto_iff : forall m1 m2 : t elt, Equal m1 m2 <-> (forall k e, MapsTo k e m1 <-> MapsTo k e m2).
Lemma Equal_Equiv : forall (m m' : t elt), Equal m m' <-> Equiv Logic.eq m m'.
Lemma Equiv_Equivb : compat_cmp -> forall m m', Equiv eq_elt m m' <-> Equivb cmp m m'.
Lemma Equal_Equivb : forall cmp, (forall e e', cmp e e' = true <-> e = e') -> forall (m m':t elt), Equal m m' <-> Equivb cmp m m'.
Lemma Equal_Equivb_eqdec : forall eq_elt_dec : (forall e e', { e = e' } + { e <> e' }), let cmp := fun e e' => if eq_elt_dec e e' then true else false in forall (m m':t elt), Equal m m' <-> Equivb cmp m m'.
Lemma Equal_refl : forall (elt:Type)(m : t elt), Equal m m.
Lemma Equal_sym : forall (elt:Type)(m m' : t elt), Equal m m' -> Equal m' m.
Lemma Equal_trans : forall (elt:Type)(m m' m'' : t elt), Equal m m' -> Equal m' m'' -> Equal m m''.
Lemma InA_eqke_eqk : forall k1 k2 e1 e2 l,   E.eq k1 k2 -> InA eqke (k1,e1) l -> InA eqk (k2,e2) l.
Lemma NoDupA_eqk_eqke : forall l, NoDupA eqk l -> NoDupA eqke l.
Lemma findA_rev : forall l k, NoDupA eqk l ->   findA (eqb k) l = findA (eqb k) (rev l).
Lemma elements_Empty : forall m:t elt, Empty m <-> elements m = nil.
Lemma elements_empty : elements (@empty elt) = nil.
Lemma of_list_1 : forall l k e,   NoDupA eqk l ->   (MapsTo k e (of_list l) <-> InA eqke (k,e) l).
Lemma of_list_1b : forall l k,   NoDupA eqk l ->   find k (of_list l) = findA (eqb k) l.
Lemma of_list_2 : forall l, NoDupA eqk l ->   equivlistA eqke l (to_list (of_list l)).
Lemma of_list_3 : forall s, Equal (of_list (to_list s)) s.
Lemma fold_spec_right m (A:Type)(i:A)(f : key -> elt -> A -> A) :   fold f m i = List.fold_right (uncurry f) i (rev (elements m)).
Lemma fold_rec :   forall (A:Type)(P : t elt -> A -> Type)(f : key -> elt -> A -> A),    forall (i:A)(m:t elt),     (forall m, Empty m -> P m i) ->     (forall k e a m' m'', MapsTo k e m -> ~In k m' ->        Add k e m' m'' -> P m' a -> P m'' (f k e a)) ->     P m (fold f m i).
Lemma fold_rec_nodep :   forall (A:Type)(P : A -> Type)(f : key -> elt -> A -> A)(i:A)(m:t elt),    P i -> (forall k e a, MapsTo k e m -> P a -> P (f k e a)) ->    P (fold f m i).
Lemma fold_rec_weak :   forall (A:Type)(P : t elt -> A -> Type)(f : key -> elt -> A -> A)(i:A),   (forall m m' a, Equal m m' -> P m a -> P m' a) ->   P (empty _) i ->   (forall k e a m, ~In k m -> P m a -> P (add k e m) (f k e a)) ->   forall m, P m (fold f m i).
Lemma fold_rel :   forall (A B:Type)(R : A -> B -> Type)    (f : key -> elt -> A -> A)(g : key -> elt -> B -> B)(i : A)(j : B)    (m : t elt),    R i j ->    (forall k e a b, MapsTo k e m -> R a b -> R (f k e a) (g k e b)) ->    R (fold f m i) (fold g m j).
Lemma map_induction :  forall P : t elt -> Type,  (forall m, Empty m -> P m) ->  (forall m m', P m -> forall x e, ~In x m -> Add x e m m' -> P m') ->  forall m, P m.
Lemma map_induction_bis :  forall P : t elt -> Type,  (forall m m', Equal m m' -> P m -> P m') ->  P (empty _) ->  (forall x e m, ~In x m -> P m -> P (add x e m)) ->  forall m, P m.
Lemma fold_identity : forall m : t elt, Equal (fold (@add _) m (empty _)) m.
Lemma fold_init :  forall m i i', eqA i i' -> eqA (fold f m i) (fold f m i').
Lemma fold_Empty :  forall m i, Empty m -> eqA (fold f m i) i.
Lemma fold_commutes : forall i m k e, ~In k m ->  eqA (fold f m (f k e i)) (f k e (fold f m i)).
Lemma fold_Equal : forall m1 m2 i, Equal m1 m2 ->  eqA (fold f m1 i) (fold f m2 i).
Lemma fold_Add : forall m1 m2 k e i, ~In k m1 -> Add k e m1 m2 ->  eqA (fold f m2 i) (f k e (fold f m1 i)).
Lemma fold_add : forall m k e i, ~In k m ->  eqA (fold f (add k e m) i) (f k e (fold f m i)).
Lemma cardinal_fold : forall m : t elt,  cardinal m = fold (fun _ _ => S) m 0.
Lemma cardinal_Empty : forall m : t elt,  Empty m <-> cardinal m = 0.
Lemma Equal_cardinal : forall m m' : t elt,   Equal m m' -> cardinal m = cardinal m'.
Lemma cardinal_1 : forall m : t elt, Empty m -> cardinal m = 0.
Lemma cardinal_2 :   forall m m' x e, ~ In x m -> Add x e m m' -> cardinal m' = S (cardinal m).
Lemma cardinal_inv_1 : forall m : t elt,  cardinal m = 0 -> Empty m.
Lemma cardinal_inv_2 :  forall m n, cardinal m = S n -> { p : key*elt | MapsTo (fst p) (snd p) m }.
Lemma cardinal_inv_2b :  forall m, cardinal m <> 0 -> { p : key*elt | MapsTo (fst p) (snd p) m }.
Lemma filter_iff : forall m k e,  MapsTo k e (filter f m) <-> MapsTo k e m /\ f k e = true.
Lemma for_all_iff : forall m,  for_all f m = true <-> (forall k e, MapsTo k e m -> f k e = true).
Lemma exists_iff : forall m,  exists_ f m = true <->  (exists p, MapsTo (fst p) (snd p) m /\ f (fst p) (snd p) = true).
Lemma Disjoint_alt : forall m m',  Disjoint m m' <->  (forall k e e', MapsTo k e m -> MapsTo k e' m' -> False).
Lemma partition_iff_1 : forall m m1 k e,  m1 = fst (partition f m) ->  (MapsTo k e m1 <-> MapsTo k e m /\ f k e = true).
Lemma partition_iff_2 : forall m m2 k e,  m2 = snd (partition f m) ->  (MapsTo k e m2 <-> MapsTo k e m /\ f k e = false).
Lemma partition_Partition : forall m m1 m2,  partition f m = (m1,m2) -> Partition m m1 m2.
Lemma Partition_In : forall m m1 m2 k,  Partition m m1 m2 -> In k m -> {In k m1}+{In k m2}.
Lemma Disjoint_sym : forall m1 m2, Disjoint m1 m2 -> Disjoint m2 m1.
Lemma Partition_sym : forall m m1 m2,  Partition m m1 m2 -> Partition m m2 m1.
Lemma Partition_Empty : forall m m1 m2, Partition m m1 m2 ->  (Empty m <-> (Empty m1 /\ Empty m2)).
Lemma Partition_Add :   forall m m' x e , ~In x m -> Add x e m m' ->   forall m1 m2, Partition m' m1 m2 ->    exists m3, (Add x e m3 m1 /\ Partition m m3 m2 \/                Add x e m3 m2 /\ Partition m m1 m3).
Lemma Partition_fold :  forall (A:Type)(eqA:A->A->Prop)(st:Equivalence eqA)(f:key->elt->A->A),  Proper (E.eq==>eq==>eqA==>eqA) f ->
Lemma Partition_cardinal : forall m m1 m2, Partition m m1 m2 ->  cardinal m = cardinal m1 + cardinal m2.
Lemma Partition_partition : forall m m1 m2, Partition m m1 m2 ->   let f := fun k (_:elt) => mem k m1 in  Equal m1 (fst (partition f m)) /\ Equal m2 (snd (partition f m)).
Lemma update_mapsto_iff : forall m m' k e,  MapsTo k e (update m m') <->   (MapsTo k e m' \/ (MapsTo k e m /\ ~In k m')).
Lemma update_dec : forall m m' k e, MapsTo k e (update m m') ->  { MapsTo k e m' } + { MapsTo k e m /\ ~In k m'}.
Lemma update_in_iff : forall m m' k,  In k (update m m') <-> In k m \/ In k m'.
Lemma diff_mapsto_iff : forall m m' k e,  MapsTo k e (diff m m') <-> MapsTo k e m /\ ~In k m'.
Lemma diff_in_iff : forall m m' k,  In k (diff m m') <-> In k m /\ ~In k m'.
Lemma restrict_mapsto_iff : forall m m' k e,  MapsTo k e (restrict m m') <-> MapsTo k e m /\ In k m'.
Lemma restrict_in_iff : forall m m' k,  In k (restrict m m') <-> In k m /\ In k m'.
Lemma sort_equivlistA_eqlistA : forall l l' : list (key*elt),  sort ltk l -> sort ltk l' -> equivlistA eqke l l' -> eqlistA eqke l l'.
Lemma gtb_1 : forall p p', gtb p p' = true <-> ltk p' p.
Lemma leb_1 : forall p p', leb p p' = true <-> ~ltk p' p.
Lemma gtb_compat : forall p, Proper (eqke==>eq) (gtb p).
Lemma leb_compat : forall p, Proper (eqke==>eq) (leb p).
Lemma elements_split : forall p m,   elements m = elements_lt p m ++ elements_ge p m.
Lemma elements_Add : forall m m' x e, ~In x m -> Add x e m m' ->   eqlistA eqke (elements m')                (elements_lt (x,e) m ++ (x,e):: elements_ge (x,e) m).
Lemma elements_Add_Above : forall m m' x e,  Above x m -> Add x e m m' ->    eqlistA eqke (elements m') (elements m ++ (x,e)::nil).
Lemma elements_Add_Below : forall m m' x e,  Below x m -> Add x e m m' ->    eqlistA eqke (elements m') ((x,e)::elements m).
Lemma elements_Equal_eqlistA : forall (m m': t elt),  Equal m m' -> eqlistA eqke (elements m) (elements m').
Lemma max_elt_Above :  forall m x e, max_elt m = Some (x,e) -> Above x (remove x m).
Lemma max_elt_MapsTo :  forall m x e, max_elt m = Some (x,e) -> MapsTo x e m.
Lemma max_elt_Empty :  forall m, max_elt m = None -> Empty m.
Lemma min_elt_Below :  forall m x e, min_elt m = Some (x,e) -> Below x (remove x m).
Lemma min_elt_MapsTo :  forall m x e, min_elt m = Some (x,e) -> MapsTo x e m.
Lemma min_elt_Empty :  forall m, min_elt m = None -> Empty m.
Lemma map_induction_max :  forall P : t elt -> Type,  (forall m, Empty m -> P m) ->  (forall m m', P m -> forall x e, Above x m -> Add x e m m' -> P m') ->  forall m, P m.
Lemma map_induction_min :  forall P : t elt -> Type,  (forall m, Empty m -> P m) ->  (forall m m', P m -> forall x e, Below x m -> Add x e m m' -> P m') ->  forall m, P m.
Lemma fold_Equal : forall m1 m2 (A:Type)(eqA:A->A->Prop)(st:Equivalence  eqA)  (f:key->elt->A->A)(i:A),  Proper (E.eq==>eq==>eqA==>eqA) f ->
Lemma fold_Add_Above : forall m1 m2 x e (A:Type)(eqA:A->A->Prop)(st:Equivalence eqA)  (f:key->elt->A->A)(i:A) (P:Proper (E.eq==>eq==>eqA==>eqA) f),
Lemma fold_Add_Below : forall m1 m2 x e (A:Type)(eqA:A->A->Prop)(st:Equivalence eqA)  (f:key->elt->A->A)(i:A) (P:Proper (E.eq==>eq==>eqA==>eqA) f),
Lemma Zle_not_lt n m : n <= m -> ~ m < n.
Lemma Zlt_not_le n m : n < m -> ~ m <= n.
Lemma Zle_not_gt n m : n <= m -> ~ n > m.
Lemma Zgt_not_le n m : n > m -> ~ n <= m.
Lemma Znot_ge_lt n m : ~ n >= m -> n < m.
Lemma Znot_lt_ge n m : ~ n < m -> n >= m.
Lemma Znot_gt_le n m: ~ n > m -> n <= m.
Lemma Znot_le_gt n m : ~ n <= m -> n > m.
Lemma not_Zne n m : ~ Zne n m -> n = m.
Lemma Zgt_asym n m : n > m -> ~ m > n.
Lemma Zgt_irrefl n : ~ n > n.
Lemma Zle_lt_or_eq n m : n <= m -> n < m \/ n = m.
Lemma Zgt_trans n m p : n > m -> m > p -> n > p.
Lemma Zle_gt_trans n m p : m <= n -> m > p -> n > p.
Lemma Zgt_le_trans n m p : n > m -> p <= m -> n > p.
Lemma Zge_trans n m p : n >= m -> m >= p -> n >= p.
Lemma Zsucc_le_compat n m : m <= n -> Z.succ m <= Z.succ n.
Lemma Zsucc_lt_compat n m : n < m -> Z.succ n < Z.succ m.
Lemma Zsucc_gt_compat n m : m > n -> Z.succ m > Z.succ n.
Lemma Zsucc_gt_reg n m : Z.succ m > Z.succ n -> m > n.
Lemma Zsucc_le_reg n m : Z.succ m <= Z.succ n -> m <= n.
Lemma Zsucc_lt_reg n m : Z.succ n < Z.succ m -> n < m.
Lemma Zgt_succ n : Z.succ n > n.
Lemma Znot_le_succ n : ~ Z.succ n <= n.
Lemma Zgt_le_succ n m : m > n -> Z.succ n <= m.
Lemma Zle_gt_succ n m : n <= m -> Z.succ m > n.
Lemma Zle_lt_succ n m : n <= m -> n < Z.succ m.
Lemma Zlt_le_succ n m : n < m -> Z.succ n <= m.
Lemma Zgt_succ_le n m : Z.succ m > n -> n <= m.
Lemma Zlt_succ_le n m : n < Z.succ m -> n <= m.
Lemma Zle_succ_gt n m : Z.succ n <= m -> m > n.
Lemma Zle_succ_le n m : Z.succ n <= m -> n <= m.
Lemma Zgt_succ_pred n m : m > Z.succ n -> Z.pred m > n.
Lemma Zlt_succ_pred n m : Z.succ n < m -> n < Z.pred m.
Lemma Zlt_0_le_0_pred n : 0 < n -> 0 <= Z.pred n.
Lemma Zgt_0_le_0_pred n : n > 0 -> 0 <= Z.pred n.
Lemma Zle_neg_pos : forall p q:positive, Zneg p <= Zpos q.
Lemma Zgt_pos_0 : forall p:positive, Zpos p > 0.
Lemma Zle_0_pos : forall p:positive, 0 <= Zpos p.
Lemma Zlt_neg_0 : forall p:positive, Zneg p < 0.
Lemma Zle_0_nat : forall n:nat, 0 <= Z.of_nat n.
Lemma Zgt_succ_gt_or_eq n m : Z.succ n > m -> n > m \/ m = n.
Lemma Zplus_gt_compat_l n m p : n > m -> p + n > p + m.
Lemma Zplus_gt_compat_r n m p : n > m -> n + p > m + p.
Lemma Zplus_le_compat_l n m p : n <= m -> p + n <= p + m.
Lemma Zplus_le_compat_r n m p : n <= m -> n + p <= m + p.
Lemma Zplus_lt_compat_l n m p : n < m -> p + n < p + m.
Lemma Zplus_lt_compat_r n m p : n < m -> n + p < m + p.
Lemma Zplus_le_reg_l n m p : p + n <= p + m -> n <= m.
Lemma Zplus_le_reg_r n m p : n + p <= m + p -> n <= m.
Lemma Zplus_lt_reg_l n m p : p + n < p + m -> n < m.
Lemma Zplus_lt_reg_r n m p : n + p < m + p -> n < m.
Lemma Zplus_gt_reg_l n m p : p + n > p + m -> n > m.
Lemma Zplus_gt_reg_r n m p : n + p > m + p -> n > m.
Lemma Zmult_le_compat_r n m p : n <= m -> 0 <= p -> n * p <= m * p.
Lemma Zmult_le_compat_l n m p : n <= m -> 0 <= p -> p * n <= p * m.
Lemma Zmult_lt_compat_r n m p : 0 < p -> n < m -> n * p < m * p.
Lemma Zmult_gt_compat_r n m p : p > 0 -> n > m -> n * p > m * p.
Lemma Zmult_gt_0_lt_compat_r n m p : p > 0 -> n < m -> n * p < m * p.
Lemma Zmult_gt_0_le_compat_r n m p : p > 0 -> n <= m -> n * p <= m * p.
Lemma Zmult_lt_0_le_compat_r n m p : 0 < p -> n <= m -> n * p <= m * p.
Lemma Zmult_gt_0_lt_compat_l n m p : p > 0 -> n < m -> p * n < p * m.
Lemma Zmult_lt_compat_l n m p : 0 < p -> n < m -> p * n < p * m.
Lemma Zmult_gt_compat_l n m p : p > 0 -> n > m -> p * n > p * m.
Lemma Zmult_ge_compat_r n m p : n >= m -> p >= 0 -> n * p >= m * p.
Lemma Zmult_ge_compat_l n m p : n >= m -> p >= 0 -> p * n >= p * m.
Lemma Zmult_ge_compat n m p q : n >= p -> m >= q -> p >= 0 -> q >= 0 -> n * m >= p * q.
Lemma Zmult_le_compat n m p q : n <= p -> m <= q -> 0 <= n -> 0 <= m -> n * m <= p * q.
Lemma Zmult_gt_0_lt_reg_r n m p : p > 0 -> n * p < m * p -> n < m.
Lemma Zmult_lt_reg_r n m p : 0 < p -> n * p < m * p -> n < m.
Lemma Zmult_le_reg_r n m p : p > 0 -> n * p <= m * p -> n <= m.
Lemma Zmult_lt_0_le_reg_r n m p : 0 < p -> n * p <= m * p -> n <= m.
Lemma Zmult_ge_reg_r n m p : p > 0 -> n * p >= m * p -> n >= m.
Lemma Zmult_gt_reg_r n m p : p > 0 -> n * p > m * p -> n > m.
Lemma Zmult_lt_compat n m p q : 0 <= n < p -> 0 <= m < q -> n * m < p * q.
Lemma Zmult_lt_compat2 n m p q : 0 < n <= p -> 0 < m < q -> n * m < p * q.
Lemma Zmult_gt_0_compat n m : n > 0 -> m > 0 -> n * m > 0.
Lemma Zmult_gt_0_le_0_compat n m : n > 0 -> 0 <= m -> 0 <= m * n.
Lemma Zmult_le_0_reg_r n m : n > 0 -> 0 <= m * n -> 0 <= m.
Lemma Zmult_lt_0_reg_r n m : 0 < n -> 0 < m * n -> 0 < m.
Lemma Zmult_gt_0_lt_0_reg_r n m : n > 0 -> 0 < m * n -> 0 < m.
Lemma Zmult_gt_0_reg_l n m : n > 0 -> n * m > 0 -> m > 0.
Lemma Zlt_square_simpl n m : 0 <= n -> m * m < n * n -> m < n.
Lemma Zgt_square_simpl n m : n >= 0 -> n * n > m * m -> n > m.
Lemma Zeq_plus_swap n m p : n + p = m <-> n = m - p.
Lemma Zlt_0_minus_lt n m : 0 < n - m -> m < n.
Lemma Zle_0_minus_le n m : 0 <= n - m -> m <= n.
Lemma Zle_minus_le_0 n m : m <= n -> 0 <= n - m.
Lemma IZR_nz : forall p : positive, IZR (Zpos p) <> 0%R.
Lemma eqR_Qeq : forall x y : Q, Q2R x = Q2R y -> x==y.
Lemma Qeq_eqR : forall x y : Q, x==y -> Q2R x = Q2R y.
Lemma Rle_Qle : forall x y : Q, (Q2R x <= Q2R y)%R -> x<=y.
Lemma Qle_Rle : forall x y : Q, x<=y -> (Q2R x <= Q2R y)%R.
Lemma Rlt_Qlt : forall x y : Q, (Q2R x < Q2R y)%R -> x<y.
Lemma Qlt_Rlt : forall x y : Q, x<y -> (Q2R x < Q2R y)%R.
Lemma Q2R_plus : forall x y : Q, Q2R (x+y) = (Q2R x + Q2R y)%R.
Lemma Q2R_mult : forall x y : Q, Q2R (x*y) = (Q2R x * Q2R y)%R.
Lemma Q2R_opp : forall x : Q, Q2R (- x) = (- Q2R x)%R.
Lemma Q2R_minus : forall x y : Q, Q2R (x-y) = (Q2R x - Q2R y)%R.
Lemma Q2R_inv : forall x : Q, ~ x==0 -> Q2R (/x) = (/ Q2R x)%R.
Lemma Q2R_div : forall x y : Q, ~ y==0 -> Q2R (x/y) = (Q2R x / Q2R y)%R.
Lemma even_or_odd : forall n, even n \/ odd n.
Lemma even_odd_dec : forall n, {even n} + {odd n}.
Lemma not_even_and_odd : forall n, even n -> odd n -> False.
Lemma even_plus_split : forall n m, (even (n + m) -> even n /\ even m \/ odd n /\ odd m) with odd_plus_split : forall n m, odd (n + m) -> odd n /\ even m \/ even n /\ odd m.
Lemma even_even_plus : forall n m, even n -> even m -> even (n + m) with odd_plus_l : forall n m, odd n -> even m -> odd (n + m).
Lemma odd_plus_r : forall n m, even n -> odd m -> odd (n + m) with odd_even_plus : forall n m, odd n -> odd m -> even (n + m).
Lemma even_plus_aux : forall n m,   (odd (n + m) <-> odd n /\ even m \/ even n /\ odd m) /\   (even (n + m) <-> even n /\ even m \/ odd n /\ odd m).
Lemma even_plus_even_inv_r : forall n m, even (n + m) -> even n -> even m.
Lemma even_plus_even_inv_l : forall n m, even (n + m) -> even m -> even n.
Lemma even_plus_odd_inv_r : forall n m, even (n + m) -> odd n -> odd m.
Lemma even_plus_odd_inv_l : forall n m, even (n + m) -> odd m -> odd n.
Lemma odd_plus_even_inv_l : forall n m, odd (n + m) -> odd m -> even n.
Lemma odd_plus_even_inv_r : forall n m, odd (n + m) -> odd n -> even m.
Lemma odd_plus_odd_inv_l : forall n m, odd (n + m) -> even m -> odd n.
Lemma odd_plus_odd_inv_r : forall n m, odd (n + m) -> even n -> odd m.
Lemma even_mult_aux : forall n m,   (odd (n * m) <-> odd n /\ odd m) /\ (even (n * m) <-> even n \/ even m).
Lemma even_mult_l : forall n m, even n -> even (n * m).
Lemma even_mult_r : forall n m, even m -> even (n * m).
Lemma even_mult_inv_r : forall n m, even (n * m) -> odd n -> even m.
Lemma even_mult_inv_l : forall n m, even (n * m) -> odd m -> even n.
Lemma odd_mult : forall n m, odd n -> odd m -> odd (n * m).
Lemma odd_mult_inv_l : forall n m, odd (n * m) -> odd n.
Lemma odd_mult_inv_r : forall n m, odd (n * m) -> odd m.
Lemma In_compat : Proper (X.eq==>eq==>iff) In.
Lemma mem_spec : forall s x `{Ok s},  mem x s = true <-> In x s.
Lemma isok_iff : forall l, Ok l <-> isok l = true.
Lemma add_spec :  forall (s : t) (x y : elt) {Hs : Ok s},    In y (add x s) <-> X.eq y x \/ In y s.
Lemma remove_spec :  forall (s : t) (x y : elt) {Hs : Ok s},    In y (remove x s) <-> In y s /\ ~X.eq y x.
Lemma singleton_ok : forall x : elt, Ok (singleton x).
Lemma singleton_spec : forall x y : elt, In y (singleton x) <-> X.eq y x.
Lemma empty_ok : Ok empty.
Lemma empty_spec : Empty empty.
Lemma is_empty_spec : forall s : t, is_empty s = true <-> Empty s.
Lemma elements_spec1 : forall (s : t) (x : elt), In x (elements s) <-> In x s.
Lemma elements_spec2w : forall (s : t) {Hs : Ok s}, NoDup (elements s).
Lemma fold_spec :  forall (s : t) (A : Type) (i : A) (f : elt -> A -> A),  fold f s i = fold_left (flip f) (elements s) i.
Lemma union_spec :  forall (s s' : t) (x : elt) {Hs : Ok s} {Hs' : Ok s'},  In x (union s s') <-> In x s \/ In x s'.
Lemma inter_spec  :  forall (s s' : t) (x : elt) {Hs : Ok s} {Hs' : Ok s'},  In x (inter s s') <-> In x s /\ In x s'.
Lemma diff_spec  :  forall (s s' : t) (x : elt) {Hs : Ok s} {Hs' : Ok s'},  In x (diff s s') <-> In x s /\ ~In x s'.
Lemma subset_spec :  forall (s s' : t) {Hs : Ok s} {Hs' : Ok s'},  subset s s' = true <-> Subset s s'.
Lemma equal_spec :  forall (s s' : t) {Hs : Ok s} {Hs' : Ok s'},  equal s s' = true <-> Equal s s'.
Lemma cardinal_spec :  forall (s : t) {Hs : Ok s}, cardinal s = length (elements s).
Lemma filter_spec' : forall s x f,  In x (filter f s) -> In x s.
Lemma filter_spec :  forall (s : t) (x : elt) (f : elt -> bool),  Proper (X.eq==>eq) f ->
Lemma for_all_spec :  forall (s : t) (f : elt -> bool),  Proper (X.eq==>eq) f ->
Lemma exists_spec :  forall (s : t) (f : elt -> bool),  Proper (X.eq==>eq) f ->
Lemma partition_spec1 :  forall (s : t) (f : elt -> bool),  Proper (X.eq==>eq) f ->
Lemma partition_spec2 :  forall (s : t) (f : elt -> bool),  Proper (X.eq==>eq) f ->
Lemma partition_ok1' :  forall (s : t) {Hs : Ok s} (f : elt -> bool)(x:elt),   In x (fst (partition f s)) -> In x s.
Lemma partition_ok2' :  forall (s : t) {Hs : Ok s} (f : elt -> bool)(x:elt),   In x (snd (partition f s)) -> In x s.
Lemma leA_Tree_Leaf : forall a:A, leA_Tree a Tree_Leaf.
Lemma leA_Tree_Node :   forall (a b:A) (G D:Tree), leA a b -> leA_Tree a (Tree_Node b G D).
Lemma invert_heap :   forall (a:A) (T1 T2:Tree),     is_heap (Tree_Node a T1 T2) ->     leA_Tree a T1 /\ leA_Tree a T2 /\ is_heap T1 /\ is_heap T2.
Lemma is_heap_rect :   forall P:Tree -> Type,     P Tree_Leaf ->     (forall (a:A) (T1 T2:Tree), leA_Tree a T1 -> leA_Tree a T2 -> is_heap T1 -> P T1 -> is_heap T2 -> P T2 -> P (Tree_Node a T1 T2)) ->     forall T:Tree, is_heap T -> P T.
Lemma is_heap_rec :   forall P:Tree -> Set,     P Tree_Leaf ->     (forall (a:A) (T1 T2:Tree), leA_Tree a T1 -> leA_Tree a T2 -> is_heap T1 -> P T1 -> is_heap T2 -> P T2 -> P (Tree_Node a T1 T2)) ->     forall T:Tree, is_heap T -> P T.
Lemma low_trans :   forall (T:Tree) (a b:A), leA a b -> leA_Tree b T -> leA_Tree a T.
Lemma merge :   forall l1:list A, Sorted leA l1 ->   forall l2:list A, Sorted leA l2 -> merge_lem l1 l2.
Lemma insert : forall T:Tree, is_heap T -> forall a:A, insert_spec a T.
Lemma list_to_heap : forall l:list A, build_heap l.
Lemma heap_to_list : forall T:Tree, is_heap T -> flat_spec T.
Lemma eq_refl : forall x, x==x.
Lemma le_refl : forall x, x<=x.
Lemma lt_irrefl : forall x, ~ x<x.
Lemma eq_sym : forall x y, x==y -> y==x.
Lemma le_antisym : forall x y, x<=y -> y<=x -> x==y.
Lemma neq_sym : forall x y, ~x==y -> ~y==x.
Lemma trans : forall o o' x y z, #o x y -> #o' y z -> #(o+o') x z.
Lemma eq_neq : forall x y z, x==y -> ~y==z -> ~x==z.
Lemma neq_eq : forall x y z, ~x==y -> y==z -> ~x==z.
Lemma not_neq_eq : forall x y, ~~x==y -> x==y.
Lemma not_ge_lt : forall x y, ~y<=x -> x<y.
Lemma not_gt_le : forall x y, ~y<x -> x<=y.
Lemma le_neq_lt : forall x y, x<=y -> ~x==y -> x<y.
Lemma norm_ei_correct : forall e:ExprI, ez2z (norm_ei e) = i2z (ei2i e).
Lemma norm_ez_correct : forall e:ExprZ, ez2z (norm_ez e) = ez2z e.
Lemma norm_ep_correct :   forall e:ExprP, ep2p (norm_ep e) <-> ep2p e.
Lemma norm_ep_correct2 :   forall e:ExprP, ep2p (norm_ep e) -> ep2p e.
Lemma i2z_eq : forall n p, i2z n=i2z p -> n = p. Proof. auto. Qed.
Lemma i2z_0 : i2z _0 = 0.  Proof. auto. Qed.
Lemma i2z_1 : i2z _1 = 1.  Proof. auto. Qed.
Lemma i2z_2 : i2z _2 = 2.  Proof. auto. Qed.
Lemma i2z_3 : i2z _3 = 3.  Proof. auto. Qed.
Lemma i2z_plus n p : i2z (n + p) = i2z n + i2z p.  Proof. auto. Qed.
Lemma i2z_opp n : i2z (- n) = - i2z n.  Proof. auto. Qed.
Lemma i2z_minus n p : i2z (n - p) = i2z n - i2z p.  Proof. auto. Qed.
Lemma i2z_mult n p : i2z (n * p) = i2z n * i2z p.  Proof. auto. Qed.
Lemma i2z_max n p : i2z (max n p) = Z.max (i2z n) (i2z p). Proof. auto. Qed.
Lemma odd_pred : forall n, n~=0 -> odd (P n) = even n.
Lemma even_pred : forall n, n~=0 -> even (P n) = odd n.
Lemma even_sub : forall n m, m<=n -> even (n-m) = Bool.eqb (even n) (even m).
Lemma odd_sub : forall n m, m<=n -> odd (n-m) = xorb (odd n) (odd m).
Lemma Alt_PI_4 : Alt_PI <= 4.
Lemma pre_cos_bound : forall (a:R) (n:nat),   - 2 <= a -> a <= 2 ->   cos_approx a (2 * n + 1) <= cos a <= cos_approx a (2 * (n + 1)).
Lemma continuity_sin : continuity sin.
Lemma CVN_R_sin : forall fn:nat -> R -> R,   fn =   (fun (N:nat) (x:R) => (-1) ^ N / INR (fact (2 * N + 1)) * x ^ (2 * N)) ->   CVN_R fn.
Lemma derivable_pt_lim_sin_0 : derivable_pt_lim sin 0 1.
Lemma derivable_pt_lim_cos_0 : derivable_pt_lim cos 0 0.
Lemma derivable_pt_lim_cos : forall x:R, derivable_pt_lim cos x (- sin x).
Lemma derivable_pt_sin : forall x:R, derivable_pt sin x.
Lemma derivable_pt_cos : forall x:R, derivable_pt cos x.
Lemma derivable_sin : derivable sin.
Lemma derivable_cos : derivable cos.
Lemma derive_pt_sin : forall x:R, derive_pt sin x (derivable_pt_sin _) = cos x.
Lemma derive_pt_cos : forall x:R, derive_pt cos x (derivable_pt_cos _) = - sin x.
Lemma spec_Z_of_N : forall n, BigZ.to_Z (Z_of_N n) = BigN.to_Z n.
Lemma spec_Zabs_N : forall z, BigN.to_Z (Zabs_N z) = Z.abs (BigZ.to_Z z).
Lemma BigQfieldth : field_theory 0 1 BigQ.add BigQ.mul BigQ.sub BigQ.opp
Lemma BigQpowerth : power_theory 1 BigQ.mul BigQ.eq Z.of_N BigQ.power.
Lemma tech_up : forall (r:R) (z:Z), r < IZR z -> IZR z <= r + 1 -> z = up r.
Lemma up_tech : forall (r:R) (z:Z), IZR z <= r -> r < IZR (z + 1) -> (z + 1)%Z = up r.
Lemma fp_R0 : frac_part 0 = 0.
Lemma for_base_fp : forall r:R, IZR (up r) - r > 0 /\ IZR (up r) - r <= 1.
Lemma base_fp : forall r:R, frac_part r >= 0 /\ frac_part r < 1.
Lemma base_Int_part : forall r:R, IZR (Int_part r) <= r /\ IZR (Int_part r) - r > -1.
Lemma Int_part_INR : forall n:nat, Int_part (INR n) = Z.of_nat n.
Lemma fp_nat : forall r:R, frac_part r = 0 ->  exists c : Z, r = IZR c.
Lemma R0_fp_O : forall r:R, 0 <> frac_part r -> 0 <> r.
Lemma Rminus_Int_part1 : forall r1 r2:R,   frac_part r1 >= frac_part r2 ->   Int_part (r1 - r2) = (Int_part r1 - Int_part r2)%Z.
Lemma Rminus_Int_part2 : forall r1 r2:R,   frac_part r1 < frac_part r2 ->   Int_part (r1 - r2) = (Int_part r1 - Int_part r2 - 1)%Z.
Lemma Rminus_fp1 : forall r1 r2:R,   frac_part r1 >= frac_part r2 ->   frac_part (r1 - r2) = frac_part r1 - frac_part r2.
Lemma Rminus_fp2 : forall r1 r2:R,   frac_part r1 < frac_part r2 ->   frac_part (r1 - r2) = frac_part r1 - frac_part r2 + 1.
Lemma plus_Int_part1 : forall r1 r2:R,   frac_part r1 + frac_part r2 >= 1 ->   Int_part (r1 + r2) = (Int_part r1 + Int_part r2 + 1)%Z.
Lemma plus_Int_part2 : forall r1 r2:R,   frac_part r1 + frac_part r2 < 1 ->   Int_part (r1 + r2) = (Int_part r1 + Int_part r2)%Z.
Lemma plus_frac_part1 : forall r1 r2:R,   frac_part r1 + frac_part r2 >= 1 ->   frac_part (r1 + r2) = frac_part r1 + frac_part r2 - 1.
Lemma plus_frac_part2 : forall r1 r2:R,   frac_part r1 + frac_part r2 < 1 ->   frac_part (r1 + r2) = frac_part r1 + frac_part r2.
Lemma inf_iff : forall x l, Inf x l <-> inf x l = true.
Lemma isok_iff : forall l, sort X.lt l <-> Ok l.
Lemma mem_spec :  forall (s : t) (x : elt) (Hs : Ok s), mem x s = true <-> In x s.
Lemma add_inf :  forall (s : t) (x a : elt), Inf a s -> X.lt a x -> Inf a (add x s).
Lemma add_spec :  forall (s : t) (x y : elt) (Hs : Ok s),   In y (add x s) <-> X.eq y x \/ In y s.
Lemma remove_inf :  forall (s : t) (x a : elt) (Hs : Ok s), Inf a s -> Inf a (remove x s).
Lemma remove_spec :  forall (s : t) (x y : elt) (Hs : Ok s),   In y (remove x s) <-> In y s /\ ~X.eq y x.
Lemma singleton_spec : forall x y : elt, In y (singleton x) <-> X.eq y x.
Lemma union_inf :  forall (s s' : t) (a : elt) (Hs : Ok s) (Hs' : Ok s'),  Inf a s -> Inf a s' -> Inf a (union s s').
Lemma union_spec :  forall (s s' : t) (x : elt) (Hs : Ok s) (Hs' : Ok s'),  In x (union s s') <-> In x s \/ In x s'.
Lemma inter_inf :  forall (s s' : t) (a : elt) (Hs : Ok s) (Hs' : Ok s'),  Inf a s -> Inf a s' -> Inf a (inter s s').
Lemma inter_spec :  forall (s s' : t) (x : elt) (Hs : Ok s) (Hs' : Ok s'),  In x (inter s s') <-> In x s /\ In x s'.
Lemma diff_inf :  forall (s s' : t) (Hs : Ok s) (Hs' : Ok s') (a : elt),  Inf a s -> Inf a s' -> Inf a (diff s s').
Lemma diff_spec :  forall (s s' : t) (x : elt) (Hs : Ok s) (Hs' : Ok s'),  In x (diff s s') <-> In x s /\ ~In x s'.
Lemma equal_spec :  forall (s s' : t) (Hs : Ok s) (Hs' : Ok s'),  equal s s' = true <-> Equal s s'.
Lemma subset_spec :  forall (s s' : t) (Hs : Ok s) (Hs' : Ok s'),  subset s s' = true <-> Subset s s'.
Lemma empty_spec : Empty empty.
Lemma is_empty_spec : forall s : t, is_empty s = true <-> Empty s.
Lemma elements_spec1 : forall (s : t) (x : elt), In x (elements s) <-> In x s.
Lemma elements_spec2 : forall (s : t) (Hs : Ok s), sort X.lt (elements s).
Lemma elements_spec2w : forall (s : t) (Hs : Ok s), NoDupA X.eq (elements s).
Lemma min_elt_spec1 : forall (s : t) (x : elt), min_elt s = Some x -> In x s.
Lemma min_elt_spec2 :  forall (s : t) (x y : elt) (Hs : Ok s),  min_elt s = Some x -> In y s -> ~ X.lt y x.
Lemma min_elt_spec3 : forall s : t, min_elt s = None -> Empty s.
Lemma max_elt_spec1 : forall (s : t) (x : elt), max_elt s = Some x -> In x s.
Lemma max_elt_spec2 :  forall (s : t) (x y : elt) (Hs : Ok s),  max_elt s = Some x -> In y s -> ~ X.lt x y.
Lemma max_elt_spec3 : forall s : t, max_elt s = None -> Empty s.
Lemma choose_spec3: forall s s' x x', Ok s -> Ok s' ->  choose s = Some x -> choose s' = Some x' -> Equal s s' -> X.eq x x'.
Lemma fold_spec :  forall (s : t) (A : Type) (i : A) (f : elt -> A -> A),  fold f s i = fold_left (flip f) (elements s) i.
Lemma cardinal_spec :  forall (s : t) (Hs : Ok s),  cardinal s = length (elements s).
Lemma filter_inf :  forall (s : t) (x : elt) (f : elt -> bool) (Hs : Ok s),  Inf x s -> Inf x (filter f s).
Lemma filter_spec :  forall (s : t) (x : elt) (f : elt -> bool),  Proper (X.eq==>eq) f ->
Lemma for_all_spec :  forall (s : t) (f : elt -> bool),  Proper (X.eq==>eq) f ->
Lemma exists_spec :  forall (s : t) (f : elt -> bool),  Proper (X.eq==>eq) f ->
Lemma partition_inf1 :  forall (s : t) (f : elt -> bool) (x : elt) (Hs : Ok s),  Inf x s -> Inf x (fst (partition f s)).
Lemma partition_inf2 :  forall (s : t) (f : elt -> bool) (x : elt) (Hs : Ok s),  Inf x s -> Inf x (snd (partition f s)).
Lemma partition_spec1 :  forall (s : t) (f : elt -> bool),  Proper (X.eq==>eq) f -> Equal (fst (partition f s)) (filter f s).
Lemma partition_spec2 :  forall (s : t) (f : elt -> bool),  Proper (X.eq==>eq) f ->
Lemma compare_spec_aux : forall s s', CompSpec eq L.lt s s' (compare s s').
Lemma compare_spec : forall s s', Ok s -> Ok s' ->  CompSpec eq lt s s' (compare s s').
Lemma eq_leibniz_list : forall xs ys, eqlistA X.eq xs ys -> xs = ys.
Lemma eq_leibniz : forall s s', eq s s' -> s = s'.
Lemma Pshiftl_nat_Zpower : forall n p, Zpos (Pos.shiftl_nat p n) = Zpos p * 2 ^ Z.of_nat n.
Lemma base_xO: forall n, base (xO n) = (base n)^2.
Lemma spec_compare0_mn: forall n x,  compare0_mn n x = (0 ?= double_to_Z n x).
Lemma spec_compare_mn_1: forall n x y,  compare_mn_1 n x y = Z.compare (double_to_Z n x) (w_to_Z y).
Lemma Omega : forall i:U -> bool, induct i -> b2p (i WF).
Lemma lemma1 : induct (fun u => p2b (I u)).
Lemma lemma2 : (forall i:U -> bool, induct i -> b2p (i WF)) -> B.
Lemma Zgcdn_pos : forall n a b,  0 <= Zgcdn n a b.
Lemma Zgcd_alt_pos : forall a b, 0 <= Zgcd_alt a b.
Lemma Zgcdn_linear_bound : forall n a b,  Z.abs a < Z.of_nat n -> Zis_gcd a b (Zgcdn n a b).
Lemma fibonacci_pos : forall n, 0 <= fibonacci n.
Lemma fibonacci_incr :  forall n m, (n<=m)%nat -> fibonacci n <= fibonacci m.
Lemma Zgcdn_worst_is_fibonacci : forall n a b,  0 < a < b ->  Zis_gcd a b (Zgcdn (S n) a b) ->  Zgcdn n a b <> Zgcdn (S n) a b ->  fibonacci (S n) <= a /\  fibonacci (S (S n)) <= b.
Lemma Zgcdn_ok_before_fibonacci : forall n a b,  0 < a < b -> a < fibonacci (S n) ->  Zis_gcd a b (Zgcdn n a b).
Lemma Zgcd_bound_fibonacci :  forall a, 0 < a -> a < fibonacci (Zgcd_bound a).
Lemma Zgcd_bound_opp a : Zgcd_bound (-a) = Zgcd_bound a.
Lemma Zgcdn_opp n a b : Zgcdn n (-a) b = Zgcdn n a b.
Lemma Zgcdn_is_gcd_pos n a b : (Zgcd_bound (Zpos a) <= n)%nat ->  Zis_gcd (Zpos a) b (Zgcdn n (Zpos a) b).
Lemma Zgcdn_is_gcd n a b :  (Zgcd_bound a <= n)%nat -> Zis_gcd a b (Zgcdn n a b).
Lemma Zgcd_is_gcd :  forall a b, Zis_gcd a b (Zgcd_alt a b).
Lemma empty_1 : Empty empty.
Lemma empty_NoDup : NoDupA empty.
Lemma is_empty_1 :forall m, Empty m -> is_empty m = true.
Lemma is_empty_2 : forall m, is_empty m = true -> Empty m.
Lemma mem_1 : forall m (Hm:NoDupA m) x, In x m -> mem x m = true.
Lemma mem_2 : forall m (Hm:NoDupA m) x, mem x m = true -> In x m.
Lemma find_2 : forall m x e, find x m = Some e -> MapsTo x e m.
Lemma find_1 : forall m (Hm:NoDupA m) x e, MapsTo x e m -> find x m = Some e.
Lemma find_eq : forall m (Hm:NoDupA m) x x',  X.eq x x' -> find x m = find x' m.
Lemma add_1 : forall m x y e, X.eq x y -> MapsTo y e (add x e m).
Lemma add_2 : forall m x y e e', ~ X.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Lemma add_3 : forall m x y e e', ~ X.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Lemma add_3' : forall m x y e e', ~ X.eq x y -> InA eqk (y,e) (add x e' m) -> InA eqk (y,e) m.
Lemma add_NoDup : forall m (Hm:NoDupA m) x e, NoDupA (add x e m).
Lemma add_eq : forall m (Hm:NoDupA m) x a e,  X.eq x a -> find x (add a e m) = Some e.
Lemma add_not_eq : forall m (Hm:NoDupA m) x a e, ~X.eq x a -> find x (add a e m) = find x m.
Lemma remove_1 : forall m (Hm:NoDupA m) x y, X.eq x y -> ~ In y (remove x m).
Lemma remove_2 : forall m (Hm:NoDupA m) x y e, ~ X.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Lemma remove_3 : forall m (Hm:NoDupA m) x y e, MapsTo y e (remove x m) -> MapsTo y e m.
Lemma remove_3' : forall m (Hm:NoDupA m) x y e, InA eqk (y,e) (remove x m) -> InA eqk (y,e) m.
Lemma remove_NoDup : forall m (Hm:NoDupA m) x, NoDupA (remove x m).
Lemma elements_1 : forall m x e, MapsTo x e m -> InA eqke (x,e) (elements m).
Lemma elements_2 : forall m x e, InA eqke (x,e) (elements m) -> MapsTo x e m.
Lemma elements_3w : forall m (Hm:NoDupA m), NoDupA (elements m).
Lemma fold_1 : forall m (A:Type)(i:A)(f:key->elt->A->A), fold f m i = fold_left (fun a p => f (fst p) (snd p) a) (elements m) i.
Lemma submap_1 : forall m (Hm:NoDupA m) m' (Hm': NoDupA m') cmp, Submap cmp m m' -> submap cmp m m' = true.
Lemma submap_2 : forall m (Hm:NoDupA m) m' (Hm': NoDupA m') cmp, submap cmp m m' = true -> Submap cmp m m'.
Lemma equal_1 : forall m (Hm:NoDupA m) m' (Hm': NoDupA m') cmp, Equivb cmp m m' -> equal cmp m m' = true.
Lemma equal_2 : forall m (Hm:NoDupA m) m' (Hm':NoDupA m') cmp, equal cmp m m' = true -> Equivb cmp m m'.
Lemma map_1 : forall (m:t elt)(x:key)(e:elt)(f:elt->elt'), MapsTo x e m -> MapsTo x (f e) (map f m).
Lemma map_2 : forall (m:t elt)(x:key)(f:elt->elt'), In x (map f m) -> In x m.
Lemma map_NoDup : forall m (Hm : NoDupA (@eqk elt) m)(f:elt->elt'), NoDupA (@eqk elt') (map f m).
Lemma mapi_1 : forall (m:t elt)(x:key)(e:elt)(f:key->elt->elt'), MapsTo x e m -> exists y, X.eq y x /\ MapsTo x (f y e) (mapi f m).
Lemma mapi_2 : forall (m:t elt)(x:key)(f:key->elt->elt'), In x (mapi f m) -> In x m.
Lemma mapi_NoDup : forall m (Hm : NoDupA (@eqk elt) m)(f: key->elt->elt'), NoDupA (@eqk elt') (mapi f m).
Lemma fold_right_pair_NoDup : forall l r (Hl: NoDupA (eqk (elt:=oee')) l)   (Hl: NoDupA (eqk (elt:=oee')) r),   NoDupA (eqk (elt:=oee')) (fold_right_pair (add (elt:=oee')) l r).
Lemma combine_NoDup : forall m (Hm:NoDupA (@eqk elt) m) m' (Hm':NoDupA (@eqk elt') m'), NoDupA (@eqk oee') (combine m m').
Lemma combine_l_1 : forall m (Hm:NoDupA (@eqk elt) m) m' (Hm':NoDupA (@eqk elt') m')(x:key), find x (combine_l m m') = at_least_left (find x m) (find x m').
Lemma combine_r_1 : forall m (Hm:NoDupA (@eqk elt) m) m' (Hm':NoDupA (@eqk elt') m')(x:key), find x (combine_r m m') = at_least_right (find x m) (find x m').
Lemma combine_1 : forall m (Hm:NoDupA (@eqk elt) m) m' (Hm':NoDupA (@eqk elt') m')(x:key), find x (combine m m') = at_least_one (find x m) (find x m').
Lemma map2_NoDup : forall m (Hm:NoDupA (@eqk elt) m) m' (Hm':NoDupA (@eqk elt') m'), NoDupA (@eqk elt'') (map2 m m').
Lemma map2_0 : forall m (Hm:NoDupA (@eqk elt) m) m' (Hm':NoDupA (@eqk elt') m')(x:key), find x (map2 m m') = at_least_one_then_f (find x m) (find x m').
Lemma map2_1 : forall m (Hm:NoDupA (@eqk elt) m) m' (Hm':NoDupA (@eqk elt') m')(x:key), In x m \/ In x m' -> find x (map2 m m') = f (find x m) (find x m').
Lemma map2_2 : forall m (Hm:NoDupA (@eqk elt) m) m' (Hm':NoDupA (@eqk elt') m')(x:key), In x (map2 m m') -> In x m \/ In x m'.
Lemma MapsTo_1 : forall m x y e, E.eq x y -> MapsTo x e m -> MapsTo y e m.
Lemma mem_1 : forall m x, In x m -> mem x m = true.
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Lemma empty_1 : Empty empty.
Lemma is_empty_1 : forall m, Empty m -> is_empty m = true.
Lemma is_empty_2 :  forall m, is_empty m = true -> Empty m.
Lemma add_1 : forall m x y e, E.eq x y -> MapsTo y e (add x e m).
Lemma add_2 : forall m x y e e', ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Lemma add_3 : forall m x y e e', ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Lemma remove_1 : forall m x y, E.eq x y -> ~ In y (remove x m).
Lemma remove_2 : forall m x y e, ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Lemma remove_3 : forall m x y e, MapsTo y e (remove x m) -> MapsTo y e m.
Lemma find_1 : forall m x e, MapsTo x e m -> find x m = Some e.
Lemma find_2 : forall m x e, find x m = Some e -> MapsTo x e m.
Lemma elements_1 : forall m x e, MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Lemma elements_2 : forall m x e, InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Lemma elements_3w : forall m, NoDupA eq_key (elements m).
Lemma cardinal_1 : forall m, cardinal m = length (elements m).
Lemma fold_1 : forall m (A : Type) (i : A) (f : key -> elt -> A -> A),       fold f m i = fold_left (fun a p => f (fst p) (snd p) a) (elements m) i.
Lemma equal_1 : forall m m' cmp, Equivb cmp m m' -> equal cmp m m' = true.
Lemma equal_2 : forall m m' cmp, equal cmp m m' = true -> Equivb cmp m m'.
Lemma map_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)(f:elt->elt'),       MapsTo x e m -> MapsTo x (f e) (map f m).
Lemma map_2 : forall (elt elt':Type)(m: t elt)(x:key)(f:elt->elt'),       In x (map f m) -> In x m.
Lemma mapi_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)       (f:key->elt->elt'), MapsTo x e m ->       exists y, E.eq y x /\ MapsTo x (f y e) (mapi f m).
Lemma mapi_2 : forall (elt elt':Type)(m: t elt)(x:key)       (f:key->elt->elt'), In x (mapi f m) -> In x m.
Lemma map2_1 : forall (elt elt' elt'':Type)(m: t elt)(m': t elt') (x:key)(f:option elt->option elt'->option elt''), In x m \/ In x m' ->       find x (map2 f m m') = f (find x m) (find x m').
Lemma map2_2 : forall (elt elt' elt'':Type)(m: t elt)(m': t elt') (x:key)(f:option elt->option elt'->option elt''),       In x (map2 f m m') -> In x m \/ In x m'.
Lemma divide_1_l : forall n, (1 | n).
Lemma divide_0_r : forall n, (n | 0).
Lemma divide_0_l : forall n, (0 | n) -> n==0.
Lemma eq_mul_1_nonneg : forall n m, 0<=n -> n*m == 1 -> n==1 /\ m==1.
Lemma eq_mul_1_nonneg' : forall n m, 0<=m -> n*m == 1 -> n==1 /\ m==1.
Lemma divide_1_r_nonneg : forall n, 0<=n -> (n | 1) -> n==1.
Lemma divide_refl : forall n, (n | n).
Lemma divide_trans : forall n m p, (n | m) -> (m | p) -> (n | p).
Lemma divide_antisym_nonneg : forall n m, 0<=n -> 0<=m -> (n | m) -> (m | n) -> n == m.
Lemma mul_divide_mono_l : forall n m p, (n | m) -> (p * n | p * m).
Lemma mul_divide_mono_r : forall n m p, (n | m) -> (n * p | m * p).
Lemma mul_divide_cancel_l : forall n m p, p ~= 0 -> ((p * n | p * m) <-> (n | m)).
Lemma mul_divide_cancel_r : forall n m p, p ~= 0 -> ((n * p | m * p) <-> (n | m)).
Lemma divide_add_r : forall n m p, (n | m) -> (n | p) -> (n | m + p).
Lemma divide_mul_l : forall n m p, (n | m) -> (n | m * p).
Lemma divide_mul_r : forall n m p, (n | p) -> (n | m * p).
Lemma divide_factor_l : forall n m, (n | n * m).
Lemma divide_factor_r : forall n m, (n | m * n).
Lemma divide_pos_le : forall n m, 0 < m -> (n | m) -> n <= m.
Lemma gcd_unique : forall n m p, 0<=p -> (p|n) -> (p|m) -> (forall q, (q|n) -> (q|m) -> (q|p)) -> gcd n m == p.
Lemma gcd_divide_iff : forall n m p, (p | gcd n m) <-> (p | n) /\ (p | m).
Lemma gcd_unique_alt : forall n m p, 0<=p -> (forall q, (q|p) <-> (q|n) /\ (q|m)) -> gcd n m == p.
Lemma gcd_comm : forall n m, gcd n m == gcd m n.
Lemma gcd_assoc : forall n m p, gcd n (gcd m p) == gcd (gcd n m) p.
Lemma gcd_0_l_nonneg : forall n, 0<=n -> gcd 0 n == n.
Lemma gcd_0_r_nonneg : forall n, 0<=n -> gcd n 0 == n.
Lemma gcd_1_l : forall n, gcd 1 n == 1.
Lemma gcd_1_r : forall n, gcd n 1 == 1.
Lemma gcd_diag_nonneg : forall n, 0<=n -> gcd n n == n.
Lemma gcd_eq_0_l : forall n m, gcd n m == 0 -> n == 0.
Lemma gcd_eq_0_r : forall n m, gcd n m == 0 -> m == 0.
Lemma gcd_eq_0 : forall n m, gcd n m == 0 <-> n == 0 /\ m == 0.
Lemma gcd_mul_diag_l : forall n m, 0<=n -> gcd n (n*m) == n.
Lemma divide_gcd_iff : forall n m, 0<=n -> ((n|m) <-> gcd n m == n).
Lemma div_same : forall a, 0<a -> a/a == 1.
Lemma mod_same : forall a, 0<a -> a mod a == 0.
Lemma div_0_l: forall a, 0<a -> 0/a == 0.
Lemma mod_0_l: forall a, 0<a -> 0 mod a == 0.
Lemma div_1_r: forall a, 0<=a -> a/1 == a.
Lemma mod_1_r: forall a, 0<=a -> a mod 1 == 0.
Lemma div_1_l: forall a, 1<a -> 1/a == 0.
Lemma mod_1_l: forall a, 1<a -> 1 mod a == 1.
Lemma div_mul : forall a b, 0<=a -> 0<b -> (a*b)/b == a.
Lemma mod_mul : forall a b, 0<=a -> 0<b -> (a*b) mod b == 0.
Lemma div_pos: forall a b, 0<=a -> 0<b -> 0 <= a/b.
Lemma div_str_pos : forall a b, 0<b<=a -> 0 < a/b.
Lemma div_small_iff : forall a b, 0<=a -> 0<b -> (a/b==0 <-> a<b).
Lemma mod_small_iff : forall a b, 0<=a -> 0<b -> (a mod b == a <-> a<b).
Lemma div_str_pos_iff : forall a b, 0<=a -> 0<b -> (0<a/b <-> b<=a).
Lemma div_lt : forall a b, 0<a -> 1<b -> a/b < a.
Lemma div_le_mono : forall a b c, 0<c -> 0<=a<=b -> a/c <= b/c.
Lemma mul_div_le : forall a b, 0<=a -> 0<b -> b*(a/b) <= a.
Lemma mul_succ_div_gt : forall a b, 0<=a -> 0<b -> a < b*(S (a/b)).
Lemma div_exact : forall a b, 0<=a -> 0<b -> (a == b*(a/b) <-> a mod b == 0).
Lemma div_le_compat_l: forall p q r, 0<=p -> 0<q<=r ->   p/r <= p/q.
Lemma mod_add : forall a b c, 0<=a -> 0<=a+b*c -> 0<c -> (a + b * c) mod c == a mod c.
Lemma div_add : forall a b c, 0<=a -> 0<=a+b*c -> 0<c -> (a + b * c) / c == a / c + b.
Lemma div_add_l: forall a b c, 0<=c -> 0<=a*b+c -> 0<b -> (a * b + c) / b == a + c / b.
Lemma div_mul_cancel_r : forall a b c, 0<=a -> 0<b -> 0<c -> (a*c)/(b*c) == a/b.
Lemma div_mul_cancel_l : forall a b c, 0<=a -> 0<b -> 0<c -> (c*a)/(c*b) == a/b.
Lemma mul_mod_distr_l: forall a b c, 0<=a -> 0<b -> 0<c -> (c*a) mod (c*b) == c * (a mod b).
Lemma mul_mod_distr_r: forall a b c, 0<=a -> 0<b -> 0<c -> (a*c) mod (b*c) == (a mod b) * c.
Lemma mul_mod_idemp_l : forall a b n, 0<=a -> 0<=b -> 0<n -> ((a mod n)*b) mod n == (a*b) mod n.
Lemma mul_mod_idemp_r : forall a b n, 0<=a -> 0<=b -> 0<n -> (a*(b mod n)) mod n == (a*b) mod n.
Lemma add_mod_idemp_l : forall a b n, 0<=a -> 0<=b -> 0<n -> ((a mod n)+b) mod n == (a+b) mod n.
Lemma add_mod_idemp_r : forall a b n, 0<=a -> 0<=b -> 0<n -> (a+(b mod n)) mod n == (a+b) mod n.
Lemma div_div : forall a b c, 0<=a -> 0<b -> 0<c -> (a/b)/c == a/(b*c).
Lemma mod_mul_r : forall a b c, 0<=a -> 0<b -> 0<c -> a mod (b*c) == a mod b + b*((a/b) mod c).
Lemma mod_divides : forall a b, 0<=a -> 0<b -> (a mod b == 0 <-> exists c, a == b*c).
Lemma Nplength_infty : forall a:N, Nplength a = infty -> a = N0.
Lemma Nplength_zeros : forall (a:N) (n:nat),  Nplength a = ni n -> forall k:nat, k < n -> N.testbit_nat a k = false.
Lemma Nplength_one : forall (a:N) (n:nat), Nplength a = ni n -> N.testbit_nat a n = true.
Lemma Nplength_first_one : forall (a:N) (n:nat),  (forall k:nat, k < n -> N.testbit_nat a k = false) ->
Lemma ni_min_idemp : forall d:natinf, ni_min d d = d.
Lemma ni_min_comm : forall d d':natinf, ni_min d d' = ni_min d' d.
Lemma ni_min_assoc : forall d d' d'':natinf, ni_min (ni_min d d') d'' = ni_min d (ni_min d' d'').
Lemma ni_min_O_l : forall d:natinf, ni_min (ni 0) d = ni 0.
Lemma ni_min_O_r : forall d:natinf, ni_min d (ni 0) = ni 0.
Lemma ni_min_inf_l : forall d:natinf, ni_min infty d = d.
Lemma ni_min_inf_r : forall d:natinf, ni_min d infty = d.
Lemma ni_le_refl : forall d:natinf, ni_le d d.
Lemma ni_le_antisym : forall d d':natinf, ni_le d d' -> ni_le d' d -> d = d'.
Lemma ni_le_trans : forall d d' d'':natinf, ni_le d d' -> ni_le d' d'' -> ni_le d d''.
Lemma ni_le_min_1 : forall d d':natinf, ni_le (ni_min d d') d.
Lemma ni_le_min_2 : forall d d':natinf, ni_le (ni_min d d') d'.
Lemma ni_min_case : forall d d':natinf, ni_min d d' = d \/ ni_min d d' = d'.
Lemma ni_le_total : forall d d':natinf, ni_le d d' \/ ni_le d' d.
Lemma ni_le_min_induc : forall d d' dm:natinf,  ni_le dm d ->  ni_le dm d' ->  (forall d'':natinf, ni_le d'' d -> ni_le d'' d' -> ni_le d'' dm) ->  ni_min d d' = dm.
Lemma le_ni_le : forall m n:nat, m <= n -> ni_le (ni m) (ni n).
Lemma ni_le_le : forall m n:nat, ni_le (ni m) (ni n) -> m <= n.
Lemma Nplength_lb : forall (a:N) (n:nat),  (forall k:nat, k < n -> N.testbit_nat a k = false) -> ni_le (ni n) (Nplength a).
Lemma Nplength_ub : forall (a:N) (n:nat), N.testbit_nat a n = true -> ni_le (Nplength a) (ni n).
Lemma Npdist_eq_1 : forall a:N, Npdist a a = infty.
Lemma Npdist_eq_2 : forall a a':N, Npdist a a' = infty -> a = a'.
Lemma Npdist_comm : forall a a':N, Npdist a a' = Npdist a' a.
Lemma Nplength_ultra_1 : forall a a':N,  ni_le (Nplength a) (Nplength a') ->  ni_le (Nplength a) (Nplength (N.lxor a a')).
Lemma Nplength_ultra : forall a a':N,  ni_le (ni_min (Nplength a) (Nplength a')) (Nplength (N.lxor a a')).
Lemma Npdist_ultra : forall a a' a'':N,  ni_le (ni_min (Npdist a a'') (Npdist a'' a')) (Npdist a a').
Lemma or_not_l_iff_1 : forall A B: Prop, decidable A -> ((A -> False) \/ B <-> (A -> B)).
Lemma or_not_l_iff_2 : forall A B: Prop, decidable B -> ((A -> False) \/ B <-> (A -> B)).
Lemma or_not_r_iff_1 : forall A B: Prop, decidable A -> (A \/ (B -> False) <-> (B -> A)).
Lemma or_not_r_iff_2 : forall A B: Prop, decidable B -> (A \/ (B -> False) <-> (B -> A)).
Lemma imp_not_l : forall A B: Prop, decidable A -> (((A -> False) -> B) <-> (A \/ B)).
Lemma not_and_iff : forall A B:Prop, (A /\ B -> False) <-> (A -> B -> False).
Lemma not_imp_iff : forall A B:Prop, decidable A -> (((A -> B) -> False) <-> A /\ (B -> False)).
Lemma not_imp_rev_iff : forall A B : Prop, decidable A -> (((A -> B) -> False) <-> (B -> False) /\ A).
Lemma derivable_pt_inv : forall (f:R -> R) (x:R),   f x <> 0 -> derivable_pt f x -> derivable_pt (/ f) x.
Lemma pr_nu_var : forall (f g:R -> R) (x:R) (pr1:derivable_pt f x) (pr2:derivable_pt g x),   f = g -> derive_pt f x pr1 = derive_pt g x pr2.
Lemma pr_nu_var2 : forall (f g:R -> R) (x:R) (pr1:derivable_pt f x) (pr2:derivable_pt g x),   (forall h:R, f h = g h) -> derive_pt f x pr1 = derive_pt g x pr2.
Lemma derivable_inv : forall f:R -> R, (forall x:R, f x <> 0) -> derivable f -> derivable (/ f).
Lemma derive_pt_inv : forall (f:R -> R) (x:R) (pr:derivable_pt f x) (na:f x <> 0),   derive_pt (/ f) x (derivable_pt_inv f x na pr) =   - derive_pt f x pr / Rsqr (f x).
Lemma Rabs_derive_1 : forall x:R, 0 < x -> derivable_pt_lim Rabs x 1.
Lemma Rabs_derive_2 : forall x:R, x < 0 -> derivable_pt_lim Rabs x (-1).
Lemma Rderivable_pt_abs : forall x:R, x <> 0 -> derivable_pt Rabs x.
Lemma Rcontinuity_abs : continuity Rabs.
Lemma continuity_finite_sum : forall (An:nat -> R) (N:nat),   continuity (fun y:R => sum_f_R0 (fun k:nat => An k * y ^ k) N).
Lemma derivable_pt_lim_fs : forall (An:nat -> R) (x:R) (N:nat),   (0 < N)%nat ->   derivable_pt_lim (fun y:R => sum_f_R0 (fun k:nat => An k * y ^ k) N) x   (sum_f_R0 (fun k:nat => INR (S k) * An (S k) * x ^ k) (pred N)).
Lemma derivable_pt_lim_finite_sum : forall (An:nat -> R) (x:R) (N:nat),   derivable_pt_lim (fun y:R => sum_f_R0 (fun k:nat => An k * y ^ k) N) x   match N with     | O => 0     | _ => sum_f_R0 (fun k:nat => INR (S k) * An (S k) * x ^ k) (pred N)   end.
Lemma derivable_pt_finite_sum : forall (An:nat -> R) (N:nat) (x:R),   derivable_pt (fun y:R => sum_f_R0 (fun k:nat => An k * y ^ k) N) x.
Lemma derivable_finite_sum : forall (An:nat -> R) (N:nat),   derivable (fun y:R => sum_f_R0 (fun k:nat => An k * y ^ k) N).
Lemma derivable_pt_lim_cosh : forall x:R, derivable_pt_lim cosh x (sinh x).
Lemma derivable_pt_lim_sinh : forall x:R, derivable_pt_lim sinh x (cosh x).
Lemma derivable_pt_exp : forall x:R, derivable_pt exp x.
Lemma derivable_pt_cosh : forall x:R, derivable_pt cosh x.
Lemma derivable_pt_sinh : forall x:R, derivable_pt sinh x.
Lemma derivable_exp : derivable exp.
Lemma derivable_cosh : derivable cosh.
Lemma derivable_sinh : derivable sinh.
Lemma derive_pt_exp : forall x:R, derive_pt exp x (derivable_pt_exp x) = exp x.
Lemma derive_pt_cosh : forall x:R, derive_pt cosh x (derivable_pt_cosh x) = sinh x.
Lemma derive_pt_sinh : forall x:R, derive_pt sinh x (derivable_pt_sinh x) = cosh x.
Lemma MVT_cor1 : forall (f:R -> R) (a b:R) (pr:derivable f),   a < b ->   exists c : R, f b - f a = derive_pt f c (pr c) * (b - a) /\ a < c < b.
Lemma MVT_cor3 : forall (f f':R -> R) (a b:R),   a < b ->   (forall x:R, a <= x -> x <= b -> derivable_pt_lim f x (f' x)) ->   exists c : R, a <= c /\ c <= b /\ f b = f a + f' c * (b - a).
Lemma Rolle : forall (f:R -> R) (a b:R) (pr:forall x:R, a < x < b -> derivable_pt f x),   (forall x:R, a <= x <= b -> continuity_pt f x) ->   a < b ->   f a = f b ->   exists c : R, (exists P : a < c < b, derive_pt f c (pr c P) = 0).
Lemma nonneg_derivative_1 : forall (f:R -> R) (pr:derivable f),   (forall x:R, 0 <= derive_pt f x (pr x)) -> increasing f.
Lemma nonpos_derivative_0 : forall (f:R -> R) (pr:derivable f),   decreasing f -> forall x:R, derive_pt f x (pr x) <= 0.
Lemma increasing_decreasing_opp : forall f:R -> R, increasing f -> decreasing (- f)%F.
Lemma nonpos_derivative_1 : forall (f:R -> R) (pr:derivable f),   (forall x:R, derive_pt f x (pr x) <= 0) -> decreasing f.
Lemma positive_derivative : forall (f:R -> R) (pr:derivable f),   (forall x:R, 0 < derive_pt f x (pr x)) -> strict_increasing f.
Lemma strictincreasing_strictdecreasing_opp : forall f:R -> R, strict_increasing f -> strict_decreasing (- f)%F.
Lemma negative_derivative : forall (f:R -> R) (pr:derivable f),   (forall x:R, derive_pt f x (pr x) < 0) -> strict_decreasing f.
Lemma null_derivative_0 : forall (f:R -> R) (pr:derivable f),   constant f -> forall x:R, derive_pt f x (pr x) = 0.
Lemma increasing_decreasing : forall f:R -> R, increasing f -> decreasing f -> constant f.
Lemma null_derivative_1 : forall (f:R -> R) (pr:derivable f),   (forall x:R, derive_pt f x (pr x) = 0) -> constant f.
Lemma derive_increasing_interv_ax : forall (a b:R) (f:R -> R) (pr:derivable f),   a < b ->   ((forall t:R, a < t < b -> 0 < derive_pt f t (pr t)) ->     forall x y:R, a <= x <= b -> a <= y <= b -> x < y -> f x < f y) /\   ((forall t:R, a < t < b -> 0 <= derive_pt f t (pr t)) ->     forall x y:R, a <= x <= b -> a <= y <= b -> x < y -> f x <= f y).
Lemma derive_increasing_interv : forall (a b:R) (f:R -> R) (pr:derivable f),   a < b ->   (forall t:R, a < t < b -> 0 < derive_pt f t (pr t)) ->   forall x y:R, a <= x <= b -> a <= y <= b -> x < y -> f x < f y.
Lemma derive_increasing_interv_var : forall (a b:R) (f:R -> R) (pr:derivable f),   a < b ->   (forall t:R, a < t < b -> 0 <= derive_pt f t (pr t)) ->   forall x y:R, a <= x <= b -> a <= y <= b -> x < y -> f x <= f y.
Lemma IAF_var : forall (f g:R -> R) (a b:R) (pr1:derivable f) (pr2:derivable g),   a <= b ->   (forall c:R, a <= c <= b -> derive_pt g c (pr2 c) <= derive_pt f c (pr1 c)) ->   g b - g a <= f b - f a.
Lemma null_derivative_loc : forall (f:R -> R) (a b:R) (pr:forall x:R, a < x < b -> derivable_pt f x),   (forall x:R, a <= x <= b -> continuity_pt f x) ->   (forall (x:R) (P:a < x < b), derive_pt f x (pr x P) = 0) ->   constant_D_eq f (fun x:R => a <= x <= b) (f a).
Lemma antiderivative_Ucte : forall (f g1 g2:R -> R) (a b:R),   antiderivative f g1 a b ->   antiderivative f g2 a b ->   exists c : R, (forall x:R, a <= x <= b -> g1 x = g2 x + c).
Lemma ind_0_1_SS : forall P:nat -> Prop,   P 0 -> P 1 -> (forall n, P n -> P (S (S n))) -> forall n, P n.
Lemma lt_div2 : forall n, 0 < n -> div2 n < n.
Lemma even_div2 : forall n, even n -> div2 n = div2 (S n) with odd_div2 : forall n, odd n -> S (div2 n) = div2 (S n).
Lemma div2_even n : div2 n = div2 (S n) -> even n with div2_odd n : S (div2 n) = div2 (S n) -> odd n.
Lemma even_odd_div2 n : (even n <-> div2 n = div2 (S n)) /\ (odd n <-> S (div2 n) = div2 (S n)).
Lemma double_S : forall n, double (S n) = S (S (double n)).
Lemma double_plus : forall n (m:nat), double (n + m) = double n + double m.
Lemma even_odd_double : forall n,   (even n <-> n = double (div2 n)) /\ (odd n <-> n = S (double (div2 n))).
Lemma even_double : forall n, even n -> n = double (div2 n).
Lemma double_even : forall n, n = double (div2 n) -> even n.
Lemma odd_double : forall n, odd n -> n = S (double (div2 n)).
Lemma double_odd : forall n, n = S (double (div2 n)) -> odd n.
Lemma even_2n : forall n, even n -> {p : nat | n = double p}.
Lemma odd_S2n : forall n, odd n -> {p : nat | n = S (double p)}.
Lemma div2_double : forall n:nat, div2 (2*n) = n.
Lemma div2_double_plus_one : forall n:nat, div2 (S (2*n)) = n.
Lemma Z_of_nat_complete (x : Z) : 0 <= x -> exists n : nat, x = Z.of_nat n.
Lemma Z_of_nat_complete_inf (x : Z) : 0 <= x -> {n : nat | x = Z.of_nat n}.
Lemma Z_of_nat_prop : forall P:Z -> Prop,   (forall n:nat, P (Z.of_nat n)) -> forall x:Z, 0 <= x -> P x.
Lemma Z_of_nat_set : forall P:Z -> Set,  (forall n:nat, P (Z.of_nat n)) -> forall x:Z, 0 <= x -> P x.
Lemma natlike_ind : forall P:Z -> Prop,  P 0 ->  (forall x:Z, 0 <= x -> P x -> P (Z.succ x)) ->
Lemma natlike_rec : forall P:Z -> Set,  P 0 ->  (forall x:Z, 0 <= x -> P x -> P (Z.succ x)) ->
Lemma natlike_rec2 :   forall P:Z -> Type,     P 0 ->     (forall z:Z, 0 <= z -> P z -> P (Z.succ z)) ->
Lemma natlike_rec3 :   forall P:Z -> Type,     P 0 ->     (forall z:Z, 0 < z -> P (Z.pred z) -> P z) ->
Lemma Zlt_0_rec :   forall P:Z -> Type,     (forall x:Z, (forall y:Z, 0 <= y < x -> P y) -> 0 <= x -> P x) ->     forall x:Z, 0 <= x -> P x.
Lemma Zlt_0_ind :   forall P:Z -> Prop,     (forall x:Z, (forall y:Z, 0 <= y < x -> P y) -> 0 <= x -> P x) ->     forall x:Z, 0 <= x -> P x.
Lemma Z_lt_rec :   forall P:Z -> Type,     (forall x:Z, (forall y:Z, 0 <= y < x -> P y) -> P x) ->     forall x:Z, 0 <= x -> P x.
Lemma Z_lt_induction :   forall P:Z -> Prop,     (forall x:Z, (forall y:Z, 0 <= y < x -> P y) -> P x) ->     forall x:Z, 0 <= x -> P x.
Lemma Zlt_lower_bound_rec :   forall P:Z -> Type, forall z:Z,     (forall x:Z, (forall y:Z, z <= y < x -> P y) -> z <= x -> P x) ->     forall x:Z, z <= x -> P x.
Lemma Zlt_lower_bound_ind :   forall P:Z -> Prop, forall z:Z,     (forall x:Z, (forall y:Z, z <= y < x -> P y) -> z <= x -> P x) ->     forall x:Z, z <= x -> P x.
Lemma HdRel_inv : forall a b l, HdRel a (b :: l) -> R a b.
Lemma Sorted_inv :   forall a l, Sorted (a :: l) -> Sorted l /\ HdRel a l.
Lemma Sorted_rect :   forall P:list A -> Type,     P [] ->     (forall a l, Sorted l -> P l -> HdRel a l -> P (a :: l)) ->     forall l:list A, Sorted l -> P l.
Lemma Sorted_LocallySorted_iff : forall l, Sorted l <-> LocallySorted l.
Lemma StronglySorted_inv : forall a l, StronglySorted (a :: l) ->   StronglySorted l /\ Forall (R a) l.
Lemma StronglySorted_rect :   forall P:list A -> Type,     P [] ->     (forall a l, StronglySorted l -> P l -> Forall (R a) l -> P (a :: l)) ->     forall l, StronglySorted l -> P l.
Lemma StronglySorted_rec :   forall P:list A -> Type,     P [] ->     (forall a l, StronglySorted l -> P l -> Forall (R a) l -> P (a :: l)) ->     forall l, StronglySorted l -> P l.
Lemma StronglySorted_Sorted : forall l, StronglySorted l -> Sorted l.
Lemma Sorted_extends :   Transitive R -> forall a l, Sorted (a::l) -> Forall (R a) l.
Lemma Sorted_StronglySorted :   Transitive R -> forall l, Sorted l -> StronglySorted l.
Lemma In_dec : forall x s, {In x s} + {~ In x s}.
Lemma Add_Equal : forall x s s', Add x s s' <-> s' [=] add x s.
Lemma equal_refl : s[=]s.
Lemma equal_sym : s[=]s' -> s'[=]s.
Lemma equal_trans : s1[=]s2 -> s2[=]s3 -> s1[=]s3.
Lemma subset_refl : s[<=]s.
Lemma subset_trans : s1[<=]s2 -> s2[<=]s3 -> s1[<=]s3.
Lemma subset_antisym : s[<=]s' -> s'[<=]s -> s[=]s'.
Lemma subset_equal : s[=]s' -> s[<=]s'.
Lemma subset_empty : empty[<=]s.
Lemma subset_remove_3 : s1[<=]s2 -> remove x s1 [<=] s2.
Lemma subset_diff : s1[<=]s3 -> diff s1 s2 [<=] s3.
Lemma subset_add_3 : In x s2 -> s1[<=]s2 -> add x s1 [<=] s2.
Lemma subset_add_2 : s1[<=]s2 -> s1[<=] add x s2.
Lemma in_subset : In x s1 -> s1[<=]s2 -> In x s2.
Lemma double_inclusion : s1[=]s2 <-> s1[<=]s2 /\ s2[<=]s1.
Lemma empty_is_empty_1 : Empty s -> s[=]empty.
Lemma empty_is_empty_2 : s[=]empty -> Empty s.
Lemma add_equal : In x s -> add x s [=] s.
Lemma add_add : add x (add x' s) [=] add x' (add x s).
Lemma remove_equal : ~ In x s -> remove x s [=] s.
Lemma Equal_remove : s[=]s' -> remove x s [=] remove x s'.
Lemma add_remove : In x s -> add x (remove x s) [=] s.
Lemma remove_add : ~In x s -> remove x (add x s) [=] s.
Lemma singleton_equal_add : singleton x [=] add x empty.
Lemma remove_singleton_empty :  In x s -> remove x s [=] empty -> singleton x [=] s.
Lemma union_sym : union s s' [=] union s' s.
Lemma union_subset_equal : s[<=]s' -> union s s' [=] s'.
Lemma union_equal_1 : s[=]s' -> union s s'' [=] union s' s''.
Lemma union_equal_2 : s'[=]s'' -> union s s' [=] union s s''.
Lemma union_assoc : union (union s s') s'' [=] union s (union s' s'').
Lemma add_union_singleton : add x s [=] union (singleton x) s.
Lemma union_add : union (add x s) s' [=] add x (union s s').
Lemma union_remove_add_1 :  union (remove x s) (add x s') [=] union (add x s) (remove x s').
Lemma union_remove_add_2 : In x s ->  union (remove x s) (add x s') [=] union s s'.
Lemma union_subset_1 : s [<=] union s s'.
Lemma union_subset_2 : s' [<=] union s s'.
Lemma union_subset_3 : s[<=]s'' -> s'[<=]s'' -> union s s' [<=] s''.
Lemma union_subset_4 : s[<=]s' -> union s s'' [<=] union s' s''.
Lemma union_subset_5 : s[<=]s' -> union s'' s [<=] union s'' s'.
Lemma empty_union_1 : Empty s -> union s s' [=] s'.
Lemma empty_union_2 : Empty s -> union s' s [=] s'.
Lemma not_in_union : ~In x s -> ~In x s' -> ~In x (union s s').
Lemma inter_sym : inter s s' [=] inter s' s.
Lemma inter_subset_equal : s[<=]s' -> inter s s' [=] s.
Lemma inter_equal_1 : s[=]s' -> inter s s'' [=] inter s' s''.
Lemma inter_equal_2 : s'[=]s'' -> inter s s' [=] inter s s''.
Lemma inter_assoc : inter (inter s s') s'' [=] inter s (inter s' s'').
Lemma union_inter_1 : inter (union s s') s'' [=] union (inter s s'') (inter s' s'').
Lemma union_inter_2 : union (inter s s') s'' [=] inter (union s s'') (union s' s'').
Lemma inter_add_1 : In x s' -> inter (add x s) s' [=] add x (inter s s').
Lemma inter_add_2 : ~ In x s' -> inter (add x s) s' [=] inter s s'.
Lemma empty_inter_1 : Empty s -> Empty (inter s s').
Lemma empty_inter_2 : Empty s' -> Empty (inter s s').
Lemma inter_subset_1 : inter s s' [<=] s.
Lemma inter_subset_2 : inter s s' [<=] s'.
Lemma inter_subset_3 :  s''[<=]s -> s''[<=]s' -> s''[<=] inter s s'.
Lemma empty_diff_1 : Empty s -> Empty (diff s s').
Lemma empty_diff_2 : Empty s -> diff s' s [=] s'.
Lemma diff_subset : diff s s' [<=] s.
Lemma diff_subset_equal : s[<=]s' -> diff s s' [=] empty.
Lemma remove_diff_singleton :  remove x s [=] diff s (singleton x).
Lemma diff_inter_empty : inter (diff s s') (inter s s') [=] empty.
Lemma diff_inter_all : union (diff s s') (inter s s') [=] s.
Lemma Add_add : Add x s (add x s).
Lemma Add_remove : In x s -> Add x (remove x s) s.
Lemma union_Add : Add x s s' -> Add x (union s s'') (union s' s'').
Lemma inter_Add :  In x s'' -> Add x s s' -> Add x (inter s s'') (inter s' s'').
Lemma union_Equal :  In x s'' -> Add x s s' -> union s s'' [=] union s' s''.
Lemma inter_Add_2 :  ~In x s'' -> Add x s s' -> inter s s'' [=] inter s' s''.
Lemma elements_Empty : forall s, Empty s <-> elements s = nil.
Lemma elements_empty : elements empty = nil.
Lemma of_list_1 : forall l x, In x (of_list l) <-> InA E.eq x l.
Lemma of_list_2 : forall l, equivlistA E.eq (to_list (of_list l)) l.
Lemma of_list_3 : forall s, of_list (to_list s) [=] s.
Lemma fold_spec_right (s:t)(A:Type)(i:A)(f : elt -> A -> A) :   fold f s i = List.fold_right f i (rev (elements s)).
Lemma fold_rec_nodep :   forall (A:Type)(P : A -> Type)(f : elt -> A -> A)(i:A)(s:t),    P i -> (forall x a, In x s -> P a -> P (f x a)) ->    P (fold f s i).
Lemma fold_rec_weak :   forall (A:Type)(P : t -> A -> Type)(f : elt -> A -> A)(i:A),   (forall s s' a, s[=]s' -> P s a -> P s' a) ->   P empty i ->   (forall x a s, ~In x s -> P s a -> P (add x s) (f x a)) ->   forall s, P s (fold f s i).
Lemma fold_rel :   forall (A B:Type)(R : A -> B -> Type)    (f : elt -> A -> A)(g : elt -> B -> B)(i : A)(j : B)(s : t),    R i j ->    (forall x a b, In x s -> R a b -> R (f x a) (g x b)) ->    R (fold f s i) (fold g s j).
Lemma set_induction :  forall P : t -> Type,  (forall s, Empty s -> P s) ->  (forall s s', P s -> forall x, ~In x s -> Add x s s' -> P s') ->  forall s, P s.
Lemma set_induction_bis :  forall P : t -> Type,  (forall s s', s [=] s' -> P s -> P s') ->  P empty ->  (forall x s, ~In x s -> P s -> P (add x s)) ->  forall s, P s.
Lemma fold_identity : forall s, fold add s empty [=] s.
Lemma fold_0 :     forall s (A : Type) (i : A) (f : elt -> A -> A),     exists l : list elt,       NoDup l /\       (forall x : elt, In x s <-> InA x l) /\       fold f s i = fold_right f i l.
Lemma fold_1 :  forall s (A : Type) (eqA : A -> A -> Prop)    (st : Equivalence eqA) (i : A) (f : elt -> A -> A),  Empty s -> eqA (fold f s i) i.
Lemma fold_2 :  forall s s' x (A : Type) (eqA : A -> A -> Prop)    (st : Equivalence eqA) (i : A) (f : elt -> A -> A),  Proper (E.eq==>eqA==>eqA) f ->
Lemma fold_1b :  forall s (A : Type)(i : A) (f : elt -> A -> A),  Empty s -> (fold f s i) = i.
Lemma fold_commutes : forall i s x,  eqA (fold f s (f x i)) (f x (fold f s i)).
Lemma fold_init : forall i i' s, eqA i i' ->  eqA (fold f s i) (fold f s i').
Lemma fold_equal :  forall i s s', s[=]s' -> eqA (fold f s i) (fold f s' i).
Lemma fold_empty : forall i, fold f empty i = i.
Lemma fold_add : forall i s x, ~In x s ->  eqA (fold f (add x s) i) (f x (fold f s i)).
Lemma add_fold : forall i s x, In x s ->  eqA (fold f (add x s) i) (fold f s i).
Lemma remove_fold_1: forall i s x, In x s ->  eqA (f x (fold f (remove x s) i)) (fold f s i).
Lemma remove_fold_2: forall i s x, ~In x s ->  eqA (fold f (remove x s) i) (fold f s i).
Lemma fold_union_inter : forall i s s',  eqA (fold f (union s s') (fold f (inter s s') i))      (fold f s (fold f s' i)).
Lemma fold_diff_inter : forall i s s',  eqA (fold f (diff s s') (fold f (inter s s') i)) (fold f s i).
Lemma fold_union: forall i s s',  (forall x, ~(In x s/\In x s')) ->  eqA (fold f (union s s') i) (fold f s (fold f s' i)).
Lemma fold_plus :  forall s p, fold (fun _ => S) s p = fold (fun _ => S) s 0 + p.
Lemma cardinal_fold : forall s, cardinal s = fold (fun _ => S) s 0.
Lemma cardinal_0 :    forall s, exists l : list elt,       NoDupA E.eq l /\
Lemma cardinal_1 : forall s, Empty s -> cardinal s = 0.
Lemma cardinal_2 :   forall s s' x, ~ In x s -> Add x s s' -> cardinal s' = S (cardinal s).
Lemma cardinal_Empty : forall s, Empty s <-> cardinal s = 0.
Lemma cardinal_inv_1 : forall s, cardinal s = 0 -> Empty s.
Lemma cardinal_inv_2 :  forall s n, cardinal s = S n -> { x : elt | In x s }.
Lemma cardinal_inv_2b :  forall s, cardinal s <> 0 -> { x : elt | In x s }.
Lemma Equal_cardinal : forall s s', s[=]s' -> cardinal s = cardinal s'.
Lemma empty_cardinal : cardinal empty = 0.
Lemma singleton_cardinal : forall x, cardinal (singleton x) = 1.
Lemma diff_inter_cardinal :  forall s s', cardinal (diff s s') + cardinal (inter s s') = cardinal s .
Lemma union_cardinal:  forall s s', (forall x, ~(In x s/\In x s')) ->  cardinal (union s s')=cardinal s+cardinal s'.
Lemma subset_cardinal :  forall s s', s[<=]s' -> cardinal s <= cardinal s' .
Lemma subset_cardinal_lt :  forall s s' x, s[<=]s' -> In x s' -> ~In x s -> cardinal s < cardinal s'.
Lemma union_cardinal_inter :  forall s s', cardinal (union s s') = cardinal s + cardinal s' - cardinal (inter s s').
Lemma union_cardinal_le :  forall s s', cardinal (union s s') <= cardinal s  + cardinal s'.
Lemma add_cardinal_1 :  forall s x, In x s -> cardinal (add x s) = cardinal s.
Lemma add_cardinal_2 :  forall s x, ~In x s -> cardinal (add x s) = S (cardinal s).
Lemma remove_cardinal_1 :  forall s x, In x s -> S (cardinal (remove x s)) = cardinal s.
Lemma remove_cardinal_2 :  forall s x, ~In x s -> cardinal (remove x s) = cardinal s.
Lemma sort_equivlistA_eqlistA : forall l l' : list elt,  sort E.lt l -> sort E.lt l' -> equivlistA E.eq l l' -> eqlistA E.eq l l'.
Lemma gtb_1 : forall x y, gtb x y = true <-> E.lt y x.
Lemma leb_1 : forall x y, leb x y = true <-> ~E.lt y x.
Lemma elements_split : forall x s,  elements s = elements_lt x s ++ elements_ge x s.
Lemma elements_Add : forall s s' x, ~In x s -> Add x s s' ->   eqlistA E.eq (elements s') (elements_lt x s ++ x :: elements_ge x s).
Lemma elements_Add_Above : forall s s' x,  Above x s -> Add x s s' ->    eqlistA E.eq (elements s') (elements s ++ x::nil).
Lemma elements_Add_Below : forall s s' x,  Below x s -> Add x s s' ->    eqlistA E.eq (elements s') (x::elements s).
Lemma set_induction_max :  forall P : t -> Type,  (forall s : t, Empty s -> P s) ->  (forall s s', P s -> forall x, Above x s -> Add x s s' -> P s') ->  forall s : t, P s.
Lemma set_induction_min :  forall P : t -> Type,  (forall s : t, Empty s -> P s) ->  (forall s s', P s -> forall x, Below x s -> Add x s s' -> P s') ->  forall s : t, P s.
Lemma fold_3 :  forall s s' x (A : Type) (eqA : A -> A -> Prop)    (st : Equivalence eqA) (i : A) (f : elt -> A -> A),  Proper (E.eq==>eqA==>eqA) f ->
Lemma fold_4 :  forall s s' x (A : Type) (eqA : A -> A -> Prop)    (st : Equivalence eqA) (i : A) (f : elt -> A -> A),  Proper (E.eq==>eqA==>eqA) f ->
Lemma fold_equal :  forall i s s', s[=]s' -> eqA (fold f s i) (fold f s' i).
Lemma add_fold : forall i s x, In x s ->  eqA (fold f (add x s) i) (fold f s i).
Lemma remove_fold_2: forall i s x, ~In x s ->  eqA (fold f (remove x s) i) (fold f s i).
Lemma choose_equal : forall s s', Equal s s' ->   match choose s, choose s' with     | Some x, Some x' => E.eq x x'
Lemma Dcompare_inf : forall r:comparison, {r = Eq} + {r = Lt} + {r = Gt}.
Lemma Zcompare_rect (P:Type) (n m:Z) : ((n ?= m) = Eq -> P) -> ((n ?= m) = Lt -> P) -> ((n ?= m) = Gt -> P) -> P.
Lemma Zcompare_rec (P:Set) (n m:Z) : ((n ?= m) = Eq -> P) -> ((n ?= m) = Lt -> P) -> ((n ?= m) = Gt -> P) -> P.
Lemma Z_lt_le_dec : {x < y} + {y <= x}.
Lemma Zlt_cotrans : forall n m:Z, n < m -> forall p:Z, {n < p} + {p < m}.
Lemma Zlt_cotrans_pos : forall n m:Z, 0 < n + m -> {0 < n} + {0 < m}.
Lemma Zlt_cotrans_neg : forall n m:Z, n + m < 0 -> {n < 0} + {m < 0}.
Lemma not_Zeq_inf : forall n m:Z, n <> m -> {n < m} + {m < n}.
Lemma Z_dec : forall n m:Z, {n < m} + {n > m} + {n = m}.
Lemma Z_dec' : forall n m:Z, {n < m} + {m < n} + {n = m}.
Lemma inject_Z_injective (a b: Z): inject_Z a == inject_Z b <-> a = b.
Lemma Qeq_alt p q : (p == q) <-> (p ?= q) = Eq.
Lemma Qlt_alt p q : (p<q) <-> (p?=q = Lt).
Lemma Qgt_alt p q : (p>q) <-> (p?=q = Gt).
Lemma Qle_alt p q : (p<=q) <-> (p?=q <> Gt).
Lemma Qge_alt p q : (p>=q) <-> (p?=q <> Lt).
Lemma Qcompare_antisym x y : CompOpp (x ?= y) = (y ?= x).
Lemma Qcompare_spec x y : CompareSpec (x==y) (x<y) (y<x) (x ?= y).
Lemma Qeq_bool_iff x y : Qeq_bool x y = true <-> x == y.
Lemma Qeq_bool_eq x y : Qeq_bool x y = true -> x == y.
Lemma Qeq_eq_bool x y : x == y -> Qeq_bool x y = true.
Lemma Qeq_bool_neq x y : Qeq_bool x y = false -> ~ x == y.
Lemma Qle_bool_iff x y : Qle_bool x y = true <-> x <= y.
Lemma Qle_bool_imp_le x y : Qle_bool x y = true -> x <= y.
Lemma Qmake_Qdiv a b : a#b==inject_Z a/inject_Z ('b).
Lemma Q_apart_0_1 : ~ 1 == 0.
Lemma Qplus_0_l : forall x, 0+x == x.
Lemma Qplus_0_r : forall x, x+0 == x.
Lemma Qopp_involutive : forall q, - -q == q.
Lemma Qplus_inj_r (x y z: Q): x + z == y + z <-> x == y.
Lemma Qplus_inj_l (x y z: Q): z + x == z + y <-> x == y.
Lemma Qmult_0_l : forall x , 0*x == 0.
Lemma Qmult_0_r : forall x , x*0 == 0.
Lemma Qmult_1_l : forall n, 1*n == n.
Lemma inject_Z_plus (x y: Z): inject_Z (x + y) = inject_Z x + inject_Z y.
Lemma inject_Z_mult (x y: Z): inject_Z (x * y) = inject_Z x * inject_Z y.
Lemma inject_Z_opp (x: Z): inject_Z (- x) = - inject_Z x.
Lemma Qinv_involutive : forall q, (/ / q) == q.
Lemma Qinv_mult_distr : forall p q, / (p * q) == /p * /q.
Lemma Qmult_inj_r (x y z: Q): ~ z == 0 -> (x * z == y * z <-> x == y).
Lemma Qmult_inj_l (x y z: Q): ~ z == 0 -> (z * x == z * y <-> x == y).
Lemma Qle_refl x : x<=x.
Lemma Qle_antisym x y : x<=y -> y<=x -> x==y.
Lemma Qle_trans : forall x y z, x<=y -> y<=z -> x<=z.
Lemma Qlt_irrefl x : ~x<x.
Lemma Qlt_not_eq x y : x<y -> ~ x==y.
Lemma Zle_Qle (x y: Z): (x <= y)%Z = (inject_Z x <= inject_Z y).
Lemma Zlt_Qlt (x y: Z): (x < y)%Z = (inject_Z x < inject_Z y).
Lemma Qle_lteq x y : x<=y <-> x<y \/ x==y.
Lemma Qlt_le_weak x y : x<y -> x<=y.
Lemma Qle_lt_trans : forall x y z, x<=y -> y<z -> x<z.
Lemma Qlt_le_trans : forall x y z, x<y -> y<=z -> x<z.
Lemma Qlt_trans : forall x y z, x<y -> y<z -> x<z.
Lemma Qnot_lt_le : forall x y, ~ x<y -> y<=x.
Lemma Qnot_le_lt : forall x y, ~ x<=y -> y<x.
Lemma Qlt_not_le : forall x y, x<y -> ~ y<=x.
Lemma Qle_not_lt : forall x y, x<=y -> ~ y<x.
Lemma Qle_lt_or_eq : forall x y, x<=y -> x<y \/ x==y.
Lemma Q_dec : forall x y, {x<y} + {y<x} + {x==y}.
Lemma Qlt_le_dec : forall x y, {x<y} + {y<=x}.
Lemma Qopp_le_compat : forall p q, p<=q -> -q <= -p.
Lemma Qle_minus_iff : forall p q, p <= q <-> 0 <= q+-p.
Lemma Qlt_minus_iff : forall p q, p < q <-> 0 < q+-p.
Lemma Qplus_le_compat : forall x y z t, x<=y -> z<=t -> x+z <= y+t.
Lemma Qplus_lt_le_compat : forall x y z t, x<y -> z<=t -> x+z < y+t.
Lemma Qplus_le_l (x y z: Q): x + z <= y + z <-> x <= y.
Lemma Qplus_le_r (x y z: Q): z + x <= z + y <-> x <= y.
Lemma Qplus_lt_l (x y z: Q): x + z < y + z <-> x < y.
Lemma Qplus_lt_r (x y z: Q): z + x < z + y <-> x < y.
Lemma Qmult_le_compat_r : forall x y z, x <= y -> 0 <= z -> x*z <= y*z.
Lemma Qmult_lt_0_le_reg_r : forall x y z, 0 < z  -> x*z <= y*z -> x <= y.
Lemma Qmult_le_r (x y z: Q): 0 < z -> (x*z <= y*z <-> x <= y).
Lemma Qmult_le_l (x y z: Q): 0 < z -> (z*x <= z*y <-> x <= y).
Lemma Qmult_lt_compat_r : forall x y z, 0 < z  -> x < y -> x*z < y*z.
Lemma Qmult_lt_r: forall x y z, 0 < z -> (x*z < y*z <-> x < y).
Lemma Qmult_lt_l (x y z: Q): 0 < z -> (z*x < z*y <-> x < y).
Lemma Qmult_le_0_compat : forall a b, 0 <= a -> 0 <= b -> 0 <= a*b.
Lemma Qinv_le_0_compat : forall a, 0 <= a -> 0 <= /a.
Lemma Qle_shift_div_l : forall a b c, 0 < c -> a*c <= b -> a <= b/c.
Lemma Qle_shift_inv_l : forall a c, 0 < c -> a*c <= 1 -> a <= /c.
Lemma Qle_shift_div_r : forall a b c, 0 < b -> a <= c*b -> a/b <= c.
Lemma Qle_shift_inv_r : forall b c, 0 < b -> 1 <= c*b -> /b <= c.
Lemma Qinv_lt_0_compat : forall a, 0 < a -> 0 < /a.
Lemma Qlt_shift_div_l : forall a b c, 0 < c -> a*c < b -> a < b/c.
Lemma Qlt_shift_inv_l : forall a c, 0 < c -> a*c < 1 -> a < /c.
Lemma Qlt_shift_div_r : forall a b c, 0 < b -> a < c*b -> a/b < c.
Lemma Qlt_shift_inv_r : forall b c, 0 < b -> 1 < c*b -> /b < c.
Lemma Rsqr_neg : forall x:R, Rsqr x = Rsqr (- x).
Lemma Rsqr_mult : forall x y:R, Rsqr (x * y) = Rsqr x * Rsqr y.
Lemma Rsqr_plus : forall x y:R, Rsqr (x + y) = Rsqr x + Rsqr y + 2 * x * y.
Lemma Rsqr_minus : forall x y:R, Rsqr (x - y) = Rsqr x + Rsqr y - 2 * x * y.
Lemma Rsqr_neg_minus : forall x y:R, Rsqr (x - y) = Rsqr (y - x).
Lemma Rsqr_1 : Rsqr 1 = 1.
Lemma Rsqr_gt_0_0 : forall x:R, 0 < Rsqr x -> x <> 0.
Lemma Rsqr_pos_lt : forall x:R, x <> 0 -> 0 < Rsqr x.
Lemma Rsqr_div : forall x y:R, y <> 0 -> Rsqr (x / y) = Rsqr x / Rsqr y.
Lemma Rsqr_eq_0 : forall x:R, Rsqr x = 0 -> x = 0.
Lemma Rsqr_minus_plus : forall a b:R, (a - b) * (a + b) = Rsqr a - Rsqr b.
Lemma Rsqr_plus_minus : forall a b:R, (a + b) * (a - b) = Rsqr a - Rsqr b.
Lemma Rsqr_incr_0 : forall x y:R, Rsqr x <= Rsqr y -> 0 <= x -> 0 <= y -> x <= y.
Lemma Rsqr_incr_0_var : forall x y:R, Rsqr x <= Rsqr y -> 0 <= y -> x <= y.
Lemma Rsqr_incr_1 : forall x y:R, x <= y -> 0 <= x -> 0 <= y -> Rsqr x <= Rsqr y.
Lemma Rsqr_incrst_0 : forall x y:R, Rsqr x < Rsqr y -> 0 <= x -> 0 <= y -> x < y.
Lemma Rsqr_incrst_1 : forall x y:R, x < y -> 0 <= x -> 0 <= y -> Rsqr x < Rsqr y.
Lemma Rsqr_neg_pos_le_0 : forall x y:R, Rsqr x <= Rsqr y -> 0 <= y -> - y <= x.
Lemma Rsqr_neg_pos_le_1 : forall x y:R, - y <= x -> x <= y -> 0 <= y -> Rsqr x <= Rsqr y.
Lemma neg_pos_Rsqr_le : forall x y:R, - y <= x -> x <= y -> Rsqr x <= Rsqr y.
Lemma Rsqr_abs : forall x:R, Rsqr x = Rsqr (Rabs x).
Lemma Rsqr_le_abs_0 : forall x y:R, Rsqr x <= Rsqr y -> Rabs x <= Rabs y.
Lemma Rsqr_le_abs_1 : forall x y:R, Rabs x <= Rabs y -> Rsqr x <= Rsqr y.
Lemma Rsqr_lt_abs_0 : forall x y:R, Rsqr x < Rsqr y -> Rabs x < Rabs y.
Lemma Rsqr_lt_abs_1 : forall x y:R, Rabs x < Rabs y -> Rsqr x < Rsqr y.
Lemma Rsqr_inj : forall x y:R, 0 <= x -> 0 <= y -> Rsqr x = Rsqr y -> x = y.
Lemma Rsqr_eq_abs_0 : forall x y:R, Rsqr x = Rsqr y -> Rabs x = Rabs y.
Lemma Rsqr_eq_asb_1 : forall x y:R, Rabs x = Rabs y -> Rsqr x = Rsqr y.
Lemma triangle_rectangle : forall x y z:R,   0 <= z -> Rsqr x + Rsqr y <= Rsqr z -> - z <= x <= z /\ - z <= y <= z.
Lemma triangle_rectangle_lt : forall x y z:R,   Rsqr x + Rsqr y < Rsqr z -> Rabs x < Rabs z /\ Rabs y < Rabs z.
Lemma triangle_rectangle_le : forall x y z:R,   Rsqr x + Rsqr y <= Rsqr z -> Rabs x <= Rabs z /\ Rabs y <= Rabs z.
Lemma Rsqr_inv : forall x:R, x <> 0 -> Rsqr (/ x) = / Rsqr x.
Lemma canonical_Rsqr : forall (a:nonzeroreal) (b c x:R),   a * Rsqr x + b * x + c =   a * Rsqr (x + b / (2 * a)) + (4 * a * c - Rsqr b) / (4 * a).
Lemma Rsqr_eq : forall x y:R, Rsqr x = Rsqr y -> x = y \/ x = - y.
Lemma succ_m1 : S (-1) == 0.
Lemma Zmax_spec x y : x >= y /\ Z.max x y = x  \/ x < y /\ Z.max x y = y.
Lemma Zmax_left n m : n>=m -> Z.max n m = n.
Lemma Zpos_max_1 p : Z.max 1 (Z.pos p) = Z.pos p.
Lemma spec_more_than_1_digit: 1 < Zpos digits.
Lemma wB_pos : wB > 0.
Lemma spec_to_Z_1 : forall x, 0 <= [|x|].
Lemma spec_to_Z_2 : forall x, [|x|] < wB.
Lemma spec_to_Z : forall x, 0 <= [|x|] < wB.
Lemma spec_of_pos : forall p,  Zpos p = (Z.of_N (fst (of_pos p)))*wB + [|(snd (of_pos p))|].
Lemma spec_zdigits : [|zdigits|] = Zpos digits.
Lemma spec_0 : [|zero|] = 0.
Lemma spec_1 : [|one|] = 1.
Lemma spec_Bm1 : [|minus_one|] = wB - 1.
Lemma spec_compare : forall x y,  compare x y = Z.compare [|x|] [|y|].
Lemma spec_eq0 : forall x, eq0 x = true -> [|x|] = 0.
Lemma spec_opp_c : forall x, [-|opp_c x|] = -[|x|].
Lemma spec_opp : forall x, [|opp x|] = (-[|x|]) mod wB.
Lemma spec_opp_carry : forall x, [|opp_carry x|] = wB - [|x|] - 1.
Lemma Zmod_equal : forall x y z, z>0 -> (x-y) mod z = 0 -> x mod z = y mod z.
Lemma spec_succ_c : forall x, [+|succ_c x|] = [|x|] + 1.
Lemma spec_add_c : forall x y, [+|add_c x y|] = [|x|] + [|y|].
Lemma spec_add_carry_c : forall x y, [+|add_carry_c x y|] = [|x|] + [|y|] + 1.
Lemma spec_succ : forall x, [|succ x|] = ([|x|] + 1) mod wB.
Lemma spec_add : forall x y, [|add x y|] = ([|x|] + [|y|]) mod wB.
Lemma spec_add_carry :  forall x y, [|add_carry x y|] = ([|x|] + [|y|] + 1) mod wB.
Lemma spec_pred_c : forall x, [-|pred_c x|] = [|x|] - 1.
Lemma spec_sub_c : forall x y, [-|sub_c x y|] = [|x|] - [|y|].
Lemma spec_sub_carry_c : forall x y, [-|sub_carry_c x y|] = [|x|] - [|y|] - 1.
Lemma spec_pred : forall x, [|pred x|] = ([|x|] - 1) mod wB.
Lemma spec_sub : forall x y, [|sub x y|] = ([|x|] - [|y|]) mod wB.
Lemma spec_sub_carry : forall x y, [|sub_carry x y|] = ([|x|] - [|y|] - 1) mod wB.
Lemma spec_mul_c : forall x y, [|| mul_c x y ||] = [|x|] * [|y|].
Lemma spec_mul : forall x y, [|mul x y|] = ([|x|] * [|y|]) mod wB.
Lemma spec_square_c : forall x, [|| square_c x||] = [|x|] * [|x|].
Lemma spec_div : forall a b, 0 < [|b|] ->     let (q,r) := div a b in     [|a|] = [|q|] * [|b|] + [|r|] /\     0 <= [|r|] < [|b|].
Lemma spec_div_gt : forall a b, [|a|] > [|b|] -> 0 < [|b|] ->     let (q,r) := div_gt a b in     [|a|] = [|q|] * [|b|] + [|r|] /\     0 <= [|r|] < [|b|].
Lemma spec_modulo :  forall a b, 0 < [|b|] ->     [|modulo a b|] = [|a|] mod [|b|].
Lemma spec_modulo_gt : forall a b, [|a|] > [|b|] -> 0 < [|b|] ->     [|modulo_gt a b|] = [|a|] mod [|b|].
Lemma Zgcd_bound : forall a b, 0<=a -> 0<=b -> Z.gcd a b <= Z.max a b.
Lemma spec_gcd : forall a b, Zis_gcd [|a|] [|b|] [|gcd a b|].
Lemma spec_gcd_gt : forall a b, [|a|] > [|b|] ->     Zis_gcd [|a|] [|b|] [|gcd_gt a b|].
Lemma spec_div21 : forall a1 a2 b,     wB/2 <= [|b|] ->     [|a1|] < [|b|] ->     let (q,r) := div21 a1 a2 b in     [|a1|] *wB+ [|a2|] = [|q|] * [|b|] + [|r|] /\     0 <= [|r|] < [|b|].
Lemma spec_add_mul_div : forall x y p,      [|p|] <= Zpos digits ->      [| add_mul_div p x y |] =        ([|x|] * (2 ^ [|p|]) +         [|y|] / (2 ^ ((Zpos digits) - [|p|]))) mod wB.
Lemma spec_pos_mod : forall w p,      [|pos_mod p w|] = [|w|] mod (2 ^ [|p|]).
Lemma spec_is_even : forall x,     if is_even x then [|x|] mod 2 = 0 else [|x|] mod 2 = 1.
Lemma spec_sqrt : forall x,      [|sqrt x|] ^ 2 <= [|x|] < ([|sqrt x|] + 1) ^ 2.
Lemma spec_sqrt2 : forall x y,      wB/ 4 <= [|x|] ->      let (s,r) := sqrt2 x y in         [||WW x y||] = [|s|] ^ 2 + [+|r|] /\         [+|r|] <= 2 * [|s|].
Lemma two_p_power2 : forall x, x>=0 -> two_p x = 2 ^ x.
Lemma spec_head00:  forall x, [|x|] = 0 -> [|head0 x|] = Zpos digits.
Lemma log_inf_bounded : forall x p, Zpos x < 2^p -> log_inf x < p.
Lemma spec_head0  : forall x,  0 < [|x|] ->  wB/ 2 <= 2 ^ ([|head0 x|]) * [|x|] < wB.
Lemma Ptail_pos : forall p, 0 <= Ptail p.
Lemma Ptail_bounded : forall p d, Zpos p < 2^(Zpos d) -> Ptail p < Zpos d.
Lemma spec_tail00:  forall x, [|x|] = 0 -> [|tail0 x|] = Zpos digits.
Lemma spec_tail0  : forall x, 0 < [|x|] ->        exists y, 0 <= y /\ [|x|] = (2 * y + 1) * (2 ^ [|tail0 x|]).
Lemma pow_sub_r : forall a b c, a~=0 -> 0<=c<=b -> a^(b-c) == a^b / a^c.
Lemma pow_div_l : forall a b c, b~=0 -> 0<=c -> a mod b == 0 -> (a/b)^c == a^c / b^c.
Lemma exists_div2 a : exists a' (b:bool), a == 2*a' + b.
Lemma testbit_0_r a (b:bool) : testbit (2*a+b) 0 = b.
Lemma testbit_succ_r a (b:bool) n : 0<=n -> testbit (2*a+b) (succ n) = testbit a n.
Lemma testbit_spec' a n : 0<=n -> a.[n] == (a / 2^n) mod 2.
Lemma testbit_spec a n : 0<=n -> exists l h, 0<=l<2^n /\ a == l + (a.[n] + 2*h)*2^n.
Lemma testbit_true : forall a n, 0<=n -> (a.[n] = true <-> (a / 2^n) mod 2 == 1).
Lemma testbit_false : forall a n, 0<=n -> (a.[n] = false <-> (a / 2^n) mod 2 == 0).
Lemma testbit_eqb : forall a n, 0<=n -> a.[n] = eqb ((a / 2^n) mod 2) 1.
Lemma b2z_inj : forall (a0 b0:bool), a0 == b0 -> a0 = b0.
Lemma add_b2z_double_div2 : forall (a0:bool) a, (a0+2*a)/2 == a.
Lemma add_b2z_double_bit0 : forall (a0:bool) a, (a0+2*a).[0] = a0.
Lemma b2z_div2 : forall (a0:bool), a0/2 == 0.
Lemma b2z_bit0 : forall (a0:bool), a0.[0] = a0.
Lemma testbit_unique : forall a n (a0:bool) l h, 0<=l<2^n -> a == l + (a0 + 2*h)*2^n -> a.[n] = a0.
Lemma bits_0 : forall n, 0.[n] = false.
Lemma bits_opp : forall a n, 0<=n -> (-a).[n] = negb (P a).[n].
Lemma bits_m1 : forall n, 0<=n -> (-1).[n] = true.
Lemma bit0_odd : forall a, a.[0] = odd a.
Lemma bit0_eqb : forall a, a.[0] = eqb (a mod 2) 1.
Lemma bit0_mod : forall a, a.[0] == a mod 2.
Lemma testbit_odd : forall a n, a.[n] = odd (a>>n).
Lemma bit_log2 : forall a, 0<a -> a.[log2 a] = true.
Lemma bits_above_log2 : forall a n, 0<=a -> log2 a < n -> a.[n] = false.
Lemma bit_log2_neg : forall a, a < -1 -> a.[log2 (P (-a))] = false.
Lemma bits_above_log2_neg : forall a n, a < 0 -> log2 (P (-a)) < n -> a.[n] = true.
Lemma bits_iff_nonneg : forall a n, log2 (abs a) < n -> (0<=a <-> a.[n] = false).
Lemma bits_iff_nonneg' : forall a, 0<=a <-> a.[S (log2 (abs a))] = false.
Lemma bits_iff_nonneg_ex : forall a, 0<=a <-> (exists k, forall m, k<m -> a.[m] = false).
Lemma bits_iff_neg : forall a n, log2 (abs a) < n -> (a<0 <-> a.[n] = true).
Lemma bits_iff_neg' : forall a, a<0 <-> a.[S (log2 (abs a))] = true.
Lemma bits_iff_neg_ex : forall a, a<0 <-> (exists k, forall m, k<m -> a.[m] = true).
Lemma div2_bits : forall a n, 0<=n -> (a/2).[n] = a.[S n].
Lemma div_pow2_bits : forall a n m, 0<=n -> 0<=m -> (a/2^n).[m] = a.[m+n].
Lemma double_bits_succ : forall a n, (2*a).[S n] = a.[n].
Lemma double_bits : forall a n, (2*a).[n] = a.[P n].
Lemma mul_pow2_bits_add : forall a n m, 0<=n -> (a*2^n).[n+m] = a.[m].
Lemma mul_pow2_bits : forall a n m, 0<=n -> (a*2^n).[m] = a.[m-n].
Lemma mul_pow2_bits_low : forall a n m, m<n -> (a*2^n).[m] = false.
Lemma mod_pow2_bits_high : forall a n m, 0<=n<=m -> (a mod 2^n).[m] = false.
Lemma mod_pow2_bits_low : forall a n m, m<n -> (a mod 2^n).[m] = a.[m].
Lemma bits_inj_0 : forall a, (forall n, a.[n] = false) -> a == 0.
Lemma bits_inj : forall a b, testbit a === testbit b -> a == b.
Lemma bits_inj_iff : forall a b, testbit a === testbit b <-> a == b.
Lemma bits_inj' : forall a b, (forall n, 0<=n -> a.[n] = b.[n]) -> a == b.
Lemma bits_inj_iff' : forall a b, (forall n, 0<=n -> a.[n] = b.[n]) <-> a == b.
Lemma are_bits : forall (f:t->bool), Proper (eq==>Logic.eq) f ->
Lemma shiftl_spec : forall a n m, 0<=m -> (a << n).[m] = a.[m-n].
Lemma shiftr_opp_r : forall a n, a >> (-n) == a << n.
Lemma shiftl_opp_r : forall a n, a << (-n) == a >> n.
Lemma shiftr_div_pow2 : forall a n, 0<=n -> a >> n == a / 2^n.
Lemma shiftr_mul_pow2 : forall a n, n<=0 -> a >> n == a * 2^(-n).
Lemma shiftl_mul_pow2 : forall a n, 0<=n -> a << n == a * 2^n.
Lemma shiftl_div_pow2 : forall a n, n<=0 -> a << n == a / 2^(-n).
Lemma shiftl_spec_alt : forall a n m, 0<=n -> (a << n).[m+n] = a.[m].
Lemma shiftl_shiftl : forall a n m, 0<=n -> (a << n) << m == a << (n+m).
Lemma shiftr_shiftl_l : forall a n m, 0<=n -> (a << n) >> m == a << (n-m).
Lemma shiftr_shiftl_r : forall a n m, 0<=n -> (a << n) >> m == a >> (m-n).
Lemma shiftr_shiftr : forall a n m, 0<=m -> (a >> n) >> m == a >> (n+m).
Lemma shiftl_1_l : forall n, 1 << n == 2^n.
Lemma shiftl_0_r : forall a, a << 0 == a.
Lemma shiftr_0_r : forall a, a >> 0 == a.
Lemma shiftl_0_l : forall n, 0 << n == 0.
Lemma shiftr_0_l : forall n, 0 >> n == 0.
Lemma shiftl_eq_0_iff : forall a n, 0<=n -> (a << n == 0 <-> a == 0).
Lemma shiftr_eq_0_iff : forall a n, a >> n == 0 <-> a==0 \/ (0<a /\ log2 a < n).
Lemma shiftr_eq_0 : forall a n, 0<=a -> log2 a < n -> a >> n == 0.
Lemma div2_div : forall a, div2 a == a/2.
Lemma div2_odd : forall a, a == 2*(div2 a) + odd a.
Lemma lxor_eq : forall a a', lxor a a' == 0 -> a == a'.
Lemma lxor_nilpotent : forall a, lxor a a == 0.
Lemma lxor_eq_0_iff : forall a a', lxor a a' == 0 <-> a == a'.
Lemma lxor_0_l : forall a, lxor 0 a == a.
Lemma lxor_0_r : forall a, lxor a 0 == a.
Lemma lxor_comm : forall a b, lxor a b == lxor b a.
Lemma lxor_assoc : forall a b c, lxor (lxor a b) c == lxor a (lxor b c).
Lemma lor_0_l : forall a, lor 0 a == a.
Lemma lor_0_r : forall a, lor a 0 == a.
Lemma lor_comm : forall a b, lor a b == lor b a.
Lemma lor_assoc : forall a b c, lor a (lor b c) == lor (lor a b) c.
Lemma lor_diag : forall a, lor a a == a.
Lemma lor_eq_0_l : forall a b, lor a b == 0 -> a == 0.
Lemma lor_eq_0_iff : forall a b, lor a b == 0 <-> a == 0 /\ b == 0.
Lemma land_0_l : forall a, land 0 a == 0.
Lemma land_0_r : forall a, land a 0 == 0.
Lemma land_comm : forall a b, land a b == land b a.
Lemma land_assoc : forall a b c, land a (land b c) == land (land a b) c.
Lemma land_diag : forall a, land a a == a.
Lemma ldiff_0_l : forall a, ldiff 0 a == 0.
Lemma ldiff_0_r : forall a, ldiff a 0 == a.
Lemma ldiff_diag : forall a, ldiff a a == 0.
Lemma lor_land_distr_l : forall a b c, lor (land a b) c == land (lor a c) (lor b c).
Lemma lor_land_distr_r : forall a b c, lor a (land b c) == land (lor a b) (lor a c).
Lemma land_lor_distr_l : forall a b c, land (lor a b) c == lor (land a c) (land b c).
Lemma land_lor_distr_r : forall a b c, land a (lor b c) == lor (land a b) (land a c).
Lemma ldiff_ldiff_l : forall a b c, ldiff (ldiff a b) c == ldiff a (lor b c).
Lemma lor_ldiff_and : forall a b, lor (ldiff a b) (land a b) == a.
Lemma land_ldiff : forall a b, land (ldiff a b) b == 0.
Lemma setbit_spec' : forall a n, setbit a n == lor a (2^n).
Lemma clearbit_spec' : forall a n, clearbit a n == ldiff a (2^n).
Lemma pow2_bits_true : forall n, 0<=n -> (2^n).[n] = true.
Lemma pow2_bits_false : forall n m, n~=m -> (2^n).[m] = false.
Lemma pow2_bits_eqb : forall n m, 0<=n -> (2^n).[m] = eqb n m.
Lemma setbit_eqb : forall a n m, 0<=n -> (setbit a n).[m] = eqb n m || a.[m].
Lemma setbit_iff : forall a n m, 0<=n -> ((setbit a n).[m] = true <-> n==m \/ a.[m] = true).
Lemma setbit_eq : forall a n, 0<=n -> (setbit a n).[n] = true.
Lemma setbit_neq : forall a n m, 0<=n -> n~=m -> (setbit a n).[m] = a.[m].
Lemma clearbit_eqb : forall a n m, (clearbit a n).[m] = a.[m] && negb (eqb n m).
Lemma clearbit_iff : forall a n m, (clearbit a n).[m] = true <-> a.[m] = true /\ n~=m.
Lemma clearbit_eq : forall a n, (clearbit a n).[n] = false.
Lemma clearbit_neq : forall a n m, n~=m -> (clearbit a n).[m] = a.[m].
Lemma shiftl_lxor : forall a b n, (lxor a b) << n == lxor (a << n) (b << n).
Lemma shiftr_lxor : forall a b n, (lxor a b) >> n == lxor (a >> n) (b >> n).
Lemma shiftl_land : forall a b n, (land a b) << n == land (a << n) (b << n).
Lemma shiftr_land : forall a b n, (land a b) >> n == land (a >> n) (b >> n).
Lemma shiftl_lor : forall a b n, (lor a b) << n == lor (a << n) (b << n).
Lemma shiftr_lor : forall a b n, (lor a b) >> n == lor (a >> n) (b >> n).
Lemma shiftl_ldiff : forall a b n, (ldiff a b) << n == ldiff (a << n) (b << n).
Lemma shiftr_ldiff : forall a b n, (ldiff a b) >> n == ldiff (a >> n) (b >> n).
Lemma lnot_spec : forall a n, 0<=n -> (lnot a).[n] = negb a.[n].
Lemma lnot_involutive : forall a, lnot (lnot a) == a.
Lemma lnot_0 : lnot 0 == -1.
Lemma lnot_m1 : lnot (-1) == 0.
Lemma lor_m1_r : forall a, lor a (-1) == -1.
Lemma lor_m1_l : forall a, lor (-1) a == -1.
Lemma land_m1_r : forall a, land a (-1) == a.
Lemma land_m1_l : forall a, land (-1) a == a.
Lemma ldiff_m1_r : forall a, ldiff a (-1) == 0.
Lemma ldiff_m1_l : forall a, ldiff (-1) a == lnot a.
Lemma lor_lnot_diag : forall a, lor a (lnot a) == -1.
Lemma add_lnot_diag : forall a, a + lnot a == -1.
Lemma ldiff_land : forall a b, ldiff a b == land a (lnot b).
Lemma land_lnot_diag : forall a, land a (lnot a) == 0.
Lemma lnot_lor : forall a b, lnot (lor a b) == land (lnot a) (lnot b).
Lemma lnot_land : forall a b, lnot (land a b) == lor (lnot a) (lnot b).
Lemma lnot_ldiff : forall a b, lnot (ldiff a b) == lor (lnot a) b.
Lemma lxor_lnot_lnot : forall a b, lxor (lnot a) (lnot b) == lxor a b.
Lemma lnot_lxor_l : forall a b, lnot (lxor a b) == lxor (lnot a) b.
Lemma lnot_lxor_r : forall a b, lnot (lxor a b) == lxor a (lnot b).
Lemma lxor_m1_r : forall a, lxor a (-1) == lnot a.
Lemma lxor_m1_l : forall a, lxor (-1) a == lnot a.
Lemma lxor_lor : forall a b, land a b == 0 -> lxor a b == lor a b.
Lemma lnot_shiftr : forall a n, 0<=n -> lnot (a >> n) == (lnot a) >> n.
Lemma ones_equiv : forall n, ones n == P (2^n).
Lemma ones_add : forall n m, 0<=n -> 0<=m -> ones (m+n) == 2^m * ones n + ones m.
Lemma ones_div_pow2 : forall n m, 0<=m<=n -> ones n / 2^m == ones (n-m).
Lemma ones_mod_pow2 : forall n m, 0<=m<=n -> (ones n) mod (2^m) == ones m.
Lemma ones_spec_low : forall n m, 0<=m<n -> (ones n).[m] = true.
Lemma ones_spec_high : forall n m, 0<=n<=m -> (ones n).[m] = false.
Lemma ones_spec_iff : forall n m, 0<=n -> ((ones n).[m] = true <-> 0<=m<n).
Lemma lor_ones_low : forall a n, 0<=a -> log2 a < n -> lor a (ones n) == ones n.
Lemma land_ones : forall a n, 0<=n -> land a (ones n) == a mod 2^n.
Lemma land_ones_low : forall a n, 0<=a -> log2 a < n -> land a (ones n) == a.
Lemma ldiff_ones_r : forall a n, 0<=n -> ldiff a (ones n) == (a >> n) << n.
Lemma ldiff_ones_r_low : forall a n, 0<=a -> log2 a < n -> ldiff a (ones n) == 0.
Lemma ldiff_ones_l_low : forall a n, 0<=a -> log2 a < n -> ldiff (ones n) a == lxor a (ones n).
Lemma shiftl_nonneg : forall a n, 0 <= (a << n) <-> 0 <= a.
Lemma shiftl_neg : forall a n, (a << n) < 0 <-> a < 0.
Lemma shiftr_nonneg : forall a n, 0 <= (a >> n) <-> 0 <= a.
Lemma shiftr_neg : forall a n, (a >> n) < 0 <-> a < 0.
Lemma div2_nonneg : forall a, 0 <= div2 a <-> 0 <= a.
Lemma div2_neg : forall a, div2 a < 0 <-> a < 0.
Lemma lor_nonneg : forall a b, 0 <= lor a b <-> 0<=a /\ 0<=b.
Lemma lor_neg : forall a b, lor a b < 0 <-> a < 0 \/ b < 0.
Lemma lnot_nonneg : forall a, 0 <= lnot a <-> a < 0.
Lemma lnot_neg : forall a, lnot a < 0 <-> 0 <= a.
Lemma land_nonneg : forall a b, 0 <= land a b <-> 0<=a \/ 0<=b.
Lemma land_neg : forall a b, land a b < 0 <-> a < 0 /\ b < 0.
Lemma ldiff_nonneg : forall a b, 0 <= ldiff a b <-> 0<=a \/ b<0.
Lemma ldiff_neg : forall a b, ldiff a b < 0 <-> a<0 /\ 0<=b.
Lemma lxor_nonneg : forall a b, 0 <= lxor a b <-> (0<=a <-> 0<=b).
Lemma log2_bits_unique : forall a n, a.[n] = true ->
Lemma log2_shiftr : forall a n, 0<a -> log2 (a >> n) == max 0 (log2 a - n).
Lemma log2_shiftl : forall a n, 0<a -> 0<=n -> log2 (a << n) == log2 a + n.
Lemma log2_shiftl' : forall a n, 0<a -> log2 (a << n) == max 0 (log2 a + n).
Lemma log2_lor : forall a b, 0<=a -> 0<=b -> log2 (lor a b) == max (log2 a) (log2 b).
Lemma log2_land : forall a b, 0<=a -> 0<=b -> log2 (land a b) <= min (log2 a) (log2 b).
Lemma log2_lxor : forall a b, 0<=a -> 0<=b -> log2 (lxor a b) <= max (log2 a) (log2 b).
Lemma add_bit0 : forall a b, (a+b).[0] = xorb a.[0] b.[0].
Lemma add3_bit0 : forall a b c, (a+b+c).[0] = xor3 a.[0] b.[0] c.[0].
Lemma add3_bits_div2 : forall (a0 b0 c0 : bool), (a0 + b0 + c0)/2 == nextcarry a0 b0 c0.
Lemma add_carry_div2 : forall a b (c0:bool), (a + b + c0)/2 == a/2 + b/2 + nextcarry a.[0] b.[0] c0.
Lemma add_carry_bits_aux : forall n, 0<=n -> forall a b (c0:bool), -(2^n) <= a < 2^n -> -(2^n) <= b < 2^n -> exists c,  a+b+c0 == lxor3 a b c /\ c/2 == lnextcarry a b c /\ c.[0] = c0.
Lemma add_carry_bits : forall a b (c0:bool), exists c, a+b+c0 == lxor3 a b c /\ c/2 == lnextcarry a b c /\ c.[0] = c0.
Lemma add_bit1 : forall a b, (a+b).[1] = xor3 a.[1] b.[1] (a.[0] && b.[0]).
Lemma nocarry_equiv : forall a b c, c/2 == lnextcarry a b c -> c.[0] = false ->
Lemma add_nocarry_lxor : forall a b, land a b == 0 -> a+b == lxor a b.
Lemma ldiff_le : forall a b, 0<=b -> ldiff a b == 0 -> 0 <= a <= b.
Lemma sub_nocarry_ldiff : forall a b, ldiff b a == 0 -> a-b == ldiff a b.
Lemma add_nocarry_lt_pow2 : forall a b n, land a b == 0 -> a < 2^n -> b < 2^n -> a+b < 2^n.
Lemma add_nocarry_mod_lt_pow2 : forall a b n, 0<=n -> land a b == 0 -> a mod 2^n + b mod 2^n < 2^n.
Lemma subset_eq : forall A (P : A -> Prop) (n m : sig P), n = m <-> `n = `m.
Lemma match_eq_rewrite : forall (A B : Type) (x : A) (fn : forall (y : A | y = x), B) (y : A | y = x), match_eq A B x fn = fn y.
Lemma eq_dep_refl : forall (p:U) (x:P p), eq_dep p x p x.
Lemma eq_dep_sym :   forall (p q:U) (x:P p) (y:P q), eq_dep p x q y -> eq_dep q y p x.
Lemma eq_dep_trans :   forall (p q r:U) (x:P p) (y:P q) (z:P r),     eq_dep p x q y -> eq_dep q y r z -> eq_dep p x r z.
Lemma eq_dep1_dep :   forall (p:U) (x:P p) (q:U) (y:P q), eq_dep1 p x q y -> eq_dep p x q y.
Lemma eq_dep_dep1 :   forall (p q:U) (x:P p) (y:P q), eq_dep p x q y -> eq_dep1 p x q y.
Lemma eq_sigT_eq_dep : forall (U:Type) (P:U -> Type) (p q:U) (x:P p) (y:P q),   existT P p x = existT P q y -> eq_dep p x q y.
Lemma eq_dep_eq_sigT : forall (U:Type) (P:U -> Type) (p q:U) (x:P p) (y:P q),   eq_dep p x q y -> existT P p x = existT P q y.
Lemma eq_sigT_iff_eq_dep : forall (U:Type) (P:U -> Type) (p q:U) (x:P p) (y:P q),   existT P p x = existT P q y <-> eq_dep p x q y.
Lemma eq_sig_eq_dep : forall (U:Prop) (P:U -> Prop) (p q:U) (x:P p) (y:P q),   exist P p x = exist P q y -> eq_dep p x q y.
Lemma eq_dep_eq_sig : forall (U:Prop) (P:U -> Prop) (p q:U) (x:P p) (y:P q),   eq_dep p x q y -> exist P p x = exist P q y.
Lemma eq_sig_iff_eq_dep : forall (U:Prop) (P:U -> Prop) (p q:U) (x:P p) (y:P q),   exist P p x = exist P q y <-> eq_dep p x q y.
Lemma eq_sigT_sig_eq : forall X P (x1 x2:X) H1 H2, existT P x1 H1 = existT P x2 H2 <-> {H:x1=x2 | rew H in H1 = H2}.
Lemma eq_sigT_fst : forall X P (x1 x2:X) H1 H2 (H:existT P x1 H1 = existT P x2 H2), x1 = x2.
Lemma eq_sigT_snd : forall X P (x1 x2:X) H1 H2 (H:existT P x1 H1 = existT P x2 H2), rew (eq_sigT_fst H) in H1 = H2.
Lemma eq_sig_fst : forall X P (x1 x2:X) H1 H2 (H:exist P x1 H1 = exist P x2 H2), x1 = x2.
Lemma eq_sig_snd : forall X P (x1 x2:X) H1 H2 (H:exist P x1 H1 = exist P x2 H2), rew (eq_sig_fst H) in H1 = H2.
Lemma eq_rect_eq__eq_dep1_eq :   Eq_rect_eq -> forall (P:U->Type) (p:U) (x y:P p), eq_dep1 p x p y -> x = y.
Lemma eq_rect_eq__eq_dep_eq : Eq_rect_eq -> Eq_dep_eq.
Lemma eq_dep_eq__UIP : Eq_dep_eq -> UIP_.
Lemma UIP__UIP_refl : UIP_ -> UIP_refl_.
Lemma UIP_refl__Streicher_K : UIP_refl_ -> Streicher_K_.
Lemma Streicher_K__eq_rect_eq : Streicher_K_ -> Eq_rect_eq.
Lemma eq_dep_eq__inj_pair2 : Eq_dep_eq U -> Inj_dep_pair.
Lemma eq_rect_eq : forall (p:U) (Q:U -> Type) (x:Q p) (h:p = p), x = eq_rect p Q x p h.
Lemma eq_rec_eq : forall (p:U) (Q:U -> Set) (x:Q p) (h:p = p), x = eq_rec p Q x p h.
Lemma eq_dep_eq : forall (P:U->Type) (p:U) (x y:P p), eq_dep p x p y -> x = y.
Lemma UIP : forall (x y:U) (p1 p2:x = y), p1 = p2.
Lemma UIP_refl : forall (x:U) (p:x = x), p = eq_refl x.
Lemma Streicher_K : forall (x:U) (P:x = x -> Prop), P (eq_refl x) -> forall p:x = x, P p.
Lemma inj_pair2 : forall (U:Type) (P:U -> Type) (p:U) (x y:P p),  existT P p x = existT P p y -> x = y.
Lemma lt_not_eq : forall s s',  lt s s' -> ~ eq s s'.
Lemma mem_spec : mem x s = true <-> In x s.
Lemma equal_spec : equal s s' = true <-> Equal s s'.
Lemma subset_spec : subset s s' = true <-> Subset s s'.
Lemma is_empty_spec : is_empty s = true <-> Empty s.
Lemma add_spec : In y (add x s) <-> E.eq y x \/ In y s.
Lemma remove_spec : In y (remove x s) <-> In y s /\ ~E.eq y x.
Lemma singleton_spec : In y (singleton x) <-> E.eq y x.
Lemma elements_spec1 : InA E.eq x (elements s) <-> In x s.
Lemma for_all_spec : forall f, Proper (E.eq==>Logic.eq) f ->
Lemma exists_spec : forall f, Proper (E.eq==>Logic.eq) f ->
Lemma compare_spec : forall s s', CompSpec eq lt s s' (compare s s').
Lemma description_rel_choice_imp_funct_choice : forall A B : Type,   FunctionalRelReification_on A B -> RelationalChoice_on A B -> FunctionalChoice_on A B.
Lemma funct_choice_imp_rel_choice : forall A B, FunctionalChoice_on A B -> RelationalChoice_on A B.
Lemma funct_choice_imp_description : forall A B, FunctionalChoice_on A B -> FunctionalRelReification_on A B.
Lemma rel_choice_and_proof_irrel_imp_guarded_rel_choice : RelationalChoice -> ProofIrrelevance -> GuardedRelationalChoice.
Lemma rel_choice_indep_of_general_premises_imp_guarded_rel_choice : forall A B, inhabited B -> RelationalChoice_on A B ->   IndependenceOfGeneralPremises -> GuardedRelationalChoice_on A B.
Lemma guarded_rel_choice_imp_rel_choice : forall A B, GuardedRelationalChoice_on A B -> RelationalChoice_on A B.
Lemma subset_types_imp_guarded_rel_choice_iff_rel_choice : ProofIrrelevance -> (GuardedRelationalChoice <-> RelationalChoice).
Lemma guarded_fun_choice_imp_indep_of_general_premises : GuardedFunctionalChoice -> IndependenceOfGeneralPremises.
Lemma guarded_fun_choice_imp_fun_choice : GuardedFunctionalChoice -> FunctionalChoiceOnInhabitedSet.
Lemma fun_choice_and_indep_general_prem_imp_guarded_fun_choice : FunctionalChoiceOnInhabitedSet -> IndependenceOfGeneralPremises -> GuardedFunctionalChoice.
Lemma omniscient_fun_choice_imp_small_drinker : OmniscientFunctionalChoice -> SmallDrinker'sParadox.
Lemma omniscient_fun_choice_imp_fun_choice : OmniscientFunctionalChoice -> FunctionalChoiceOnInhabitedSet.
Lemma fun_choice_and_small_drinker_imp_omniscient_fun_choice : FunctionalChoiceOnInhabitedSet -> SmallDrinker'sParadox -> OmniscientFunctionalChoice.
Lemma iota_imp_constructive_definite_description : IotaStatement -> ConstructiveDefiniteDescription.
Lemma epsilon_imp_constructive_indefinite_description: EpsilonStatement -> ConstructiveIndefiniteDescription.
Lemma constructive_indefinite_description_and_small_drinker_imp_epsilon : SmallDrinker'sParadox -> ConstructiveIndefiniteDescription -> EpsilonStatement.
Lemma epsilon_imp_small_drinker : EpsilonStatement -> SmallDrinker'sParadox.
Lemma classical_denumerable_description_imp_fun_choice : forall A:Type,   FunctionalRelReification_on A nat ->   forall R:A->nat->Prop,     (forall x y, decidable (R x y)) -> FunctionalChoice_on_rel R.
Lemma relative_non_contradiction_of_indefinite_descr : forall C:Prop, (ConstructiveIndefiniteDescription -> C) -> (FunctionalChoice -> C).
Lemma constructive_indefinite_descr_fun_choice : ConstructiveIndefiniteDescription -> FunctionalChoice.
Lemma relative_non_contradiction_of_definite_descr : forall C:Prop, (ConstructiveDefiniteDescription -> C) -> (FunctionalRelReification -> C).
Lemma constructive_definite_descr_fun_reification : ConstructiveDefiniteDescription -> FunctionalRelReification.
Lemma ge_not_lt x y : y<=x -> x<y -> False.
Lemma max_l x y : y<=x -> max x y == x.
Lemma max_r x y : x<=y -> max x y == y.
Lemma min_l x y : x<=y -> min x y == x.
Lemma min_r x y : y<=x -> min x y == y.
Lemma max_spec n m : (n < m /\ max n m == m) \/ (m <= n /\ max n m == n).
Lemma max_spec_le n m : (n <= m /\ max n m == m) \/ (m <= n /\ max n m == n).
Lemma max_unicity n m p : ((n < m /\ p == m) \/ (m <= n /\ p == n)) -> p == max n m.
Lemma max_unicity_ext f : (forall n m, (n < m /\ f n m == m) \/ (m <= n /\ f n m == n)) -> (forall n m, f n m == max n m).
Lemma max_mono f : (Proper (eq ==> eq) f) -> (Proper (le ==> le) f) -> forall x y, max (f x) (f y) == f (max x y).
Lemma max_id n : max n n == n.
Lemma max_assoc m n p : max m (max n p) == max (max m n) p.
Lemma max_comm n m : max n m == max m n.
Lemma le_max_l n m : n <= max n m.
Lemma le_max_r n m : m <= max n m.
Lemma max_l_iff n m : max n m == n <-> m <= n.
Lemma max_r_iff n m : max n m == m <-> n <= m.
Lemma max_le n m p : p <= max n m -> p <= n \/ p <= m.
Lemma max_le_iff n m p : p <= max n m <-> p <= n \/ p <= m.
Lemma max_lt_iff n m p : p < max n m <-> p < n \/ p < m.
Lemma max_lub_l n m p : max n m <= p -> n <= p.
Lemma max_lub_r n m p : max n m <= p -> m <= p.
Lemma max_lub n m p : n <= p -> m <= p -> max n m <= p.
Lemma max_lub_iff n m p : max n m <= p <-> n <= p /\ m <= p.
Lemma max_lub_lt n m p : n < p -> m < p -> max n m < p.
Lemma max_lub_lt_iff n m p : max n m < p <-> n < p /\ m < p.
Lemma max_le_compat_l n m p : n <= m -> max p n <= max p m.
Lemma max_le_compat_r n m p : n <= m -> max n p <= max m p.
Lemma max_le_compat n m p q : n <= m -> p <= q -> max n p <= max m q.
Lemma min_spec n m : (n < m /\ min n m == n) \/ (m <= n /\ min n m == m).
Lemma min_spec_le n m : (n <= m /\ min n m == n) \/ (m <= n /\ min n m == m).
Lemma min_unicity n m p : ((n < m /\ p == n) \/ (m <= n /\ p == m)) ->  p == min n m.
Lemma min_unicity_ext f : (forall n m, (n < m /\ f n m == n)  \/ (m <= n /\ f n m == m)) -> (forall n m, f n m == min n m).
Lemma min_mono f : (Proper (eq ==> eq) f) -> (Proper (le ==> le) f) -> forall x y, min (f x) (f y) == f (min x y).
Lemma min_id n : min n n == n.
Lemma min_assoc m n p : min m (min n p) == min (min m n) p.
Lemma min_comm n m : min n m == min m n.
Lemma le_min_r n m : min n m <= m.
Lemma le_min_l n m : min n m <= n.
Lemma min_l_iff n m : min n m == n <-> n <= m.
Lemma min_r_iff n m : min n m == m <-> m <= n.
Lemma min_le n m p : min n m <= p -> n <= p \/ m <= p.
Lemma min_le_iff n m p : min n m <= p <-> n <= p \/ m <= p.
Lemma min_lt_iff n m p : min n m < p <-> n < p \/ m < p.
Lemma min_glb_l n m p : p <= min n m -> p <= n.
Lemma min_glb_r n m p : p <= min n m -> p <= m.
Lemma min_glb n m p : p <= n -> p <= m -> p <= min n m.
Lemma min_glb_iff n m p : p <= min n m <-> p <= n /\ p <= m.
Lemma min_glb_lt n m p : p < n -> p < m -> p < min n m.
Lemma min_glb_lt_iff n m p : p < min n m <-> p < n /\ p < m.
Lemma min_le_compat_l n m p : n <= m -> min p n <= min p m.
Lemma min_le_compat_r n m p : n <= m -> min n p <= min m p.
Lemma min_le_compat n m p q : n <= m -> p <= q -> min n p <= min m q.
Lemma min_max_absorption n m : max n (min n m) == n.
Lemma max_min_absorption n m : min n (max n m) == n.
Lemma max_min_distr n m p : max n (min m p) == min (max n m) (max n p).
Lemma min_max_distr n m p : min n (max m p) == max (min n m) (min n p).
Lemma max_min_modular n m p : max n (min m (max n p)) == min (max n m) (max n p).
Lemma min_max_modular n m p : min n (max m (min n p)) == max (min n m) (min n p).
Lemma max_min_disassoc n m p : min n (max m p) <= max (min n m) p.
Lemma max_min_antimono f : Proper (eq==>eq) f -> Proper (le==>inverse le) f -> forall x y, max (f x) (f y) == f (min x y).
Lemma min_max_antimono f : Proper (eq==>eq) f -> Proper (le==>inverse le) f -> forall x y, min (f x) (f y) == f (max x y).
Lemma max_case_strong n m (P:t -> Type) : (forall x y, x==y -> P x -> P y) -> (m<=n -> P n) -> (n<=m -> P m) -> P (max n m).
Lemma max_case n m (P:t -> Type) : (forall x y, x == y -> P x -> P y) -> P n -> P m -> P (max n m).
Lemma max_dec n m : {max n m == n} + {max n m == m}.
Lemma min_case_strong n m (P:O.t -> Type) :
Lemma min_case n m (P:O.t -> Type) :
Lemma min_dec n m : {min n m == n} + {min n m == m}.
Lemma max_monotone f : Proper (le ==> le) f -> forall x y, max (f x) (f y) = f (max x y).
Lemma min_monotone f : Proper (le ==> le) f -> forall x y, min (f x) (f y) = f (min x y).
Lemma min_max_antimonotone f : Proper (le ==> inverse le) f -> forall x y, min (f x) (f y) = f (max x y).
Lemma max_min_antimonotone f : Proper (le ==> inverse le) f -> forall x y, max (f x) (f y) = f (min x y).
Lemma max_case_strong : forall n m (P:t -> Type), (m<=n -> P n) -> (n<=m -> P m) -> P (max n m).
Lemma max_case : forall n m (P:t -> Type), P n -> P m -> P (max n m).
Lemma max_dec : forall n m, {max n m = n} + {max n m = m}.
Lemma min_case_strong : forall n m (P:O.t -> Type),
Lemma min_case : forall n m (P:O.t -> Type),
Lemma min_dec : forall n m, {min n m = n} + {min n m = m}.
Lemma compare_spec : forall x y, CompSpec eq lt x y (compare x y).
Lemma NNPP : forall p:Prop, ~ ~ p -> p.
Lemma Peirce : forall P:Prop, ((P -> False) -> P) -> P.
Lemma not_imply_elim : forall P Q:Prop, ~ (P -> Q) -> P.
Lemma not_imply_elim2 : forall P Q:Prop, ~ (P -> Q) -> ~ Q.
Lemma imply_to_or : forall P Q:Prop, (P -> Q) -> ~ P \/ Q.
Lemma imply_to_and : forall P Q:Prop, ~ (P -> Q) -> P /\ ~ Q.
Lemma or_to_imply : forall P Q:Prop, ~ P \/ Q -> P -> Q.
Lemma not_and_or : forall P Q:Prop, ~ (P /\ Q) -> ~ P \/ ~ Q.
Lemma or_not_and : forall P Q:Prop, ~ P \/ ~ Q -> ~ (P /\ Q).
Lemma not_or_and : forall P Q:Prop, ~ (P \/ Q) -> ~ P /\ ~ Q.
Lemma and_not_or : forall P Q:Prop, ~ P /\ ~ Q -> ~ (P \/ Q).
Lemma imply_and_or : forall P Q:Prop, (P -> Q) -> P \/ Q -> Q.
Lemma imply_and_or2 : forall P Q R:Prop, (P -> Q) -> P \/ R -> Q \/ R.
Lemma proof_irrelevance : forall (P:Prop) (p1 p2:P), p1 = p2.
Lemma eq_rect_eq : forall (U:Type) (p:U) (Q:U -> Type) (x:Q p) (h:p = p), x = eq_rect p Q x p h.
Lemma Ropp_div : forall x y, -x/y = -(x/y).
Lemma Boule_half_to_interval : forall x , Boule (/2) pos_half x -> 0 <= x <= 1.
Lemma Boule_lt : forall c r x, Boule c r x -> Rabs x < Rabs c + r.
Lemma Un_cv_ext : forall un vn, (forall n, un n = vn n) -> forall l, Un_cv un l -> Un_cv vn l.
Lemma Alt_first_term_bound :forall f l N n,  Un_decreasing f -> Un_cv f 0 ->  Un_cv (sum_f_R0 (tg_alt f)) l ->  (N <= n)%nat ->  R_dist (sum_f_R0 (tg_alt f) n) l <= f N.
Lemma Alt_CVU : forall (f : nat -> R -> R) g h c r,  (forall x, Boule c r x ->Un_decreasing (fun n => f n x)) ->   (forall x, Boule c r x -> Un_cv (fun n => f n x) 0) ->  (forall x, Boule c r x ->       Un_cv (sum_f_R0 (tg_alt  (fun i => f i x))) (g x)) ->  (forall x n, Boule c r x -> f n x <= h n) ->  (Un_cv h 0) ->  CVU (fun N x => sum_f_R0 (tg_alt (fun i => f i x)) N) g c r.
Lemma pow2_ge_0 : forall x, 0 <= x ^ 2.
Lemma pow2_abs : forall x,  Rabs x ^ 2 = x ^ 2.
Lemma derivable_pt_tan : forall x, -PI/2 < x < PI/2 -> derivable_pt tan x.
Lemma derive_pt_tan : forall (x:R), forall (Pr1: -PI/2 < x < PI/2), derive_pt tan x (derivable_pt_tan x Pr1) = 1 + (tan x)^2.
Lemma derive_increasing_interv : forall (a b:R) (f:R -> R),   a < b ->   forall (pr:forall x, a < x < b -> derivable_pt f x),   (forall t:R, forall (t_encad : a < t < b), 0 < derive_pt f t (pr t t_encad)) ->   forall x y:R, a < x < b -> a < y < b -> x < y -> f x < f y.
Lemma plus_Rsqr_gt_0 : forall x, 1 + x ^ 2 > 0.
Lemma PI2_lower_bound : forall x, 0 < x < 2 -> 0 < cos x  -> x < PI/2.
Lemma PI2_3_2 : 3/2 < PI/2.
Lemma PI2_1 : 1 < PI/2.
Lemma tan_increasing : forall x y:R,   -PI/2 < x ->   x < y ->    y < PI/2 -> tan x < tan y.
Lemma tan_is_inj : forall x y, -PI/2 < x < PI/2 -> -PI/2 < y < PI/2 ->  tan x = tan y -> x = y.
Lemma exists_atan_in_frame : forall lb ub y, lb < ub -> -PI/2 < lb -> ub < PI/2 -> tan lb < y < tan ub -> {x | lb < x < ub /\ tan x = y}.
Lemma tan_1_gt_1 : tan 1 > 1.
Lemma ub_opp : forall x, x < PI/2 -> -PI/2 < -x.
Lemma pos_opp_lt : forall x, 0 < x -> -x < x.
Lemma tech_opp_tan : forall x y, -tan x < y -> tan (-x) < y.
Lemma atan_bound : forall x, -PI/2 < atan x < PI/2.
Lemma atan_right_inv : forall x, tan (atan x) = x.
Lemma atan_opp : forall x, atan (- x) = - atan x.
Lemma derivable_pt_atan : forall x, derivable_pt atan x.
Lemma atan_increasing : forall x y, x < y -> atan x < atan y.
Lemma atan_0 : atan 0 = 0.
Lemma atan_1 : atan 1 = PI/4.
Lemma derive_pt_atan : forall x,     derive_pt atan x (derivable_pt_atan x) =        1 / (1 + x²).
Lemma Ratan_seq_decreasing : forall x, (0 <= x <= 1)%R -> Un_decreasing (Ratan_seq x).
Lemma Ratan_seq_converging : forall x, (0 <= x <= 1)%R -> Un_cv (Ratan_seq x) 0.
Lemma Ratan_seq_opp : forall x n, Ratan_seq (-x) n = -Ratan_seq x n.
Lemma sum_Ratan_seq_opp :  forall x n, sum_f_R0 (tg_alt (Ratan_seq (- x))) n =    - sum_f_R0 (tg_alt (Ratan_seq x)) n.
Lemma ps_atan0_0 : ps_atan 0 = 0.
Lemma ps_atan_exists_1_opp : forall x h h', proj1_sig (ps_atan_exists_1 (-x) h) =     -(proj1_sig (ps_atan_exists_1 x h')).
Lemma ps_atan_opp : forall x, ps_atan (-x) = -ps_atan x.
Lemma ps_atanSeq_continuity_pt_1 : forall (N:nat) (x:R),     0 <= x ->     x <= 1 ->     continuity_pt (fun x => sum_f_R0 (tg_alt (Ratan_seq x)) N) x.
Lemma pow_lt_1_compat : forall x n, 0 <= x < 1 -> (0 < n)%nat ->  0 <= x ^ n < 1.
Lemma Datan_seq_Rabs : forall x n, Datan_seq (Rabs x) n = Datan_seq x n.
Lemma Datan_seq_pos : forall x n, 0 < x -> 0 < Datan_seq x n.
Lemma Datan_sum_eq :forall x n, sum_f_R0 (tg_alt (Datan_seq x)) n = (1 - (- x ^ 2) ^ S n)/(1 + x ^ 2).
Lemma Datan_seq_increasing : forall x y n, (n > 0)%nat -> 0 <= x < y -> Datan_seq x n < Datan_seq y n.
Lemma Datan_seq_decreasing : forall x,  -1 < x -> x < 1 -> Un_decreasing (Datan_seq x).
Lemma Datan_seq_CV_0 : forall x, -1 < x -> x < 1 -> Un_cv (Datan_seq x) 0.
Lemma Datan_lim : forall x, -1 < x -> x < 1 ->   Un_cv (fun N : nat => sum_f_R0 (tg_alt (Datan_seq x)) N) (/ (1 + x ^ 2)).
Lemma Datan_CVU_prelim : forall c (r : posreal), Rabs c + r < 1 -> CVU (fun N x => sum_f_R0 (tg_alt (Datan_seq x)) N)    (fun y : R => / (1 + y ^ 2)) c r.
Lemma Datan_is_datan : forall (N:nat) (x:R),     -1 <= x ->     x < 1 -> derivable_pt_lim (fun x => sum_f_R0 (tg_alt (Ratan_seq x)) N) x (sum_f_R0 (tg_alt (Datan_seq x)) N).
Lemma Ratan_CVU' : CVU (fun N x => sum_f_R0 (tg_alt (Ratan_seq x)) N)                    ps_atan (/2) (mkposreal (/2) pos_half_prf).
Lemma Ratan_CVU : CVU (fun N x => sum_f_R0 (tg_alt (Ratan_seq x)) N)                    ps_atan 0  (mkposreal 1 Rlt_0_1).
Lemma Alt_PI_tg : forall n, PI_tg n = Ratan_seq 1 n.
Lemma Ratan_is_ps_atan : forall eps, eps > 0 ->      exists N, forall n, (n >= N)%nat -> forall x, -1 < x -> x < 1 ->      Rabs (sum_f_R0 (tg_alt (Ratan_seq x)) n - ps_atan x) < eps.
Lemma Datan_continuity : continuity (fun x => /(1+x ^ 2)).
Lemma derivable_pt_lim_ps_atan : forall x, -1 < x < 1 -> derivable_pt_lim ps_atan x ((fun y => /(1 + y ^ 2)) x).
Lemma derivable_pt_ps_atan :  forall x, -1 < x < 1 -> derivable_pt ps_atan x.
Lemma ps_atan_continuity_pt_1 : forall eps : R,      eps > 0 ->      exists alp : R,      alp > 0 /\      (forall x, x < 1 -> 0 < x -> R_dist x 1 < alp ->      dist R_met (ps_atan x) (Alt_PI/4) < eps).
Lemma Datan_eq_DatanSeq_interv : forall x, -1 < x < 1 -> forall (Pratan:derivable_pt ps_atan x) (Prmymeta:derivable_pt atan x),     derive_pt ps_atan x Pratan = derive_pt atan x Prmymeta.
Lemma atan_eq_ps_atan : forall x, 0 < x < 1 -> atan x = ps_atan x.
Lemma PI_ineq : forall N : nat,   sum_f_R0 (tg_alt PI_tg) (S (2 * N)) <= PI / 4 <=   sum_f_R0 (tg_alt PI_tg) (2 * N).
Lemma compare_spec : forall x y, CompSpec eq lt x y (compare x y).
Lemma lt_not_eq : forall x y, lt x y -> ~eq x y.
Lemma lt_trans : Transitive lt.
Lemma lt_eq : forall x y z, lt x y -> eq y z -> lt x z.
Lemma eq_lt : forall x y z, eq x y -> lt y z -> lt x z.
Lemma compare_spec : forall x y, CompSpec eq lt x y (compare x y).
Lemma compare_sym :  forall x y, (y?=x) = CompOpp (x?=y).
Lemma compare_Eq : forall x y, compare x y = Eq <-> eq x y.
Lemma compare_Lt : forall x y, compare x y = Lt <-> lt x y.
Lemma compare_Gt : forall x y, compare x y = Gt <-> lt y x.
Lemma compare_trans :  forall c x y z, (x?=y) = c -> (y?=z) = c -> (x?=z) = c.
Lemma iter_nat_of_Z : forall n A f x, 0 <= n -> Z.iter n f x = iter_nat (Z.abs_nat n) A f x.
Lemma lt_stepl : forall x y z, x < y -> x == z -> z < y.
Lemma lt_stepr : forall x y z, x < y -> y == z -> x < z.
Lemma le_stepl : forall x y z, x <= y -> x == z -> z <= y.
Lemma le_stepr : forall x y z, x <= y -> y == z -> x <= z.
Lemma lt_exists_pred_strong : forall z n m, z < m -> m <= n -> exists k, m == S k /\ z <= k.
Lemma lt_succ_pred : forall z n, z < n -> S (P n) == n.
Lemma rs_rs' :  A z -> right_step -> right_step'.
Lemma rs'_rs'' : right_step' -> right_step''.
Lemma rbase : A' z.
Lemma A'A_right : (forall n, A' n) -> forall n, z <= n -> A n.
Lemma ls_ls' :  A z -> left_step -> left_step'.
Lemma ls'_ls'' : left_step' -> left_step''.
Lemma lbase : A' (S z).
Lemma A'A_left : (forall n, A' n) -> forall n, n <= z -> A n.
Lemma eqb_eq : forall x y, eqb x y = true <-> x==y.
Lemma le_lteq : forall x y, le x y <-> x<y \/ x==y.
Lemma lt_total : forall x y, x<y \/ x==y \/ y<x.
Lemma leb_le : forall x y, leb x y <-> x <= y.
Lemma leb_total : forall x y, leb x y \/ leb y x.
Lemma leb_trans : Transitive leb.
Lemma compare_spec : forall x y, CompSpec eq lt x y (compare x y).
Lemma eqb_eq : forall x y, eqb x y <-> eq x y.
Lemma finite_cardinal :   forall X:Ensemble U, Finite U X ->  exists n : nat, cardinal U X n.
Lemma cardinal_finite :   forall (X:Ensemble U) (n:nat), cardinal U X n -> Finite U X.
Lemma Finite_downward_closed :   forall A:Ensemble U,     Finite U A -> forall X:Ensemble U, Included U X A -> Finite U X.
Lemma Intersection_preserves_finite :   forall A:Ensemble U,     Finite U A -> forall X:Ensemble U, Finite U (Intersection U X A).
Lemma cardinalO_empty :   forall X:Ensemble U, cardinal U X 0 -> X = Empty_set U.
Lemma inh_card_gt_O :   forall X:Ensemble U, Inhabited U X -> forall n:nat, cardinal U X n -> n > 0.
Lemma card_soustr_1 :   forall (X:Ensemble U) (n:nat),     cardinal U X n ->     forall x:U, In U X x -> cardinal U (Subtract U X x) (pred n).
Lemma cardinal_is_functional :   forall (X:Ensemble U) (c1:nat),     cardinal U X c1 ->     forall (Y:Ensemble U) (c2:nat), cardinal U Y c2 -> X = Y -> c1 = c2.
Lemma cardinal_Empty : forall m:nat, cardinal U (Empty_set U) m -> 0 = m.
Lemma cardinal_unicity :   forall (X:Ensemble U) (n:nat),     cardinal U X n -> forall m:nat, cardinal U X m -> n = m.
Lemma card_Add_gen :   forall (A:Ensemble U) (x:U) (n n':nat),     cardinal U A n -> cardinal U (Add U A x) n' -> n' <= S n.
Lemma incl_st_card_lt :   forall (X:Ensemble U) (c1:nat),     cardinal U X c1 ->     forall (Y:Ensemble U) (c2:nat), cardinal U Y c2 -> Strict_Included U X Y -> c2 > c1.
Lemma incl_card_le :   forall (X Y:Ensemble U) (n m:nat),     cardinal U X n -> cardinal U Y m -> Included U X Y -> n <= m.
Lemma G_aux :   forall P:Ensemble U -> Prop,     (forall X:Ensemble U, Finite U X -> (forall Y:Ensemble U, Strict_Included U Y X -> P Y) -> P X) ->     P (Empty_set U).
Lemma Generalized_induction_on_finite_sets :   forall P:Ensemble U -> Prop,     (forall X:Ensemble U, Finite U X -> (forall Y:Ensemble U, Strict_Included U Y X -> P Y) -> P X) ->     forall X:Ensemble U, Finite U X -> P X.
Lemma diagonal_projs_same_behavior : forall A (x:Delta A), pi1 x = pi2 x.
Lemma diagonal_inverse1 : forall A, is_inverse (A:=A) delta pi1.
Lemma diagonal_inverse2 : forall A, is_inverse (A:=A) delta pi2.
Lemma FunctExt_UniqInverse : FunctionalExtensionality -> UniqueInverse.
Lemma UniqInverse_EqDeltaProjs : UniqueInverse -> EqDeltaProjs.
Lemma FunctExt_BijComp : FunctionalExtensionality -> BijectivityBijectiveComp.
Lemma BijComp_FunctExt : BijectivityBijectiveComp -> FunctionalExtensionality.
Lemma B0 : B 0.
Lemma BS : forall z : Z, B z -> B (z + 1).
Lemma BP : forall z : Z, B z -> B (z - 1).
Lemma B_holds : forall z : Z, B z.
Lemma eqb_eq x y : eqb x y = true <-> x == y.
Lemma leb_le x y : leb x y = true <-> x <= y.
Lemma ltb_lt x y : ltb x y = true <-> x < y.
Lemma compare_eq_iff n m : compare n m = Eq <-> n == m.
Lemma compare_lt_iff n m : compare n m = Lt <-> n < m.
Lemma compare_le_iff n m : compare n m <> Gt <-> n <= m.
Lemma compare_antisym n m : compare m n = CompOpp (compare n m).
Lemma pow_0_r : forall a, a^0 == 1.
Lemma pow_succ_r : forall a b, 0<=b -> a^(succ b) == a * a^b.
Lemma pow_neg_r : forall a b, b<0 -> a^b == 0.
Lemma pow_pow_N : forall a b, 0<=b -> a^b == pow_N a (Z.to_N (to_Z b)).
Lemma pow_pos_N : forall a p, pow_pos a p == pow_N a (Npos p).
Lemma square_spec n : square n == n * n.
Lemma sqrt_spec : forall n, 0<=n -> (sqrt n)*(sqrt n) <= n /\ n < (succ (sqrt n))*(succ (sqrt n)).
Lemma sqrt_neg : forall n, n<0 -> sqrt n == 0.
Lemma log2_spec : forall n, 0<n -> 2^(log2 n) <= n /\ n < 2^(succ (log2 n)).
Lemma log2_nonpos : forall n, n<=0 -> log2 n == 0.
Lemma even_spec n : even n = true <-> Even n.
Lemma odd_spec n : odd n = true <-> Odd n.
Lemma spec_divide : forall n m, (n|m) <-> Z.divide [n] [m].
Lemma gcd_divide_l : forall n m, (gcd n m | n).
Lemma gcd_divide_r : forall n m, (gcd n m | m).
Lemma gcd_greatest : forall n m p, (p|n) -> (p|m) -> (p|gcd n m).
Lemma gcd_nonneg : forall n m, 0 <= gcd n m.
Lemma testbit_odd_0 : forall a, testbit (2*a+1) 0 = true.
Lemma testbit_even_0 : forall a, testbit (2*a) 0 = false.
Lemma testbit_odd_succ : forall a n, 0<=n -> testbit (2*a+1) (succ n) = testbit a n.
Lemma testbit_even_succ : forall a n, 0<=n -> testbit (2*a) (succ n) = testbit a n.
Lemma testbit_neg_r : forall a n, n<0 -> testbit a n = false.
Lemma shiftr_spec : forall a n m, 0<=m -> testbit (shiftr a n) m = testbit a (m+n).
Lemma shiftl_spec_high : forall a n m, 0<=m -> n<=m -> testbit (shiftl a n) m = testbit a (m-n).
Lemma shiftl_spec_low : forall a n m, m<n -> testbit (shiftl a n) m = false.
Lemma land_spec : forall a b n, testbit (land a b) n = testbit a n && testbit b n.
Lemma lor_spec : forall a b n, testbit (lor a b) n = testbit a n || testbit b n.
Lemma ldiff_spec : forall a b n, testbit (ldiff a b) n = testbit a n && negb (testbit b n).
Lemma lxor_spec : forall a b n, testbit (lxor a b) n = xorb (testbit a n) (testbit b n).
Lemma div2_spec : forall a, div2 a == shiftr a 1.
Lemma compare_eq_iff x y : (x ?= y) = Eq <-> x==y.
Lemma compare_eq x y : (x ?= y) = Eq -> x==y.
Lemma compare_lt_iff x y : (x ?= y) = Lt <-> x<y.
Lemma compare_gt_iff x y : (x ?= y) = Gt <-> y<x.
Lemma compare_nlt_iff x y : (x ?= y) <> Lt <-> ~(x<y).
Lemma compare_ngt_iff x y : (x ?= y) <> Gt <-> ~(y<x).
Lemma compare_refl x : (x ?= x) = Eq.
Lemma compare_antisym x y : (y ?= x) = CompOpp (x ?= y).
Lemma le_not_gt_iff : forall x y, x<=y <-> ~y<x.
Lemma lt_not_ge_iff : forall x y, x<y <-> ~y<=x.
Lemma le_or_gt : forall x y, x<=y \/ y<x.
Lemma lt_or_ge : forall x y, x<y \/ y<=x.
Lemma eq_is_le_ge : forall x y, x==y <-> x<=y /\ y<=x.
Lemma compare_le_iff x y : compare x y <> Gt <-> x<=y.
Lemma compare_ge_iff x y : compare x y <> Lt <-> y<=x.
Lemma lt_dec : forall x y : t, {lt x y} + {~ lt x y}.
Lemma if_eq_dec : forall x y (B:Type)(b b':B),   (if eq_dec x y then b else b') =   (match compare x y with Eq => b | _ => b' end).
Lemma eqb_alt :   forall x y, eqb x y = match compare x y with Eq => true | _ => false end.
Lemma lt_not_eq x y : x<y -> ~x==y.  Proof. order. Qed.
Lemma lt_eq x y z : x<y -> y==z -> x<z. Proof. order. Qed.
Lemma eq_lt x y z : x==y -> y<z -> x<z. Proof. order. Qed.
Lemma le_eq x y z : x<=y -> y==z -> x<=z. Proof. order. Qed.
Lemma eq_le x y z : x==y -> y<=z -> x<=z. Proof. order. Qed.
Lemma neq_eq x y z : ~x==y -> y==z -> ~x==z. Proof. order. Qed.
Lemma eq_neq x y z : x==y -> ~y==z -> ~x==z. Proof. order. Qed.
Lemma le_lt_trans x y z : x<=y -> y<z -> x<z. Proof. order. Qed.
Lemma lt_le_trans x y z : x<y -> y<=z -> x<z. Proof. order. Qed.
Lemma le_trans x y z : x<=y -> y<=z -> x<=z. Proof. order. Qed.
Lemma le_antisym x y : x<=y -> y<=x -> x==y. Proof. order. Qed.
Lemma le_neq x y : x<=y -> ~x==y -> x<y. Proof. order. Qed.
Lemma neq_sym x y : ~x==y -> ~y==x. Proof. order. Qed.
Lemma lt_le x y : x<y -> x<=y. Proof. order. Qed.
Lemma gt_not_eq x y : y<x -> ~x==y. Proof. order. Qed.
Lemma eq_not_lt x y : x==y -> ~x<y. Proof. order. Qed.
Lemma eq_not_gt x y : x==y -> ~ y<x. Proof. order. Qed.
Lemma lt_not_gt x y : x<y -> ~ y<x. Proof. order. Qed.
Lemma eq_is_nlt_ngt x y : x==y <-> ~x<y /\ ~y<x.
Lemma le_lteq : forall x y, le x y <-> lt x y \/ eq x y.
Lemma compare_spec : forall x y, CompSpec eq lt x y (compare x y).
Lemma compare_spec x y : CompareSpec (x==y) (x<y) (y<x) (x?=y).
Lemma compare_eq x y : (x ?= y) = Eq -> x==y.
Lemma compare_refl x : (x ?= x) = Eq.
Lemma compare_gt_iff x y : (x ?= y) = Gt <-> y<x.
Lemma compare_ge_iff x y : (x ?= y) <> Lt <-> y<=x.
Lemma compare_ngt_iff x y : (x ?= y) <> Gt <-> ~(y<x).
Lemma compare_nlt_iff x y : (x ?= y) <> Lt <-> ~(x<y).
Lemma compare_nle_iff x y : (x ?= y) = Gt <-> ~(x<=y).
Lemma compare_nge_iff x y : (x ?= y) = Lt <-> ~(y<=x).
Lemma lt_irrefl x : ~ (x<x).
Lemma lt_eq_cases n m : n <= m <-> n < m \/ n==m.
Lemma leb_spec0 x y : reflect (x<=y) (x<=?y).
Lemma leb_spec x y : BoolSpec (x<=y) (y<x) (x<=?y).
Lemma ltb_spec0 x y : reflect (x<y) (x<?y).
Lemma ltb_spec x y : BoolSpec (x<y) (y<=x) (x<?y).
Lemma leb_nle x y : x <=? y = false <-> ~ (x <= y).
Lemma leb_gt x y : x <=? y = false <-> y < x.
Lemma ltb_nlt x y : x <? y = false <-> ~ (x < y).
Lemma ltb_ge x y : x <? y = false <-> y <= x.
Lemma leb_refl x : x <=? x = true.
Lemma leb_antisym x y : y <=? x = negb (x <? y).
Lemma ltb_irrefl x : x <? x = false.
Lemma ltb_antisym x y : y <? x = negb (x <=? y).
Lemma eqb_compare x y : (x =? y) = match compare x y with Eq => true | _ => false end.
Lemma ltb_compare x y : (x <? y) = match compare x y with Lt => true | _ => false end.
Lemma leb_compare x y : (x <=? y) = match compare x y with Gt => false | _ => true end.
Lemma eq_dec : forall x y:positive, {x = y} + {x <> y}.
Lemma xI_succ_xO p : p~1 = succ p~0.
Lemma succ_discr p : p <> succ p.
Lemma pred_double_spec p : pred_double p = pred (p~0).
Lemma succ_pred_double p : succ (pred_double p) = p~0.
Lemma pred_double_succ p : pred_double (succ p) = p~1.
Lemma double_succ p : (succ p)~0 = succ (succ p~0).
Lemma pred_double_xO_discr p : pred_double p <> p~0.
Lemma succ_not_1 p : succ p <> 1.
Lemma pred_succ p : pred (succ p) = p.
Lemma succ_pred_or p : p = 1 \/ succ (pred p) = p.
Lemma succ_pred p : p <> 1 -> succ (pred p) = p.
Lemma succ_inj p q : succ p = succ q -> p = q.
Lemma pred_N_succ p : pred_N (succ p) = Npos p.
Lemma add_1_r p : p + 1 = succ p.
Lemma add_1_l p : 1 + p = succ p.
Lemma add_no_neutral p q : q + p <> p.
Lemma add_carry_add p q r s : add_carry p r = add_carry q s -> p + r = q + s.
Lemma add_reg_r p q r : p + r = q + r -> p = q.
Lemma add_reg_l p q r : p + q = p + r -> q = r.
Lemma add_cancel_r p q r : p + r = q + r <-> p = q.
Lemma add_cancel_l p q r : r + p = r + q <-> p = q.
Lemma add_carry_reg_r p q r : add_carry p r = add_carry q r -> p = q.
Lemma add_carry_reg_l p q r : add_carry p q = add_carry p r -> q = r.
Lemma add_xO p q : (p + q)~0 = p~0 + q~0.
Lemma add_xI_pred_double p q : (p + q)~0 = p~1 + pred_double q.
Lemma add_xO_pred_double p q : pred_double (p + q) = p~0 + pred_double q.
Lemma add_diag p : p + p = p~0.
Lemma peano_equiv (P:positive->Type) (a:P 1) (f:forall p, P p -> P (succ p)) p :  PeanoView_iter P a f p (peanoView p) = peano_rect P a f p.
Lemma mul_1_l p : 1 * p = p.
Lemma mul_1_r p : p * 1 = p.
Lemma mul_xO_r p q : p * q~0 = (p * q)~0.
Lemma mul_xI_r p q : p * q~1 = p + (p * q)~0.
Lemma mul_succ_l p q : (succ p) * q = q + p * q.
Lemma mul_succ_r p q : p * (succ q) = p + p * q.
Lemma mul_xI_mul_xO_discr p q r : p~1 * r <> q~0 * r.
Lemma mul_xO_discr p q : p~0 * q <> q.
Lemma mul_cancel_r p q r : p * r = q * r <-> p = q.
Lemma mul_cancel_l p q r : r * p = r * q <-> p = q.
Lemma mul_eq_1_l p q : p * q = 1 -> p = 1.
Lemma mul_eq_1_r p q : p * q = 1 -> q = 1.
Lemma square_xO p : p~0 * p~0 = (p*p)~0~0.
Lemma square_xI p : p~1 * p~1 = (p*p+p)~0~1.
Lemma iter_swap_gen : forall A B (f:A->B)(g:A->A)(h:B->B), (forall a, f (g a) = h (f a)) -> forall p a, f (iter p g a) = iter p h (f a).
Lemma pow_1_r p : p^1 = p.
Lemma pow_succ_r p q : p^(succ q) = p * p^q.
Lemma square_spec p : square p = p * p.
Lemma sub_mask_succ_r p q : sub_mask p (succ q) = sub_mask_carry p q.
Lemma sub_mask_add p q r : sub_mask p q = IsPos r -> q + r = p.
Lemma sub_mask_add_diag_l p q : sub_mask (p+q) p = IsPos q.
Lemma sub_mask_pos_iff p q r : sub_mask p q = IsPos r <-> q + r = p.
Lemma sub_mask_add_diag_r p q : sub_mask p (p+q) = IsNeg.
Lemma sub_mask_neg_iff p q : sub_mask p q = IsNeg <-> exists r, p + r = q.
Lemma compare_cont_spec p q c : compare_cont p q c = switch_Eq c (p ?= q).
Lemma compare_cont_Lt_Gt p q : compare_cont p q Lt = Gt <-> p > q.
Lemma compare_cont_Lt_Lt p q : compare_cont p q Lt = Lt <-> p <= q.
Lemma compare_cont_Gt_Lt p q : compare_cont p q Gt = Lt <-> p < q.
Lemma compare_cont_Gt_Gt p q : compare_cont p q Gt = Gt <-> p >= q.
Lemma compare_xO_xO p q : (p~0 ?= q~0) = (p ?= q).
Lemma compare_xI_xI p q : (p~1 ?= q~1) = (p ?= q).
Lemma compare_xI_xO p q : (p~1 ?= q~0) = switch_Eq Gt (p ?= q).
Lemma compare_xO_xI p q : (p~0 ?= q~1) = switch_Eq Lt (p ?= q).
Lemma compare_sub_mask p q : (p ?= q) = mask2cmp (sub_mask p q).
Lemma lt_iff_add p q : p < q <-> exists r, p + r = q.
Lemma gt_iff_add p q : p > q <-> exists r, q + r = p.
Lemma compare_cont_antisym p q c : CompOpp (compare_cont p q c) = compare_cont q p (CompOpp c).
Lemma compare_eq_iff p q : (p ?= q) = Eq <-> p = q.
Lemma compare_antisym p q : (q ?= p) = CompOpp (p ?= q).
Lemma compare_lt_iff p q : (p ?= q) = Lt <-> p < q.
Lemma compare_le_iff p q : (p ?= q) <> Gt <-> p <= q.
Lemma gt_lt_iff p q : p > q <-> q < p.
Lemma gt_lt p q : p > q -> q < p.
Lemma lt_gt p q : p < q -> q > p.
Lemma ge_le_iff p q : p >= q <-> q <= p.
Lemma ge_le p q : p >= q -> q <= p.
Lemma le_ge p q : p <= q -> q >= p.
Lemma compare_succ_r p q : switch_Eq Gt (p ?= succ q) = switch_Eq Lt (p ?= q).
Lemma compare_succ_l p q : switch_Eq Lt (succ p ?= q) = switch_Eq Gt (p ?= q).
Lemma lt_succ_diag_r p : p < succ p.
Lemma compare_succ_succ p q : (succ p ?= succ q) = (p ?= q).
Lemma le_1_l p : 1 <= p.
Lemma nlt_1_r p : ~ p < 1.
Lemma lt_1_succ p : 1 < succ p.
Lemma le_nlt p q : p <= q <-> ~ q < p.
Lemma lt_nle p q : p < q <-> ~ q <= p.
Lemma lt_le_incl p q : p<q -> p<=q.
Lemma lt_lt_succ n m : n < m -> n < succ m.
Lemma succ_lt_mono n m : n < m <-> succ n < succ m.
Lemma succ_le_mono n m : n <= m <-> succ n <= succ m.
Lemma lt_trans n m p : n < m -> m < p -> n < p.
Lemma lt_total p q : p < q \/ p = q \/ q < p.
Lemma le_refl p : p <= p.
Lemma le_lt_trans n m p : n <= m -> m < p -> n < p.
Lemma lt_le_trans n m p : n < m -> m <= p -> n < p.
Lemma le_trans n m p : n <= m -> m <= p -> n <= p.
Lemma le_succ_l n m : succ n <= m <-> n < m.
Lemma le_antisym p q : p <= q -> q <= p -> p = q.
Lemma add_compare_mono_l p q r : (p+q ?= p+r) = (q ?= r).
Lemma add_compare_mono_r p q r : (q+p ?= r+p) = (q ?= r).
Lemma lt_add_diag_r p q : p < p + q.
Lemma add_lt_mono_l p q r : q<r <-> p+q < p+r.
Lemma add_lt_mono_r p q r : q<r <-> q+p < r+p.
Lemma add_lt_mono p q r s : p<q -> r<s -> p+r<q+s.
Lemma add_le_mono_l p q r : q<=r <-> p+q<=p+r.
Lemma add_le_mono_r p q r : q<=r <-> q+p<=r+p.
Lemma add_le_mono p q r s : p<=q -> r<=s -> p+r <= q+s.
Lemma mul_compare_mono_l p q r : (p*q ?= p*r) = (q ?= r).
Lemma mul_compare_mono_r p q r : (q*p ?= r*p) = (q ?= r).
Lemma mul_lt_mono_l p q r : q<r <-> p*q < p*r.
Lemma mul_lt_mono_r p q r : q<r <-> q*p < r*p.
Lemma mul_lt_mono p q r s : p<q -> r<s -> p*r < q*s.
Lemma mul_le_mono_l p q r : q<=r <-> p*q<=p*r.
Lemma mul_le_mono_r p q r : q<=r <-> q*p<=r*p.
Lemma mul_le_mono p q r s : p<=q -> r<=s -> p*r <= q*s.
Lemma lt_add_r p q : p < p+q.
Lemma lt_not_add_l p q : ~ p+q < p.
Lemma pow_gt_1 n p : 1<n -> 1<n^p.
Lemma sub_1_r p : sub p 1 = pred p.
Lemma pred_sub p : pred p = sub p 1.
Lemma sub_mask_pos' p q : q < p -> exists r, sub_mask p q = IsPos r /\ q + r = p.
Lemma sub_mask_pos p q : q < p -> exists r, sub_mask p q = IsPos r.
Lemma add_sub p q : (p+q)-q = p.
Lemma mul_sub_distr_l p q r : r<q -> p*(q-r) = p*q-p*r.
Lemma mul_sub_distr_r p q r : q<p -> (p-q)*r = p*r-q*r.
Lemma sub_lt_mono_l p q r: q<p -> p<r -> r-p < r-q.
Lemma sub_compare_mono_l p q r : q<p -> r<p -> (p-q ?= p-r) = (r ?= q).
Lemma sub_compare_mono_r p q r : p<q -> p<r -> (q-p ?= r-p) = (q ?= r).
Lemma sub_lt_mono_r p q r : q<p -> r<q -> q-r < p-r.
Lemma sub_decr n m : m<n -> n-m < n.
Lemma add_sub_assoc p q r : r<q -> p+(q-r) = p+q-r.
Lemma sub_add_distr p q r : q+r < p -> p-(q+r) = p-q-r.
Lemma sub_sub_distr p q r : r<q -> q-r < p -> p-(q-r) = p+r-q.
Lemma sub_xO_xO n m : m<n -> n~0 - m~0 = (n-m)~0.
Lemma sub_xI_xI n m : m<n -> n~1 - m~1 = (n-m)~0.
Lemma sub_xI_xO n m : m<n -> n~1 - m~0 = (n-m)~1.
Lemma sub_xO_xI n m : n~0 - m~1 = pred_double (n-m).
Lemma sub_mask_neg_iff' p q : sub_mask p q = IsNeg <-> p < q.
Lemma sub_mask_neg p q : p<q -> sub_mask p q = IsNeg.
Lemma sub_le p q : p<=q -> p-q = 1.
Lemma sub_lt p q : p<q -> p-q = 1.
Lemma sub_diag p : p-p = 1.
Lemma size_nat_monotone p q : p<q -> (size_nat p <= size_nat q)%nat.
Lemma size_gt p : p < 2^(size p).
Lemma size_le p : 2^(size p) <= p~0.
Lemma max_l : forall x y, y<=x -> max x y = x.
Lemma max_r : forall x y, x<=y -> max x y = y.
Lemma min_l : forall x y, x<=y -> min x y = x.
Lemma min_r : forall x y, y<=x -> min x y = y.
Lemma max_1_l n : max 1 n = n.
Lemma max_1_r n : max n 1 = n.
Lemma min_1_l n : min 1 n = 1.
Lemma min_1_r n : min n 1 = 1.
Lemma succ_max_distr n m : succ (max n m) = max (succ n) (succ m).
Lemma succ_min_distr n m : succ (min n m) = min (succ n) (succ m).
Lemma add_max_distr_l n m p : max (p + n) (p + m) = p + max n m.
Lemma add_max_distr_r n m p : max (n + p) (m + p) = max n m + p.
Lemma add_min_distr_l n m p : min (p + n) (p + m) = p + min n m.
Lemma add_min_distr_r n m p : min (n + p) (m + p) = min n m + p.
Lemma mul_max_distr_l n m p : max (p * n) (p * m) = p * max n m.
Lemma mul_max_distr_r n m p : max (n * p) (m * p) = max n m * p.
Lemma mul_min_distr_l n m p : min (p * n) (p * m) = p * min n m.
Lemma mul_min_distr_r n m p : min (n * p) (m * p) = min n m * p.
Lemma iter_op_succ : forall A (op:A->A->A), (forall x y z, op x (op y z) = op (op x y) z) -> forall p a, iter_op op (succ p) a = op a (iter_op op p a).
Lemma of_nat_succ (n:nat) : of_succ_nat n = of_nat (S n).
Lemma pred_of_succ_nat (n:nat) : pred (of_succ_nat n) = of_nat n.
Lemma succ_of_nat (n:nat) : n<>O -> succ (of_nat n) = of_succ_nat n.
Lemma sqrtrem_step_spec f g p x : (f=xO \/ f=xI) -> (g=xO \/ g=xI) -> SqrtSpec p x -> SqrtSpec (sqrtrem_step f g p) (g (f x)).
Lemma sqrtrem_spec p : SqrtSpec (sqrtrem p) p.
Lemma sqrt_spec p : let s := sqrt p in s*s <= p < (succ s)*(succ s).
Lemma divide_add_cancel_l p q r : (p | r) -> (p | q + r) -> (p | q).
Lemma divide_xO_xI p q r : (p | q~0) -> (p | r~1) -> (p | q).
Lemma divide_xO_xO p q : (p~0|q~0) <-> (p|q).
Lemma divide_mul_l p q r : (p|q) -> (p|q*r).
Lemma divide_mul_r p q r : (p|r) -> (p|q*r).
Lemma ggcdn_gcdn : forall n a b, fst (ggcdn n a b) = gcdn n a b.
Lemma ggcd_gcd : forall a b, fst (ggcd a b) = gcd a b.
Lemma ggcdn_correct_divisors : forall n a b, let '(g,(aa,bb)) := ggcdn n a b in a = g*aa /\ b = g*bb.
Lemma ggcd_correct_divisors : forall a b, let '(g,(aa,bb)) := ggcd a b in a=g*aa /\ b=g*bb.
Lemma gcd_divide_l : forall a b, (gcd a b | a).
Lemma gcd_divide_r : forall a b, (gcd a b | b).
Lemma gcdn_greatest : forall n a b, (size_nat a + size_nat b <= n)%nat -> forall p, (p|a) -> (p|b) -> (p|gcdn n a b).
Lemma gcd_greatest : forall a b p, (p|a) -> (p|b) -> (p|gcd a b).
Lemma ggcd_greatest : forall a b, let (aa,bb) := snd (ggcd a b) in forall p, (p|aa) -> (p|bb) -> p=1.
Lemma Peqb_true_eq x y : Pos.eqb x y = true -> x=y.
Lemma Pcompare_eq_Gt p q : (p ?= q) = Gt <-> p > q.
Lemma Pplus_one_succ_r p : Pos.succ p = p + 1.
Lemma Pplus_one_succ_l p : Pos.succ p = 1 + p.
Lemma Pcompare_refl p : Pos.compare_cont p p Eq = Eq.
Lemma Pcompare_Eq_eq : forall p q, Pos.compare_cont p q Eq = Eq -> p = q.
Lemma ZC4 p q : Pos.compare_cont p q Eq = CompOpp (Pos.compare_cont q p Eq).
Lemma Ppred_minus p : Pos.pred p = p - 1.
Lemma Pminus_mask_Gt p q : p > q -> exists h : positive,  Pos.sub_mask p q = IsPos h /\
Lemma Pplus_minus : forall p q, p > q -> q+(p-q) = p.
Lemma Dcompare : forall r:comparison, r = Eq \/ r = Lt \/ r = Gt.
Lemma Strict_Rel_Transitive_with_Rel :   forall x y z:U,     Strict_Rel_of U D x y -> Rel_of U D y z -> Strict_Rel_of U D x z.
Lemma Strict_Rel_Transitive_with_Rel_left :   forall x y z:U,     Rel_of U D x y -> Strict_Rel_of U D y z -> Strict_Rel_of U D x z.
Lemma Strict_Rel_Transitive : Transitive U (Strict_Rel_of U D).
Lemma Rmax_l : forall x y, y<=x -> Rmax x y = x.
Lemma Rmax_r : forall x y, x<=y -> Rmax x y = y.
Lemma Rmin_l : forall x y, x<=y -> Rmin x y = x.
Lemma Rmin_r : forall x y, y<=x -> Rmin x y = y.
Lemma plus_max_distr_l : forall n m p, Rmax (p + n) (p + m) = p + Rmax n m.
Lemma plus_max_distr_r : forall n m p, Rmax (n + p) (m + p) = Rmax n m + p.
Lemma plus_min_distr_l : forall n m p, Rmin (p + n) (p + m) = p + Rmin n m.
Lemma plus_min_distr_r : forall n m p, Rmin (n + p) (m + p) = Rmin n m + p.
Lemma opp_max_distr : forall n m : R, -(Rmax n m) = Rmin (- n) (- m).
Lemma opp_min_distr : forall n m : R, - (Rmin n m) = Rmax (- n) (- m).
Lemma minus_max_distr_l : forall n m p, Rmax (p - n) (p - m) = p - Rmin n m.
Lemma minus_max_distr_r : forall n m p, Rmax (n - p) (m - p) = Rmax n m - p.
Lemma minus_min_distr_l : forall n m p, Rmin (p - n) (p - m) = p - Rmax n m.
Lemma minus_min_distr_r : forall n m p, Rmin (n - p) (m - p) = Rmin n m - p.
Lemma nat_N_Z n : Z.of_N (N.of_nat n) = Z.of_nat n.
Lemma N_nat_Z n : Z.of_nat (N.to_nat n) = Z.of_N n.
Lemma positive_nat_Z p : Z.of_nat (Pos.to_nat p) = Zpos p.
Lemma positive_N_Z p : Z.of_N (Npos p) = Zpos p.
Lemma positive_N_nat p : N.to_nat (Npos p) = Pos.to_nat p.
Lemma positive_nat_N p : N.of_nat (Pos.to_nat p) = Npos p.
Lemma Z_N_nat n : N.to_nat (Z.to_N n) = Z.to_nat n.
Lemma Z_nat_N n : N.of_nat (Z.to_nat n) = Z.to_N n.
Lemma Zabs_N_nat n : N.to_nat (Z.abs_N n) = Z.abs_nat n.
Lemma Zabs_nat_N n : N.of_nat (Z.abs_nat n) = Z.abs_N n.
Lemma id n : Z.to_N (Z.of_N n) = n.
Lemma inj n m : Z.of_N n = Z.of_N m -> n = m.
Lemma inj_iff n m : Z.of_N n = Z.of_N m <-> n = m.
Lemma is_nonneg n : 0 <= Z.of_N n.
Lemma inj_0 : Z.of_N 0 = 0.
Lemma inj_pos p : Z.of_N (Npos p) = Zpos p.
Lemma inj_compare n m : (Z.of_N n ?= Z.of_N m) = (n ?= m)%N.
Lemma inj_le n m : (n<=m)%N <-> Z.of_N n <= Z.of_N m.
Lemma inj_lt n m : (n<m)%N <-> Z.of_N n < Z.of_N m.
Lemma inj_ge n m : (n>=m)%N <-> Z.of_N n >= Z.of_N m.
Lemma inj_gt n m : (n>m)%N <-> Z.of_N n > Z.of_N m.
Lemma inj_abs_N z : Z.of_N (Z.abs_N z) = Z.abs z.
Lemma inj_add n m : Z.of_N (n+m) = Z.of_N n + Z.of_N m.
Lemma inj_mul n m : Z.of_N (n*m) = Z.of_N n * Z.of_N m.
Lemma inj_sub_max n m : Z.of_N (n-m) = Z.max 0 (Z.of_N n - Z.of_N m).
Lemma inj_sub n m : (m<=n)%N -> Z.of_N (n-m) = Z.of_N n - Z.of_N m.
Lemma inj_succ n : Z.of_N (N.succ n) = Z.succ (Z.of_N n).
Lemma inj_pred_max n : Z.of_N (N.pred n) = Z.max 0 (Z.pred (Z.of_N n)).
Lemma inj_pred n : (0<n)%N -> Z.of_N (N.pred n) = Z.pred (Z.of_N n).
Lemma inj_min n m : Z.of_N (N.min n m) = Z.min (Z.of_N n) (Z.of_N m).
Lemma inj_max n m : Z.of_N (N.max n m) = Z.max (Z.of_N n) (Z.of_N m).
Lemma inj_div n m : Z.of_N (n/m) = Z.of_N n / Z.of_N m.
Lemma inj_mod n m : (m<>0)%N -> Z.of_N (n mod m) = (Z.of_N n) mod (Z.of_N m).
Lemma inj_quot n m : Z.of_N (n/m) = Z.of_N n ÷ Z.of_N m.
Lemma inj_rem n m : Z.of_N (n mod m) = Z.rem (Z.of_N n) (Z.of_N m).
Lemma inj_div2 n : Z.of_N (N.div2 n) = Z.div2 (Z.of_N n).
Lemma inj_quot2 n : Z.of_N (N.div2 n) = Z.quot2 (Z.of_N n).
Lemma inj_pow n m : Z.of_N (n^m) = (Z.of_N n)^(Z.of_N m).
Lemma inj_testbit a n : Z.testbit (Z.of_N a) (Z.of_N n) = N.testbit a n.
Lemma id n : 0<=n -> Z.of_N (Z.to_N n) = n.
Lemma inj n m : 0<=n -> 0<=m -> Z.to_N n = Z.to_N m -> n = m.
Lemma inj_iff n m : 0<=n -> 0<=m -> (Z.to_N n = Z.to_N m <-> n = m).
Lemma inj_0 : Z.to_N 0 = 0%N.
Lemma inj_pos n : Z.to_N (Zpos n) = Npos n.
Lemma inj_neg n : Z.to_N (Zneg n) = 0%N.
Lemma inj_add n m : 0<=n -> 0<=m -> Z.to_N (n+m) = (Z.to_N n + Z.to_N m)%N.
Lemma inj_mul n m : 0<=n -> 0<=m -> Z.to_N (n*m) = (Z.to_N n * Z.to_N m)%N.
Lemma inj_succ n : 0<=n -> Z.to_N (Z.succ n) = N.succ (Z.to_N n).
Lemma inj_sub n m : 0<=m -> Z.to_N (n - m) = (Z.to_N n - Z.to_N m)%N.
Lemma inj_pred n : Z.to_N (Z.pred n) = N.pred (Z.to_N n).
Lemma inj_compare n m : 0<=n -> 0<=m -> (Z.to_N n ?= Z.to_N m)%N = (n ?= m).
Lemma inj_le n m : 0<=n -> 0<=m -> (n<=m <-> (Z.to_N n <= Z.to_N m)%N).
Lemma inj_lt n m : 0<=n -> 0<=m -> (n<m <-> (Z.to_N n < Z.to_N m)%N).
Lemma inj_min n m : Z.to_N (Z.min n m) = N.min (Z.to_N n) (Z.to_N m).
Lemma inj_max n m : Z.to_N (Z.max n m) = N.max (Z.to_N n) (Z.to_N m).
Lemma inj_div n m : 0<=n -> 0<=m -> Z.to_N (n/m) = (Z.to_N n / Z.to_N m)%N.
Lemma inj_mod n m : 0<=n -> 0<m -> Z.to_N (n mod m) = ((Z.to_N n) mod (Z.to_N m))%N.
Lemma inj_quot n m : 0<=n -> 0<=m -> Z.to_N (n÷m) = (Z.to_N n / Z.to_N m)%N.
Lemma inj_rem n m :0<=n -> 0<=m -> Z.to_N (Z.rem n m) = ((Z.to_N n) mod (Z.to_N m))%N.
Lemma inj_div2 n : Z.to_N (Z.div2 n) = N.div2 (Z.to_N n).
Lemma inj_quot2 n : Z.to_N (Z.quot2 n) = N.div2 (Z.to_N n).
Lemma inj_pow n m : 0<=n -> 0<=m -> Z.to_N (n^m) = ((Z.to_N n)^(Z.to_N m))%N.
Lemma inj_testbit a n : 0<=n -> Z.testbit (Z.of_N a) n = N.testbit a (Z.to_N n).
Lemma abs_N_spec n : Z.abs_N n = Z.to_N (Z.abs n).
Lemma abs_N_nonneg n : 0<=n -> Z.abs_N n = Z.to_N n.
Lemma id_abs n : Z.of_N (Z.abs_N n) = Z.abs n.
Lemma id n : Z.abs_N (Z.of_N n) = n.
Lemma inj_0 : Z.abs_N 0 = 0%N.
Lemma inj_pos p : Z.abs_N (Zpos p) = Npos p.
Lemma inj_neg p : Z.abs_N (Zneg p) = Npos p.
Lemma inj_opp n : Z.abs_N (-n) = Z.abs_N n.
Lemma inj_succ n : 0<=n -> Z.abs_N (Z.succ n) = N.succ (Z.abs_N n).
Lemma inj_add n m : 0<=n -> 0<=m -> Z.abs_N (n+m) = (Z.abs_N n + Z.abs_N m)%N.
Lemma inj_mul n m : Z.abs_N (n*m) = (Z.abs_N n * Z.abs_N m)%N.
Lemma inj_sub n m : 0<=m<=n -> Z.abs_N (n-m) = (Z.abs_N n - Z.abs_N m)%N.
Lemma inj_pred n : 0<n -> Z.abs_N (Z.pred n) = N.pred (Z.abs_N n).
Lemma inj_compare n m : 0<=n -> 0<=m -> (Z.abs_N n ?= Z.abs_N m)%N = (n ?= m).
Lemma inj_le n m : 0<=n -> 0<=m -> (n<=m <-> (Z.abs_N n <= Z.abs_N m)%N).
Lemma inj_lt n m : 0<=n -> 0<=m -> (n<m <-> (Z.abs_N n < Z.abs_N m)%N).
Lemma inj_min n m : 0<=n -> 0<=m -> Z.abs_N (Z.min n m) = N.min (Z.abs_N n) (Z.abs_N m).
Lemma inj_max n m : 0<=n -> 0<=m -> Z.abs_N (Z.max n m) = N.max (Z.abs_N n) (Z.abs_N m).
Lemma inj_quot n m : Z.abs_N (n÷m) = ((Z.abs_N n) / (Z.abs_N m))%N.
Lemma inj_rem n m : Z.abs_N (Z.rem n m) = ((Z.abs_N n) mod (Z.abs_N m))%N.
Lemma inj_pow n m : 0<=m -> Z.abs_N (n^m) = ((Z.abs_N n)^(Z.abs_N m))%N.
Lemma inj_succ_abs n : Z.abs_N (Z.succ (Z.abs n)) = N.succ (Z.abs_N n).
Lemma inj_add_abs n m : Z.abs_N (Z.abs n + Z.abs m) = (Z.abs_N n + Z.abs_N m)%N.
Lemma inj_mul_abs n m : Z.abs_N (Z.abs n * Z.abs m) = (Z.abs_N n * Z.abs_N m)%N.
Lemma inj_0 : Z.of_nat 0 = 0.
Lemma inj_succ n : Z.of_nat (S n) = Z.succ (Z.of_nat n).
Lemma is_nonneg n : 0 <= Z.of_nat n.
Lemma id n : Z.to_nat (Z.of_nat n) = n.
Lemma inj n m : Z.of_nat n = Z.of_nat m -> n = m.
Lemma inj_iff n m : Z.of_nat n = Z.of_nat m <-> n = m.
Lemma inj_compare n m : (Z.of_nat n ?= Z.of_nat m) = nat_compare n m.
Lemma inj_le n m : (n<=m)%nat <-> Z.of_nat n <= Z.of_nat m.
Lemma inj_lt n m : (n<m)%nat <-> Z.of_nat n < Z.of_nat m.
Lemma inj_ge n m : (n>=m)%nat <-> Z.of_nat n >= Z.of_nat m.
Lemma inj_gt n m : (n>m)%nat <-> Z.of_nat n > Z.of_nat m.
Lemma inj_abs_nat z : Z.of_nat (Z.abs_nat z) = Z.abs z.
Lemma inj_add n m : Z.of_nat (n+m) = Z.of_nat n + Z.of_nat m.
Lemma inj_mul n m : Z.of_nat (n*m) = Z.of_nat n * Z.of_nat m.
Lemma inj_sub_max n m : Z.of_nat (n-m) = Z.max 0 (Z.of_nat n - Z.of_nat m).
Lemma inj_sub n m : (m<=n)%nat -> Z.of_nat (n-m) = Z.of_nat n - Z.of_nat m.
Lemma inj_pred_max n : Z.of_nat (pred n) = Z.max 0 (Z.pred (Z.of_nat n)).
Lemma inj_pred n : (0<n)%nat -> Z.of_nat (pred n) = Z.pred (Z.of_nat n).
Lemma inj_min n m : Z.of_nat (min n m) = Z.min (Z.of_nat n) (Z.of_nat m).
Lemma inj_max n m : Z.of_nat (max n m) = Z.max (Z.of_nat n) (Z.of_nat m).
Lemma id n : 0<=n -> Z.of_nat (Z.to_nat n) = n.
Lemma inj n m : 0<=n -> 0<=m -> Z.to_nat n = Z.to_nat m -> n = m.
Lemma inj_iff n m : 0<=n -> 0<=m -> (Z.to_nat n = Z.to_nat m <-> n = m).
Lemma inj_0 : Z.to_nat 0 = O.
Lemma inj_pos n : Z.to_nat (Zpos n) = Pos.to_nat n.
Lemma inj_neg n : Z.to_nat (Zneg n) = O.
Lemma inj_add n m : 0<=n -> 0<=m -> Z.to_nat (n+m) = (Z.to_nat n + Z.to_nat m)%nat.
Lemma inj_mul n m : 0<=n -> 0<=m -> Z.to_nat (n*m) = (Z.to_nat n * Z.to_nat m)%nat.
Lemma inj_succ n : 0<=n -> Z.to_nat (Z.succ n) = S (Z.to_nat n).
Lemma inj_sub n m : 0<=m -> Z.to_nat (n - m) = (Z.to_nat n - Z.to_nat m)%nat.
Lemma inj_pred n : Z.to_nat (Z.pred n) = pred (Z.to_nat n).
Lemma inj_compare n m : 0<=n -> 0<=m -> nat_compare (Z.to_nat n) (Z.to_nat m) = (n ?= m).
Lemma inj_le n m : 0<=n -> 0<=m -> (n<=m <-> (Z.to_nat n <= Z.to_nat m)%nat).
Lemma inj_lt n m : 0<=n -> 0<=m -> (n<m <-> (Z.to_nat n < Z.to_nat m)%nat).
Lemma inj_min n m : Z.to_nat (Z.min n m) = min (Z.to_nat n) (Z.to_nat m).
Lemma inj_max n m : Z.to_nat (Z.max n m) = max (Z.to_nat n) (Z.to_nat m).
Lemma abs_nat_spec n : Z.abs_nat n = Z.to_nat (Z.abs n).
Lemma abs_nat_nonneg n : 0<=n -> Z.abs_nat n = Z.to_nat n.
Lemma id_abs n : Z.of_nat (Z.abs_nat n) = Z.abs n.
Lemma id n : Z.abs_nat (Z.of_nat n) = n.
Lemma inj_0 : Z.abs_nat 0 = 0%nat.
Lemma inj_pos p : Z.abs_nat (Zpos p) = Pos.to_nat p.
Lemma inj_neg p : Z.abs_nat (Zneg p) = Pos.to_nat p.
Lemma inj_succ n : 0<=n -> Z.abs_nat (Z.succ n) = S (Z.abs_nat n).
Lemma inj_add n m : 0<=n -> 0<=m -> Z.abs_nat (n+m) = (Z.abs_nat n + Z.abs_nat m)%nat.
Lemma inj_mul n m : Z.abs_nat (n*m) = (Z.abs_nat n * Z.abs_nat m)%nat.
Lemma inj_sub n m : 0<=m<=n -> Z.abs_nat (n-m) = (Z.abs_nat n - Z.abs_nat m)%nat.
Lemma inj_pred n : 0<n -> Z.abs_nat (Z.pred n) = pred (Z.abs_nat n).
Lemma inj_compare n m : 0<=n -> 0<=m -> nat_compare (Z.abs_nat n) (Z.abs_nat m) = (n ?= m).
Lemma inj_le n m : 0<=n -> 0<=m -> (n<=m <-> (Z.abs_nat n <= Z.abs_nat m)%nat).
Lemma inj_lt n m : 0<=n -> 0<=m -> (n<m <-> (Z.abs_nat n < Z.abs_nat m)%nat).
Lemma inj_min n m : 0<=n -> 0<=m -> Z.abs_nat (Z.min n m) = min (Z.abs_nat n) (Z.abs_nat m).
Lemma inj_max n m : 0<=n -> 0<=m -> Z.abs_nat (Z.max n m) = max (Z.abs_nat n) (Z.abs_nat m).
Lemma inj_succ_abs n : Z.abs_nat (Z.succ (Z.abs n)) = S (Z.abs_nat n).
Lemma inj_add_abs n m : Z.abs_nat (Z.abs n + Z.abs m) = (Z.abs_nat n + Z.abs_nat m)%nat.
Lemma inj_mul_abs n m : Z.abs_nat (Z.abs n * Z.abs m) = (Z.abs_nat n * Z.abs_nat m)%nat.
Lemma inj_neq n m : neq n m -> Zne (Z.of_nat n) (Z.of_nat m).
Lemma Zpos_P_of_succ_nat n : Zpos (Pos.of_succ_nat n) = Z.succ (Z.of_nat n).
Lemma sub_add_opp : forall n m, Z.sub n m = Z.add n (Z.opp m).
Lemma mul_comm : forall n m, n*m == m*n.
Lemma lt_eq_cases : forall n m, n<=m <-> n<m \/ n==m.
Lemma PermutationA_app_head l₁ l₂ l : PermutationA l₁ l₂ -> PermutationA (l ++ l₁) (l ++ l₂).
Lemma PermutationA_app_tail l₁ l₂ l : PermutationA l₁ l₂ -> PermutationA (l₁ ++ l) (l₂ ++ l).
Lemma PermutationA_cons_append l x : PermutationA (x :: l) (l ++ x :: nil).
Lemma PermutationA_app_comm l₁ l₂ : PermutationA (l₁ ++ l₂) (l₂ ++ l₁).
Lemma PermutationA_cons_app l l₁ l₂ x : PermutationA l (l₁ ++ l₂) -> PermutationA (x :: l) (l₁ ++ x :: l₂).
Lemma PermutationA_middle l₁ l₂ x : PermutationA (x :: l₁ ++ l₂) (l₁ ++ x :: l₂).
Lemma PermutationA_equivlistA l₁ l₂ : PermutationA l₁ l₂ -> equivlistA eqA l₁ l₂.
Lemma NoDupA_equivlistA_PermutationA l₁ l₂ : NoDupA eqA l₁ -> NoDupA eqA l₂ ->  equivlistA eqA l₁ l₂ -> PermutationA l₁ l₂.
Lemma max_0_l : forall n, max 0 n == n.
Lemma max_0_r : forall n, max n 0 == n.
Lemma min_0_l : forall n, min 0 n == 0.
Lemma min_0_r : forall n, min n 0 == 0.
Lemma succ_max_distr : forall n m, S (max n m) == max (S n) (S m).
Lemma succ_min_distr : forall n m, S (min n m) == min (S n) (S m).
Lemma add_max_distr_l : forall n m p, max (p + n) (p + m) == p + max n m.
Lemma add_max_distr_r : forall n m p, max (n + p) (m + p) == max n m + p.
Lemma add_min_distr_l : forall n m p, min (p + n) (p + m) == p + min n m.
Lemma add_min_distr_r : forall n m p, min (n + p) (m + p) == min n m + p.
Lemma mul_max_distr_l : forall n m p, max (p * n) (p * m) == p * max n m.
Lemma mul_max_distr_r : forall n m p, max (n * p) (m * p) == max n m * p.
Lemma mul_min_distr_l : forall n m p, min (p * n) (p * m) == p * min n m.
Lemma mul_min_distr_r : forall n m p, min (n * p) (m * p) == min n m * p.
Lemma sub_max_distr_l : forall n m p, max (p - n) (p - m) == p - min n m.
Lemma sub_max_distr_r : forall n m p, max (n - p) (m - p) == max n m - p.
Lemma sub_min_distr_l : forall n m p, min (p - n) (p - m) == p - max n m.
Lemma sub_min_distr_r : forall n m p, min (n - p) (m - p) == min n m - p.
Lemma compare_spec : forall x y, CompareSpec (x==y) (x<y) (y<x) (compare x y).
Lemma le_lteq : forall x y, x<=y <-> x<y \/ x==y.
Lemma lt_total : forall x y, x<y \/ x==y \/ y<x.
Lemma eqb_eq : forall x y, eq_bool x y = true <-> x == y.
Lemma eqb_correct : forall x y, eq_bool x y = true -> x == y.
Lemma eqb_complete : forall x y, x == y -> eq_bool x y = true.
Lemma max_l : forall x y, y<=x -> max x y == x.
Lemma max_r : forall x y, x<=y -> max x y == y.
Lemma min_l : forall x y, x<=y -> min x y == x.
Lemma min_r : forall x y, y<=x -> min x y == y.
Lemma add_0_l : forall x, 0+x == x.
Lemma add_comm : forall x y, x+y == y+x.
Lemma add_assoc : forall x y z, x+(y+z) == x+y+z.
Lemma mul_1_l : forall x, 1*x == x.
Lemma mul_comm : forall x y, x*y == y*x.
Lemma mul_assoc : forall x y z, x*(y*z) == x*y*z.
Lemma mul_add_distr_r : forall x y z, (x+y)*z == x*z + y*z.
Lemma sub_add_opp : forall x y, x-y == x+(-y).
Lemma add_opp_diag_r : forall x, x+(-x) == 0.
Lemma neq_1_0 : 1!=0.
Lemma div_mul_inv : forall x y, x/y == x*(/y).
Lemma mul_inv_diag_l : forall x, x!=0 -> /x * x == 1.
Lemma gt_S_n : forall n m, S m > S n -> m > n.
Lemma gt_pred : forall n m, m > S n -> pred m > n.
Lemma gt_irrefl : forall n, ~ n > n.
Lemma gt_asym : forall n m, n > m -> ~ m > n.
Lemma le_not_gt : forall n m, n <= m -> ~ n > m.
Lemma gt_not_le : forall n m, n > m -> ~ n <= m.
Lemma gt_S_le : forall n m, S m > n -> n <= m.
Lemma gt_le_S : forall n m, m > n -> S n <= m.
Lemma le_gt_S : forall n m, n <= m -> S m > n.
Lemma gt_trans : forall n m p, n > m -> m > p -> n > p.
Lemma plus_gt_reg_l : forall n m p, p + n > p + m -> n > m.
Lemma plus_gt_compat_l : forall n m p, n > m -> p + n > p + m.
Lemma sum_maj1 : forall (fn:nat -> R -> R) (An:nat -> R) (x l1 l2:R)   (N:nat),   Un_cv (fun n:nat => SP fn n x) l1 ->   Un_cv (fun n:nat => sum_f_R0 An n) l2 ->   (forall n:nat, Rabs (fn n x) <= An n) ->   Rabs (l1 - SP fn N x) <= l2 - sum_f_R0 An N.
Lemma Rseries_CV_comp : forall An Bn:nat -> R,   (forall n:nat, 0 <= An n <= Bn n) ->   { l:R | Un_cv (fun N:nat => sum_f_R0 Bn N) l } ->   { l:R | Un_cv (fun N:nat => sum_f_R0 An N) l }.
Lemma Cesaro : forall (An Bn:nat -> R) (l:R),   Un_cv Bn l ->   (forall n:nat, 0 < An n) ->   cv_infty (fun n:nat => sum_f_R0 An n) ->   Un_cv (fun n:nat => sum_f_R0 (fun k:nat => An k * Bn k) n / sum_f_R0 An n)   l.
Lemma Cesaro_1 : forall (An:nat -> R) (l:R),   Un_cv An l -> Un_cv (fun n:nat => sum_f_R0 An (pred n) / INR n) l.
Lemma Zabs_ind : forall (P:Z -> Prop) (n:Z),   (n >= 0 -> P n) -> (n <= 0 -> P (- n)) -> P (Z.abs n).
Lemma Zabs_spec x : 0 <= x /\ Z.abs x = x \/
Lemma Zsgn_spec x : 0 < x /\ Z.sgn x = 1 \/
Lemma Zabs_nat_le n m : 0 <= n <= m -> (Z.abs_nat n <= Z.abs_nat m)%nat.
Lemma Zabs_nat_lt n m : 0 <= n < m -> (Z.abs_nat n < Z.abs_nat m)%nat.
Lemma In_In : forall s x, M.In x s <-> In _ (!!s) x.
Lemma Subset_Included : forall s s',  s[<=]s'  <-> Included _ (!!s) (!!s').
Lemma Equal_Same_set : forall s s', s[=]s' <-> !!s === !!s'.
Lemma empty_Empty_Set : !!M.empty === Empty_set _.
Lemma Empty_Empty_set : forall s, Empty s -> !!s === Empty_set _.
Lemma singleton_Singleton : forall x, !!(M.singleton x) === Singleton _ x .
Lemma union_Union : forall s s', !!(union s s') === Union _ (!!s) (!!s').
Lemma inter_Intersection : forall s s', !!(inter s s') === Intersection _ (!!s) (!!s').
Lemma add_Add : forall x s, !!(add x s) === Add _ (!!s) x.
Lemma Add_Add : forall x s s', MP.Add x s s' -> !!s' === Add _ (!!s) x.
Lemma remove_Subtract : forall x s, !!(remove x s) === Subtract _ (!!s) x.
Lemma mkEns_Finite : forall s, Finite _ (!!s).
Lemma mkEns_cardinal : forall s, cardinal _ (!!s) (M.cardinal s).
Lemma Ens_to_FSet : forall e : Ensemble M.elt, Finite _ e ->
Lemma sub_le_mono_r : forall n m p, n <= m -> n-p <= m-p.
Lemma sub_le_mono_l : forall n m p, n <= m -> p-m <= p-n.
Lemma le_equiv : forall n m, le_alt n m <-> n <= m.
Lemma lt_equiv : forall n m, lt_alt n m <-> n < m.
Lemma in_inv : forall (a b:A) (l:list A), In b (a :: l) -> a = b \/ In b l.
Lemma app_inj_tail :   forall (x y:list A) (a b:A), x ++ [a] = y ++ [b] -> x = y /\ a = b.
Lemma app_length : forall l l' : list A, length (l++l') = length l + length l'.
Lemma in_app_or : forall (l m:list A) (a:A), In a (l ++ m) -> In a l \/ In a m.
Lemma in_or_app : forall (l m:list A) (a:A), In a l \/ In a m -> In a (l ++ m).
Lemma in_app_iff : forall l l' (a:A), In a (l++l') <-> In a l \/ In a l'.
Lemma app_inv_head:  forall l l1 l2 : list A, l ++ l1 = l ++ l2 -> l1 = l2.
Lemma app_inv_tail:   forall l l1 l2 : list A, l1 ++ l = l2 ++ l -> l1 = l2.
Lemma nth_in_or_default :   forall (n:nat) (l:list A) (d:A), {In (nth n l d) l} + {nth n l d = d}.
Lemma nth_S_cons :   forall (n:nat) (l:list A) (d a:A),     In (nth n l d) l -> In (nth (S n) (a :: l) d) (a :: l).
Lemma nth_default_eq :   forall n l (d:A), nth_default d l n = nth n l d.
Lemma nth_In :   forall (n:nat) (l:list A) (d:A), n < length l -> In (nth n l d) l.
Lemma nth_overflow : forall l n d, length l <= n -> nth n l d = d.
Lemma nth_indep :   forall l n d d', n < length l -> nth n l d = nth n l d'.
Lemma app_nth1 :   forall l l' d n, n < length l -> nth n (l++l') d = nth n l d.
Lemma app_nth2 :   forall l l' d n, n >= length l -> nth n (l++l') d = nth (n-length l) l' d.
Lemma app_removelast_last :   forall l d, l <> [] -> l = removelast l ++ [last l d].
Lemma exists_last :   forall l, l <> [] -> { l' : (list A) & { a : A | l = l' ++ [a]}}.
Lemma removelast_app :   forall l l', l' <> [] -> removelast (l++l') = l ++ removelast l'.
Lemma count_occ_nil : forall (x : A), count_occ [] x = 0.
Lemma count_occ_cons_eq : forall (l : list A) (x y : A), x = y -> count_occ (x::l) y = S (count_occ l y).
Lemma count_occ_cons_neq : forall (l : list A) (x y : A), x <> y -> count_occ (x::l) y = count_occ l y.
Lemma rev_app_distr : forall x y:list A, rev (x ++ y) = rev y ++ rev x.
Lemma rev_involutive : forall l:list A, rev (rev l) = l.
Lemma in_rev : forall l x, In x l <-> In x (rev l).
Lemma rev_length : forall l, length (rev l) = length l.
Lemma rev_nth : forall l d n,  n < length l ->   nth n (rev l) d = nth (length l - S n) l d.
Lemma rev_append_rev : forall l l', rev_append l l' = rev l ++ l'.
Lemma rev_alt : forall l, rev l = rev_append l [].
Lemma rev_list_ind :     forall P:list A-> Prop, P [] -> (forall (a:A) (l:list A), P (rev l) -> P (rev (a :: l))) -> forall l:list A, P (rev l).
Lemma list_eq_dec : forall l l':list A, {l = l'} + {l <> l'}.
Lemma in_map :   forall (l:list A) (x:A), In x l -> In (f x) (map l).
Lemma in_map_iff : forall l y, In y (map l) <-> exists x, f x = y /\ In x l.
Lemma map_length : forall l, length (map l) = length l.
Lemma map_nth : forall l d n,   nth n (map l) (f d) = f (nth n l d).
Lemma map_nth_error : forall n l d,   nth_error l n = Some d -> nth_error (map l) n = Some (f d).
Lemma map_app : forall l l',   map (l++l') = (map l)++(map l').
Lemma map_rev : forall l, map (rev l) = rev (map l).
Lemma map_eq_nil : forall l, map l = [] -> l = [].
Lemma in_flat_map : forall (f:A->list B)(l:list A)(y:B),   In y (flat_map f l) <-> exists x, In x l /\ In y (f x).
Lemma map_id : forall (A :Type) (l : list A), map (fun x => x) l = l.
Lemma map_map : forall (A B C:Type)(f:A->B)(g:B->C) l, map g (map f l) = map (fun x => g (f x)) l.
Lemma map_ext : forall (A B : Type)(f g:A->B), (forall a, f a = g a) -> forall l, map f l = map g l.
Lemma fold_left_app : forall (l l':list B)(i:A),   fold_left (l++l') i = fold_left l' (fold_left l i).
Lemma fold_left_length : forall (A:Type)(l:list A), fold_left (fun x _ => S x) l 0 = length l.
Lemma fold_right_app : forall (A B:Type)(f:A->B->B) l l' i,   fold_right f i (l++l') = fold_right f (fold_right f i l') l.
Lemma fold_left_rev_right : forall (A B:Type)(f:A->B->B) l i,   fold_right f i (rev l) = fold_left (fun x y => f y x) l i.
Lemma existsb_exists :     forall l, existsb l = true <-> exists x, In x l /\ f x = true.
Lemma existsb_nth : forall l n d, n < length l ->     existsb l = false -> f (nth n l d) = false.
Lemma existsb_app : forall l1 l2,     existsb (l1++l2) = existsb l1 || existsb l2.
Lemma forallb_forall :     forall l, forallb l = true <-> (forall x, In x l -> f x = true).
Lemma forallb_app :     forall l1 l2, forallb (l1++l2) = forallb l1 && forallb l2.
Lemma filter_In : forall x l, In x (filter l) <-> In x l /\ f x = true.
Lemma in_split_l : forall (l:list (A*B))(p:A*B),     In p l -> In (fst p) (fst (split l)).
Lemma in_split_r : forall (l:list (A*B))(p:A*B),     In p l -> In (snd p) (snd (split l)).
Lemma split_nth : forall (l:list (A*B))(n:nat)(d:A*B),     nth n l d = (nth n (fst (split l)) (fst d), nth n (snd (split l)) (snd d)).
Lemma split_length_l : forall (l:list (A*B)),     length (fst (split l)) = length l.
Lemma split_length_r : forall (l:list (A*B)),     length (snd (split l)) = length l.
Lemma split_combine : forall (l: list (A*B)),     let (l1,l2) := split l in combine l1 l2 = l.
Lemma combine_split : forall (l:list A)(l':list B), length l = length l' ->     split (combine l l') = (l,l').
Lemma in_combine_l : forall (l:list A)(l':list B)(x:A)(y:B),     In (x,y) (combine l l') -> In x l.
Lemma in_combine_r : forall (l:list A)(l':list B)(x:A)(y:B),     In (x,y) (combine l l') -> In y l'.
Lemma combine_length : forall (l:list A)(l':list B),     length (combine l l') = min (length l) (length l').
Lemma combine_nth : forall (l:list A)(l':list B)(n:nat)(x:A)(y:B),     length l = length l' ->     nth n (combine l l') (x,y) = (nth n l x, nth n l' y).
Lemma in_prod_aux :     forall (x:A) (y:B) (l:list B), In y l -> In (x, y) (map (fun y0:B => (x, y0)) l).
Lemma in_prod :     forall (l:list A) (l':list B) (x:A) (y:B), In x l -> In y l' -> In (x, y) (list_prod l l').
Lemma in_prod_iff :     forall (l:list A)(l':list B)(x:A)(y:B), In (x,y) (list_prod l l') <-> In x l /\ In y l'.
Lemma prod_length : forall (l:list A)(l':list B),     length (list_prod l l') = (length l) * (length l').
Lemma lel_refl : lel l l.
Lemma lel_trans : lel l m -> lel m n -> lel l n.
Lemma lel_cons_cons : lel l m -> lel (a :: l) (b :: m).
Lemma lel_cons : lel l m -> lel l (b :: m).
Lemma lel_tail : lel (a :: l) (b :: m) -> lel l m.
Lemma lel_nil : forall l':list A, lel l' nil -> nil = l'.
Lemma incl_refl : forall l:list A, incl l l.
Lemma incl_tl : forall (a:A) (l m:list A), incl l m -> incl l (a :: m).
Lemma incl_tran : forall l m n:list A, incl l m -> incl m n -> incl l n.
Lemma incl_appl : forall l m n:list A, incl l n -> incl l (n ++ m).
Lemma incl_appr : forall l m n:list A, incl l n -> incl l (m ++ n).
Lemma incl_cons :   forall (a:A) (l m:list A), In a m -> incl l m -> incl (a :: l) m.
Lemma incl_app : forall l m n:list A, incl l n -> incl m n -> incl (l ++ m) n.
Lemma firstn_skipn : forall n l, firstn n l ++ skipn n l = l.
Lemma firstn_length : forall n l, length (firstn n l) = min n (length l).
Lemma removelast_firstn : forall n l, n < length l ->    removelast (firstn (S n) l) = firstn n l.
Lemma firstn_removelast : forall n l, n < length l ->    firstn n (removelast l) = firstn n l.
Lemma NoDup_remove_1 : forall l l' a, NoDup (l++a::l') -> NoDup (l++l').
Lemma NoDup_remove_2 : forall l l' a, NoDup (l++a::l') -> ~In a (l++l').
Lemma seq_length : forall len start, length (seq start len) = len.
Lemma seq_nth : forall len start n d,   n < len -> nth n (seq start len) d = start+n.
Lemma seq_shift : forall len start,   map S (seq start len) = seq (S start) len.
Lemma Exists_exists : forall A P (l:list A), Exists P l <-> (exists x, In x l /\ P x).
Lemma Exists_nil : forall A (P:A->Prop), Exists P nil <-> False.
Lemma Exists_cons : forall A (P:A->Prop) x l, Exists P (x::l) <-> P x \/ Exists P l.
Lemma Forall_forall : forall A P (l:list A), Forall P l <-> (forall x, In x l -> P x).
Lemma Forall_inv : forall A P (a:A) l, Forall P (a :: l) -> P a.
Lemma Forall_rect : forall A (P:A->Prop) (Q : list A -> Type),    Q [] -> (forall b l, P b -> Q (b :: l)) -> forall l, Forall P l -> Q l.
Lemma Forall_impl : forall A (P Q : A -> Prop), (forall a, P a -> Q a) -> forall l, Forall P l -> Forall Q l.
Lemma ForallOrdPairs_In : forall A (R:A->A->Prop) l, ForallOrdPairs R l -> forall x y, In x l -> In y l -> x=y \/ R x y \/ R y x.
Lemma ForallPairs_ForallOrdPairs : forall A (R:A->A->Prop) l, ForallPairs R l -> ForallOrdPairs R l.
Lemma ForallOrdPairs_ForallPairs : forall A (R:A->A->Prop), (forall x, R x x) -> (forall x y, R x y -> R y x) -> forall l, ForallOrdPairs R l -> ForallPairs R l.
Lemma wwB_wBwB : wwB = wB^2.
Lemma spec_ww_1    : [[ww_1]] = 1.
Lemma spec_ww_Bm1  : [[ww_Bm1]] = wwB - 1.
Lemma lt_0_wB : 0 < wB.
Lemma lt_0_wwB : 0 < wwB.
Lemma wB_pos: 1 < wB.
Lemma wwB_pos: 1 < wwB.
Lemma mod_wwB : forall z x,  (z*wB + [|x|]) mod wwB = (z mod wB)*wB + [|x|].
Lemma wB_div : forall x y, ([|x|] * wB + [|y|]) / wB = [|x|].
Lemma wB_div_plus : forall x y p,  0 <= p ->  ([|x|]*wB + [|y|]) / 2^(Zpos w_digits + p) = [|x|] / 2^p.
Lemma lt_wB_wwB : wB < wwB.
Lemma w_to_Z_wwB : forall x, x < wB -> x < wwB.
Lemma spec_ww_to_Z : forall x, 0 <= [[x]] < wwB.
Lemma double_wB_wwB : forall n, double_wB n * double_wB n = double_wB (S n).
Lemma double_wB_pos:  forall n, 0 <= double_wB n.
Lemma double_wB_more_digits: forall n, wB <= double_wB n.
Lemma spec_double_to_Z :  forall n (x:word w n), 0 <= [!n | x!] < double_wB n.
Lemma spec_get_low: forall n x,    [!n | x!] < wB ->  [|get_low n x|] = [!n | x!].
Lemma spec_double_WW : forall n (h l : word w n),   [!S n|double_WW n h l!] = [!n|h!] * double_wB n + [!n|l!].
Lemma spec_extend_aux : forall n x, [!S n|extend_aux n x!] = [[x]].
Lemma spec_extend : forall n x, [!S n|extend n x!] = [|x|].
Lemma spec_double_0 : forall n, [!n|double_0 n!] = 0.
Lemma spec_double_split : forall n x,  let (h,l) := double_split n x in  [!S n|x!] = [!n|h!] * double_wB n + [!n|l!].
Lemma wB_lex_inv: forall a b c d,     a < c ->     a * wB + [|b|] < c  * wB + [|d|].
Lemma spec_ww_compare : forall x y,   ww_compare x y = Z.compare [[x]] [[y]].
Lemma one_mod_wB : 1 mod wB = 1.
Lemma succ_mod_wB : forall n : Z, (n + 1) mod wB = ((n mod wB) + 1) mod wB.
Lemma pred_mod_wB : forall n : Z, (n - 1) mod wB = ((n mod wB) - 1) mod wB.
Lemma NZ_to_Z_mod : forall n, [| n |] mod wB = [| n |].
Lemma B0 : B 0.
Lemma BS : forall n : Z, 0 <= n -> n < wB - 1 -> B n -> B (n + 1).
Lemma B_holds : forall n : Z, 0 <= n < wB -> B n.
Lemma mem_eq: E.eq x y -> mem x s=mem y s.
Lemma equal_mem_1: (forall a, mem a s=mem a s') -> equal s s'=true.
Lemma equal_mem_2: equal s s'=true -> forall a, mem a s=mem a s'.
Lemma subset_mem_1: (forall a, mem a s=true->mem a s'=true) -> subset s s'=true.
Lemma subset_mem_2: subset s s'=true -> forall a, mem a s=true -> mem a s'=true.
Lemma empty_mem: mem x empty=false.
Lemma is_empty_equal_empty: is_empty s = equal s empty.
Lemma choose_mem_1: choose s=Some x -> mem x s=true.
Lemma choose_mem_2: choose s=None -> is_empty s=true.
Lemma add_mem_1: mem x (add x s)=true.
Lemma add_mem_2: ~E.eq x y -> mem y (add x s)=mem y s.
Lemma remove_mem_1: mem x (remove x s)=false.
Lemma remove_mem_2: ~E.eq x y -> mem y (remove x s)=mem y s.
Lemma singleton_equal_add: equal (singleton x) (add x empty)=true.
Lemma union_mem: mem x (union s s')=mem x s || mem x s'.
Lemma inter_mem: mem x (inter s s')=mem x s && mem x s'.
Lemma diff_mem: mem x (diff s s')=mem x s && negb (mem x s').
Lemma mem_3 : ~In x s -> mem x s=false.
Lemma mem_4 : mem x s=false -> ~In x s.
Lemma equal_refl: equal s s=true.
Lemma equal_sym: equal s s'=equal s' s.
Lemma equal_trans: equal s s'=true -> equal s' s''=true -> equal s s''=true.
Lemma equal_equal: equal s s'=true -> equal s s''=equal s' s''.
Lemma equal_cardinal: equal s s'=true -> cardinal s=cardinal s'.
Lemma subset_refl: subset s s=true.
Lemma subset_antisym: subset s s'=true -> subset s' s=true -> equal s s'=true.
Lemma subset_trans: subset s s'=true -> subset s' s''=true -> subset s s''=true.
Lemma subset_equal: equal s s'=true -> subset s s'=true.
Lemma choose_mem_3: is_empty s=false -> {x:elt|choose s=Some x /\ mem x s=true}.
Lemma choose_mem_4: choose empty=None.
Lemma add_mem_3: mem y s=true -> mem y (add x s)=true.
Lemma add_equal: mem x s=true -> equal (add x s) s=true.
Lemma remove_mem_3: mem y (remove x s)=true -> mem y s=true.
Lemma remove_equal: mem x s=false -> equal (remove x s) s=true.
Lemma add_remove: mem x s=true -> equal (add x (remove x s)) s=true.
Lemma remove_add: mem x s=false -> equal (remove x (add x s)) s=true.
Lemma is_empty_cardinal: is_empty s = zerob (cardinal s).
Lemma singleton_mem_1: mem x (singleton x)=true.
Lemma singleton_mem_2: ~E.eq x y -> mem y (singleton x)=false.
Lemma singleton_mem_3: mem y (singleton x)=true -> E.eq x y.
Lemma union_sym: equal (union s s') (union s' s)=true.
Lemma union_subset_equal: subset s s'=true -> equal (union s s') s'=true.
Lemma union_equal_1: equal s s'=true-> equal (union s s'') (union s' s'')=true.
Lemma union_equal_2: equal s' s''=true-> equal (union s s') (union s s'')=true.
Lemma union_assoc: equal (union (union s s') s'') (union s (union s' s''))=true.
Lemma add_union_singleton: equal (add x s) (union (singleton x) s)=true.
Lemma union_add: equal (union (add x s) s') (add x (union s s'))=true.
Lemma union_subset_1: subset s (union s s')=true.
Lemma union_subset_2: subset s' (union s s')=true.
Lemma union_subset_3: subset s s''=true -> subset s' s''=true -> subset (union s s') s''=true.
Lemma inter_sym: equal (inter s s') (inter s' s)=true.
Lemma inter_subset_equal: subset s s'=true -> equal (inter s s') s=true.
Lemma inter_equal_1: equal s s'=true -> equal (inter s s'') (inter s' s'')=true.
Lemma inter_equal_2: equal s' s''=true -> equal (inter s s') (inter s s'')=true.
Lemma inter_assoc: equal (inter (inter s s') s'') (inter s (inter s' s''))=true.
Lemma union_inter_1: equal (inter (union s s') s'') (union (inter s s'') (inter s' s''))=true.
Lemma union_inter_2: equal (union (inter s s') s'') (inter (union s s'') (union s' s''))=true.
Lemma inter_add_1: mem x s'=true -> equal (inter (add x s) s') (add x (inter s s'))=true.
Lemma inter_add_2: mem x s'=false -> equal (inter (add x s) s') (inter s s')=true.
Lemma inter_subset_1: subset (inter s s') s=true.
Lemma inter_subset_2: subset (inter s s') s'=true.
Lemma inter_subset_3: subset s'' s=true -> subset s'' s'=true -> subset s'' (inter s s')=true.
Lemma diff_subset: subset (diff s s') s=true.
Lemma diff_subset_equal: subset s s'=true -> equal (diff s s') empty=true.
Lemma remove_inter_singleton: equal (remove x s) (diff s (singleton x))=true.
Lemma diff_inter_empty: equal (inter (diff s s') (inter s s')) empty=true.
Lemma diff_inter_all: equal (union (diff s s') (inter s s')) s=true.
Lemma set_rec:  forall (P:t->Type), (forall s s', equal s s'=true -> P s -> P s') -> (forall s x, mem x s=false -> P s -> P (add x s)) -> P empty -> forall s, P s.
Lemma exclusive_set : forall s s' x, ~(In x s/\In x s') <-> mem x s && mem x s'=false.
Lemma fold_empty: (fold f empty i) = i.
Lemma fold_equal: equal s s'=true -> eqA (fold f s i) (fold f s' i).
Lemma fold_add: mem x s=false -> eqA (fold f (add x s) i) (f x (fold f s i)).
Lemma add_fold: mem x s=true -> eqA (fold f (add x s) i) (fold f s i).
Lemma remove_fold_1: mem x s=true -> eqA (f x (fold f (remove x s) i)) (fold f s i).
Lemma remove_fold_2: mem x s=false -> eqA (fold f (remove x s) i) (fold f s i).
Lemma fold_union: (forall x, mem x s && mem x s'=false) -> eqA (fold f (union s s') i) (fold f s (fold f s' i)).
Lemma add_cardinal_1: forall s x, mem x s=true -> cardinal (add x s)=cardinal s.
Lemma add_cardinal_2: forall s x, mem x s=false -> cardinal (add x s)=S (cardinal s).
Lemma remove_cardinal_1: forall s x, mem x s=true -> S (cardinal (remove x s))=cardinal s.
Lemma remove_cardinal_2: forall s x, mem x s=false -> cardinal (remove x s)=cardinal s.
Lemma union_cardinal: forall s s', (forall x, mem x s && mem x s'=false) -> cardinal (union s s')=cardinal s+cardinal s'.
Lemma subset_cardinal: forall s s', subset s s'=true -> cardinal s<=cardinal s'.
Lemma filter_mem: forall s x, mem x (filter f s)=mem x s && f x.
Lemma for_all_filter: forall s, for_all f s=is_empty (filter (fun x => negb (f x)) s).
Lemma exists_filter : forall s, exists_ f s=negb (is_empty (filter f s)).
Lemma partition_filter_1: forall s, equal (fst (partition f s)) (filter f s)=true.
Lemma partition_filter_2: forall s, equal (snd (partition f s)) (filter (fun x => negb (f x)) s)=true.
Lemma filter_add_1 : forall s x, f x = true -> filter f (add x s) [=] add x (filter f s).
Lemma filter_add_2 : forall s x, f x = false -> filter f (add x s) [=] filter f s.
Lemma add_filter_1 : forall s s' x, f x=true -> (Add x s s') -> (Add x (filter f s) (filter f s')).
Lemma add_filter_2 : forall s s' x, f x=false -> (Add x s s') -> filter f s [=] filter f s'.
Lemma union_filter: forall f g, Proper (E.eq==>Logic.eq) f -> Proper (E.eq==>Logic.eq) g ->
Lemma filter_union: forall s s', filter f (union s s') [=] union (filter f s) (filter f s').
Lemma for_all_mem_1: forall s, (forall x, (mem x s)=true->(f x)=true) -> (for_all f s)=true.
Lemma for_all_mem_2: forall s, (for_all f s)=true -> forall x,(mem x s)=true -> (f x)=true.
Lemma for_all_mem_3: forall s x,(mem x s)=true -> (f x)=false -> (for_all f s)=false.
Lemma for_all_mem_4: forall s, for_all f s=false -> {x:elt | mem x s=true /\ f x=false}.
Lemma for_all_exists: forall s, exists_ f s = negb (for_all (fun x =>negb (f x)) s).
Lemma exists_mem_1: forall s, (forall x, mem x s=true->f x=false) -> exists_ f s=false.
Lemma exists_mem_2: forall s, exists_ f s=false -> forall x, mem x s=true -> f x=false.
Lemma exists_mem_3: forall s x, mem x s=true -> f x=true -> exists_ f s=true.
Lemma exists_mem_4: forall s, exists_ f s=true -> {x:elt | (mem x s)=true /\ (f x)=true}.
Lemma sum_plus : forall f g, Proper (E.eq==>Logic.eq) f -> Proper (E.eq==>Logic.eq) g ->
Lemma sum_filter : forall f : elt -> bool, Proper (E.eq==>Logic.eq) f ->
Lemma fold_compat : forall (A:Type)(eqA:A->A->Prop)(st:Equivalence eqA) (f g:elt->A->A), Proper (E.eq==>eqA==>eqA) f -> transpose eqA f ->
Lemma sum_compat : forall f g, Proper (E.eq==>Logic.eq) f -> Proper (E.eq==>Logic.eq) g ->
Lemma Peqb_complete p p' : Pos.eqb p p' = true -> p = p'.
Lemma Peqb_Pcompare p p' : Pos.eqb p p' = true -> Pos.compare p p' = Eq.
Lemma Pcompare_Peqb p p' : Pos.compare p p' = Eq -> Pos.eqb p p' = true.
Lemma Neqb_Ncompare n n' : N.eqb n n' = true -> N.compare n n' = Eq.
Lemma Ncompare_Neqb n n' : N.compare n n' = Eq -> N.eqb n n' = true.
Lemma Neqb_complete n n' : N.eqb n n' = true -> n = n'.
Lemma Nxor_eq_true n n' : N.lxor n n' = 0 -> N.eqb n n' = true.
Lemma Nxor_eq_false n n' p : N.lxor n n' = N.pos p -> N.eqb n n' = false.
Lemma Nodd_not_double a : Nodd a -> forall a0, N.eqb (N.double a0) a = false.
Lemma Nnot_div2_not_double a a0 : N.eqb (N.div2 a) a0 = false -> N.eqb a (N.double a0) = false.
Lemma Neven_not_double_plus_one a : Neven a -> forall a0, N.eqb (N.succ_double a0) a = false.
Lemma Nnot_div2_not_double_plus_one a a0 : N.eqb (N.div2 a) a0 = false -> N.eqb (N.succ_double a0) a = false.
Lemma Nbit0_neq a a' : N.odd a = false -> N.odd a' = true -> N.eqb a a' = false.
Lemma Ndiv2_eq a a' : N.eqb a a' = true -> N.eqb (N.div2 a) (N.div2 a') = true.
Lemma Ndiv2_neq a a' : N.eqb (N.div2 a) (N.div2 a') = false -> N.eqb a a' = false.
Lemma Ndiv2_bit_eq a a' : N.odd a = N.odd a' -> N.div2 a = N.div2 a' -> a = a'.
Lemma Ndiv2_bit_neq a a' : N.eqb a a' = false ->
Lemma Nneq_elim a a' :  N.eqb a a' = false ->
Lemma Ndouble_or_double_plus_un a :  {a0 : N | a = N.double a0} + {a1 : N | a = N.succ_double a1}.
Lemma Nleb_alt a b : Nleb a b = N.leb a b.
Lemma Nleb_Nle a b : Nleb a b = true <-> a <= b.
Lemma Nleb_refl a : Nleb a a = true.
Lemma Nleb_antisym a b : Nleb a b = true -> Nleb b a = true -> a = b.
Lemma Nleb_trans a b c : Nleb a b = true -> Nleb b c = true -> Nleb a c = true.
Lemma Nleb_ltb_trans a b c : Nleb a b = true -> Nleb c b = false -> Nleb c a = false.
Lemma Nltb_leb_trans a b c : Nleb b a = false -> Nleb b c = true -> Nleb c a = false.
Lemma Nltb_trans a b c : Nleb b a = false -> Nleb c b = false -> Nleb c a = false.
Lemma Nltb_leb_weak a b : Nleb b a = false -> Nleb a b = true.
Lemma Nleb_double_mono a b : Nleb a b = true -> Nleb (N.double a) (N.double b) = true.
Lemma Nleb_double_plus_one_mono a b : Nleb a b = true ->  Nleb (N.succ_double a) (N.succ_double b) = true.
Lemma Nleb_double_mono_conv a b : Nleb (N.double a) (N.double b) = true -> Nleb a b = true.
Lemma Nleb_double_plus_one_mono_conv a b : Nleb (N.succ_double a) (N.succ_double b) = true ->
Lemma Nltb_double_mono a b :  Nleb a b = false -> Nleb (N.double a) (N.double b) = false.
Lemma Nltb_double_plus_one_mono a b : Nleb a b = false ->  Nleb (N.succ_double a) (N.succ_double b) = false.
Lemma Nltb_double_mono_conv a b : Nleb (N.double a) (N.double b) = false -> Nleb a b = false.
Lemma Nltb_double_plus_one_mono_conv a b : Nleb (N.succ_double a) (N.succ_double b) = false ->
Lemma Nltb_Ncompare a b : Nleb a b = false <-> N.compare a b = Gt.
Lemma Ncompare_Gt_Nltb a b : N.compare a b = Gt -> Nleb a b = false.
Lemma Ncompare_Lt_Nltb a b : N.compare a b = Lt -> Nleb b a = false.
Lemma Nmin_le_1 a b : Nleb (N.min a b) a = true.
Lemma Nmin_le_2 a b : Nleb (N.min a b) b = true.
Lemma Nmin_le_3 a b c : Nleb a (N.min b c) = true -> Nleb a b = true.
Lemma Nmin_le_4 a b c : Nleb a (N.min b c) = true -> Nleb a c = true.
Lemma Nmin_le_5 a b c :  Nleb a b = true -> Nleb a c = true -> Nleb a (N.min b c) = true.
Lemma Nmin_lt_3 a b c : Nleb (N.min b c) a = false -> Nleb b a = false.
Lemma Nmin_lt_4 a b c : Nleb (N.min b c) a = false -> Nleb c a = false.
Lemma MaxRlist_P1 : forall (l:Rlist) (x:R), In x l -> x <= MaxRlist l.
Lemma MinRlist_P1 : forall (l:Rlist) (x:R), In x l -> MinRlist l <= x.
Lemma AbsList_P1 : forall (l:Rlist) (x y:R), In y l -> In (Rabs (y - x) / 2) (AbsList l x).
Lemma MinRlist_P2 : forall l:Rlist, (forall y:R, In y l -> 0 < y) -> 0 < MinRlist l.
Lemma AbsList_P2 : forall (l:Rlist) (x y:R),   In y (AbsList l x) ->  exists z : R, In z l /\ y = Rabs (z - x) / 2.
Lemma MaxRlist_P2 : forall l:Rlist, (exists y : R, In y l) -> In (MaxRlist l) l.
Lemma pos_Rl_P1 : forall (l:Rlist) (a:R),   (0 < Rlength l)%nat ->   pos_Rl (cons a l) (Rlength l) = pos_Rl l (pred (Rlength l)).
Lemma pos_Rl_P2 : forall (l:Rlist) (x:R),   In x l <-> (exists i : nat, (i < Rlength l)%nat /\ x = pos_Rl l i).
Lemma Rlist_P1 : forall (l:Rlist) (P:R -> R -> Prop),   (forall x:R, In x l ->  exists y : R, P x y) ->   exists l' : Rlist,     Rlength l = Rlength l' /\     (forall i:nat, (i < Rlength l)%nat -> P (pos_Rl l i) (pos_Rl l' i)).
Lemma RList_P0 : forall (l:Rlist) (a:R),   pos_Rl (insert l a) 0 = a \/ pos_Rl (insert l a) 0 = pos_Rl l 0.
Lemma RList_P1 : forall (l:Rlist) (a:R), ordered_Rlist l -> ordered_Rlist (insert l a).
Lemma RList_P2 : forall l1 l2:Rlist, ordered_Rlist l2 -> ordered_Rlist (cons_ORlist l1 l2).
Lemma RList_P3 : forall (l:Rlist) (x:R),   In x l <-> (exists i : nat, x = pos_Rl l i /\ (i < Rlength l)%nat).
Lemma RList_P4 : forall (l1:Rlist) (a:R), ordered_Rlist (cons a l1) -> ordered_Rlist l1.
Lemma RList_P5 : forall (l:Rlist) (x:R), ordered_Rlist l -> In x l -> pos_Rl l 0 <= x.
Lemma RList_P6 : forall l:Rlist,   ordered_Rlist l <->   (forall i j:nat,     (i <= j)%nat -> (j < Rlength l)%nat -> pos_Rl l i <= pos_Rl l j).
Lemma RList_P7 : forall (l:Rlist) (x:R),   ordered_Rlist l -> In x l -> x <= pos_Rl l (pred (Rlength l)).
Lemma RList_P8 : forall (l:Rlist) (a x:R), In x (insert l a) <-> x = a \/ In x l.
Lemma RList_P9 : forall (l1 l2:Rlist) (x:R), In x (cons_ORlist l1 l2) <-> In x l1 \/ In x l2.
Lemma RList_P10 : forall (l:Rlist) (a:R), Rlength (insert l a) = S (Rlength l).
Lemma RList_P11 : forall l1 l2:Rlist,   Rlength (cons_ORlist l1 l2) = (Rlength l1 + Rlength l2)%nat.
Lemma RList_P12 : forall (l:Rlist) (i:nat) (f:R -> R),   (i < Rlength l)%nat -> pos_Rl (app_Rlist l f) i = f (pos_Rl l i).
Lemma RList_P13 : forall (l:Rlist) (i:nat) (a:R),   (i < pred (Rlength l))%nat ->   pos_Rl (mid_Rlist l a) (S i) = (pos_Rl l i + pos_Rl l (S i)) / 2.
Lemma RList_P14 : forall (l:Rlist) (a:R), Rlength (mid_Rlist l a) = Rlength l.
Lemma RList_P15 : forall l1 l2:Rlist,   ordered_Rlist l1 ->   ordered_Rlist l2 ->   pos_Rl l1 0 = pos_Rl l2 0 -> pos_Rl (cons_ORlist l1 l2) 0 = pos_Rl l1 0.
Lemma RList_P16 : forall l1 l2:Rlist,   ordered_Rlist l1 ->   ordered_Rlist l2 ->   pos_Rl l1 (pred (Rlength l1)) = pos_Rl l2 (pred (Rlength l2)) ->   pos_Rl (cons_ORlist l1 l2) (pred (Rlength (cons_ORlist l1 l2))) =   pos_Rl l1 (pred (Rlength l1)).
Lemma RList_P17 : forall (l1:Rlist) (x:R) (i:nat),   ordered_Rlist l1 ->   In x l1 ->   pos_Rl l1 i < x -> (i < pred (Rlength l1))%nat -> pos_Rl l1 (S i) <= x.
Lemma RList_P18 : forall (l:Rlist) (f:R -> R), Rlength (app_Rlist l f) = Rlength l.
Lemma RList_P19 : forall l:Rlist,   l <> nil ->  exists r : R, (exists r0 : Rlist, l = cons r r0).
Lemma RList_P20 : forall l:Rlist,   (2 <= Rlength l)%nat ->   exists r : R,     (exists r1 : R, (exists l' : Rlist, l = cons r (cons r1 l'))).
Lemma RList_P21 : forall l l':Rlist, l = l' -> Rtail l = Rtail l'.
Lemma RList_P22 : forall l1 l2:Rlist, l1 <> nil -> pos_Rl (cons_Rlist l1 l2) 0 = pos_Rl l1 0.
Lemma RList_P23 : forall l1 l2:Rlist,   Rlength (cons_Rlist l1 l2) = (Rlength l1 + Rlength l2)%nat.
Lemma RList_P24 : forall l1 l2:Rlist,   l2 <> nil ->   pos_Rl (cons_Rlist l1 l2) (pred (Rlength (cons_Rlist l1 l2))) =   pos_Rl l2 (pred (Rlength l2)).
Lemma RList_P25 : forall l1 l2:Rlist,   ordered_Rlist l1 ->   ordered_Rlist l2 ->   pos_Rl l1 (pred (Rlength l1)) <= pos_Rl l2 0 ->   ordered_Rlist (cons_Rlist l1 l2).
Lemma RList_P26 : forall (l1 l2:Rlist) (i:nat),   (i < Rlength l1)%nat -> pos_Rl (cons_Rlist l1 l2) i = pos_Rl l1 i.
Lemma RList_P27 : forall l1 l2 l3:Rlist,   cons_Rlist l1 (cons_Rlist l2 l3) = cons_Rlist (cons_Rlist l1 l2) l3.
Lemma RList_P28 : forall l:Rlist, cons_Rlist l nil = l.
Lemma RList_P29 : forall (l2 l1:Rlist) (i:nat),   (Rlength l1 <= i)%nat ->   (i < Rlength (cons_Rlist l1 l2))%nat ->   pos_Rl (cons_Rlist l1 l2) i = pos_Rl l2 (i - Rlength l1).
Lemma singleton_spec : forall x y, InT y (singleton x) <-> X.eq y x.
Lemma create_spec : forall l x r y,  InT y (create l x r) <-> X.eq y x \/ InT y l \/ InT y r.
Lemma bal_spec : forall l x r y, InT y (bal l x r) <-> X.eq y x \/ InT y l \/ InT y r.
Lemma add_spec' : forall s x y, InT y (add x s) <-> X.eq y x \/ InT y s.
Lemma add_spec : forall s x y `{Ok s}, InT y (add x s) <-> X.eq y x \/ InT y s.
Lemma join_spec : forall l x r y, InT y (join l x r) <-> X.eq y x \/ InT y l \/ InT y r.
Lemma remove_min_spec : forall l x r y h, InT y (Node h l x r) <-> X.eq y (remove_min l x r)#2 \/ InT y (remove_min l x r)#1.
Lemma remove_min_gt_tree : forall l x r h `{Ok (Node h l x r)}, gt_tree (remove_min l x r)#2 (remove_min l x r)#1.
Lemma merge_spec : forall s1 s2 y, InT y (merge s1 s2) <-> InT y s1 \/ InT y s2.
Lemma remove_spec : forall s x y `{Ok s}, (InT y (remove x s) <-> InT y s /\ ~ X.eq y x).
Lemma concat_spec : forall s1 s2 y, InT y (concat s1 s2) <-> InT y s1 \/ InT y s2.
Lemma split_spec1 : forall s x y `{Ok s}, (InT y (split x s)#l <-> InT y s /\ X.lt y x).
Lemma split_spec2 : forall s x y `{Ok s}, (InT y (split x s)#r <-> InT y s /\ X.lt x y).
Lemma split_spec3 : forall s x `{Ok s}, ((split x s)#b = true <-> InT x s).
Lemma split_ok : forall s x `{Ok s}, Ok (split x s)#l /\ Ok (split x s)#r.
Lemma inter_spec_ok : forall s1 s2 `{Ok s1, Ok s2}, Ok (inter s1 s2) /\ (forall y, InT y (inter s1 s2) <-> InT y s1 /\ InT y s2).
Lemma inter_spec : forall s1 s2 y `{Ok s1, Ok s2}, (InT y (inter s1 s2) <-> InT y s1 /\ InT y s2).
Lemma diff_spec_ok : forall s1 s2 `{Ok s1, Ok s2}, Ok (diff s1 s2) /\ (forall y, InT y (diff s1 s2) <-> InT y s1 /\ ~InT y s2).
Lemma diff_spec : forall s1 s2 y `{Ok s1, Ok s2}, (InT y (diff s1 s2) <-> InT y s1 /\ ~InT y s2).
Lemma union_spec : forall s1 s2 y `{Ok s1, Ok s2}, (InT y (union s1 s2) <-> InT y s1 \/ InT y s2).
Lemma filter_spec : forall s x f, Proper (X.eq==>Logic.eq) f ->
Lemma filter_weak_spec : forall s x f, InT x (filter f s) -> InT x s.
Lemma partition_spec1' s f : (partition f s)#1 = filter f s.
Lemma partition_spec2' s f : (partition f s)#2 = filter (fun x => negb (f x)) s.
Lemma partition_spec1 s f : Proper (X.eq==>Logic.eq) f ->
Lemma partition_spec2 s f : Proper (X.eq==>Logic.eq) f ->
Lemma of_nat_to_nat_inv {m} (p : t m) : of_nat_lt (proj2_sig (to_nat p)) = p.
Lemma L_sanity {m} n (p : t m) : proj1_sig (to_nat (L n p)) = proj1_sig (to_nat p).
Lemma R_sanity {m} n (p : t m) : proj1_sig (to_nat (R n p)) = n + proj1_sig (to_nat p).
Lemma depair_sanity {m n} (o : t m) (p : t n) : proj1_sig (to_nat (depair o p)) = n * (proj1_sig (to_nat o)) + (proj1_sig (to_nat p)).
Lemma strong_rec_alt : forall a f n, strong_rec a f n = strong_rec0 a f (S n) n.
Lemma strong_rec0_0 : forall a m, (strong_rec0 a f 0 m) = a.
Lemma strong_rec0_succ : forall a n m, Aeq (strong_rec0 a f (S n) m) (f (strong_rec0 a f n) m).
Lemma strong_rec_0 : forall a, Aeq (strong_rec a f 0) (f (fun _ => a) 0).
Lemma strong_rec0_more_steps : forall a k n m, m < n -> Aeq (strong_rec0 a f n m) (strong_rec0 a f (n+k) m).
Lemma strong_rec0_fixpoint : forall (a : A) (n : N.t),
Lemma strong_rec_any_fst_arg : forall a a' n, Aeq (strong_rec a f n) (strong_rec a' f n).
Lemma lt_O_fact : forall n:nat, 0 < fact n.
Lemma fact_neq_0 : forall n:nat, fact n <> 0.
Lemma fact_le : forall n m:nat, n <= m -> fact n <= fact m.
Lemma cont_deriv : forall (f d:R -> R) (D:R -> Prop) (x0:R),   D_in f d D x0 -> continue_in f D x0.
Lemma Dconst : forall (D:R -> Prop) (y x0:R), D_in (fun x:R => y) (fun x:R => 0) D x0.
Lemma Dx : forall (D:R -> Prop) (x0:R), D_in (fun x:R => x) (fun x:R => 1) D x0.
Lemma Dadd : forall (D:R -> Prop) (df dg f g:R -> R) (x0:R),   D_in f df D x0 ->   D_in g dg D x0 ->   D_in (fun x:R => f x + g x) (fun x:R => df x + dg x) D x0.
Lemma Dmult : forall (D:R -> Prop) (df dg f g:R -> R) (x0:R),   D_in f df D x0 ->   D_in g dg D x0 ->   D_in (fun x:R => f x * g x) (fun x:R => df x * g x + f x * dg x) D x0.
Lemma Dmult_const : forall (D:R -> Prop) (f df:R -> R) (x0 a:R),   D_in f df D x0 -> D_in (fun x:R => a * f x) (fun x:R => a * df x) D x0.
Lemma Dopp : forall (D:R -> Prop) (f df:R -> R) (x0:R),   D_in f df D x0 -> D_in (fun x:R => - f x) (fun x:R => - df x) D x0.
Lemma Dminus : forall (D:R -> Prop) (df dg f g:R -> R) (x0:R),   D_in f df D x0 ->   D_in g dg D x0 ->   D_in (fun x:R => f x - g x) (fun x:R => df x - dg x) D x0.
Lemma Dx_pow_n : forall (n:nat) (D:R -> Prop) (x0:R),   D_in (fun x:R => x ^ n) (fun x:R => INR n * x ^ (n - 1)) D x0.
Lemma Dcomp : forall (Df Dg:R -> Prop) (df dg f g:R -> R) (x0:R),   D_in f df Df x0 ->   D_in g dg Dg (f x0) ->   D_in (fun x:R => g (f x)) (fun x:R => df x * dg (f x)) (Dgf Df Dg f) x0.
Lemma D_pow_n : forall (n:nat) (D:R -> Prop) (x0:R) (expr dexpr:R -> R),   D_in expr dexpr D x0 ->   D_in (fun x:R => expr x ^ n)   (fun x:R => INR n * expr x ^ (n - 1) * dexpr x) (     Dgf D D expr) x0.
Lemma log2_nonneg : forall a, 0 <= log2 a.
Lemma log2_unique : forall a b, 0<=b -> 2^b<=a<2^(S b) -> log2 a == b.
Lemma log2_spec_alt : forall a, 0<a -> exists r, a == 2^(log2 a) + r /\ 0 <= r < 2^(log2 a).
Lemma log2_unique' : forall a b c, 0<=b -> 0<=c<2^b -> a == 2^b + c -> log2 a == b.
Lemma log2_pow2 : forall a, 0<=a -> log2 (2^a) == a.
Lemma log2_pred_pow2 : forall a, 0<a -> log2 (P (2^a)) == P a.
Lemma log2_1 : log2 1 == 0.
Lemma log2_2 : log2 2 == 1.
Lemma log2_pos : forall a, 1<a -> 0 < log2 a.
Lemma log2_null : forall a, log2 a == 0 <-> a <= 1.
Lemma log2_le_mono : forall a b, a<=b -> log2 a <= log2 b.
Lemma log2_lt_cancel : forall a b, log2 a < log2 b -> a < b.
Lemma log2_le_pow2 : forall a b, 0<a -> (2^b<=a <-> b <= log2 a).
Lemma log2_lt_pow2 : forall a b, 0<a -> (a<2^b <-> log2 a < b).
Lemma log2_lt_lin : forall a, 0<a -> log2 a < a.
Lemma log2_le_lin : forall a, 0<=a -> log2 a <= a.
Lemma log2_mul_below : forall a b, 0<a -> 0<b -> log2 a + log2 b <= log2 (a*b).
Lemma log2_mul_above : forall a b, 0<=a -> 0<=b -> log2 (a*b) <= log2 a + log2 b + 1.
Lemma log2_mul_pow2 : forall a b, 0<a -> 0<=b -> log2 (a*2^b) == b + log2 a.
Lemma log2_double : forall a, 0<a -> log2 (2*a) == S (log2 a).
Lemma log2_same : forall a b, 0<a -> 0<b -> log2 a == log2 b -> a < 2*b.
Lemma log2_succ_le : forall a, log2 (S a) <= S (log2 a).
Lemma log2_succ_or : forall a, log2 (S a) == S (log2 a) \/ log2 (S a) == log2 a.
Lemma log2_eq_succ_is_pow2 : forall a, log2 (S a) == S (log2 a) -> exists b, S a == 2^b.
Lemma log2_eq_succ_iff_pow2 : forall a, 0<a -> (log2 (S a) == S (log2 a) <-> exists b, S a == 2^b).
Lemma log2_succ_double : forall a, 0<a -> log2 (2*a+1) == S (log2 a).
Lemma log2_add_le : forall a b, a~=1 -> b~=1 -> log2 (a+b) <= log2 a + log2 b.
Lemma add_log2_lt : forall a b, 0<a -> 0<b -> log2 a + log2 b < 2 * log2 (a+b).
Lemma log2_up_eqn0 : forall a, a<=1 -> log2_up a == 0.
Lemma log2_up_eqn : forall a, 1<a -> log2_up a == S (log2 (P a)).
Lemma log2_up_spec : forall a, 1<a -> 2^(P (log2_up a)) < a <= 2^(log2_up a).
Lemma log2_up_nonpos : forall a, a<=0 -> log2_up a == 0.
Lemma log2_up_nonneg : forall a, 0 <= log2_up a.
Lemma log2_up_unique : forall a b, 0<b -> 2^(P b)<a<=2^b -> log2_up a == b.
Lemma log2_up_pow2 : forall a, 0<=a -> log2_up (2^a) == a.
Lemma log2_up_succ_pow2 : forall a, 0<=a -> log2_up (S (2^a)) == S a.
Lemma log2_up_1 : log2_up 1 == 0.
Lemma log2_up_2 : log2_up 2 == 1.
Lemma le_log2_log2_up : forall a, log2 a <= log2_up a.
Lemma le_log2_up_succ_log2 : forall a, log2_up a <= S (log2 a).
Lemma log2_log2_up_spec : forall a, 0<a -> 2^log2 a <= a <= 2^log2_up a.
Lemma log2_log2_up_exact : forall a, 0<a -> (log2 a == log2_up a <-> exists b, a == 2^b).
Lemma log2_up_pos : forall a, 1<a -> 0 < log2_up a.
Lemma log2_up_null : forall a, log2_up a == 0 <-> a <= 1.
Lemma log2_up_le_mono : forall a b, a<=b -> log2_up a <= log2_up b.
Lemma log2_up_lt_cancel : forall a b, log2_up a < log2_up b -> a < b.
Lemma log2_up_lt_pow2 : forall a b, 0<a -> (2^b<a <-> b < log2_up a).
Lemma log2_up_le_pow2 : forall a b, 0<a -> (a<=2^b <-> log2_up a <= b).
Lemma log2_up_lt_lin : forall a, 0<a -> log2_up a < a.
Lemma log2_up_le_lin : forall a, 0<=a -> log2_up a <= a.
Lemma log2_up_mul_above : forall a b, 0<=a -> 0<=b -> log2_up (a*b) <= log2_up a + log2_up b.
Lemma log2_up_mul_below : forall a b, 0<a -> 0<b -> log2_up a + log2_up b <= S (log2_up (a*b)).
Lemma log2_up_mul_pow2 : forall a b, 0<a -> 0<=b -> log2_up (a*2^b) == b + log2_up a.
Lemma log2_up_double : forall a, 0<a -> log2_up (2*a) == S (log2_up a).
Lemma log2_up_same : forall a b, 0<a -> 0<b -> log2_up a == log2_up b -> a < 2*b.
Lemma log2_up_succ_le : forall a, log2_up (S a) <= S (log2_up a).
Lemma log2_up_succ_or : forall a, log2_up (S a) == S (log2_up a) \/ log2_up (S a) == log2_up a.
Lemma log2_up_eq_succ_is_pow2 : forall a, log2_up (S a) == S (log2_up a) -> exists b, a == 2^b.
Lemma log2_up_eq_succ_iff_pow2 : forall a, 0<a -> (log2_up (S a) == S (log2_up a) <-> exists b, a == 2^b).
Lemma log2_up_succ_double : forall a, 0<a -> log2_up (2*a+1) == 2 + log2 a.
Lemma log2_up_add_le : forall a b, a~=1 -> b~=1 -> log2_up (a+b) <= log2_up a + log2_up b.
Lemma add_log2_up_lt : forall a b, 0<a -> 0<b -> log2_up a + log2_up b < 2 * log2_up (a+b).
Lemma itersucc_or_itersucc n m : exists k, n == (S^k) m \/ m == (S^k) n.
Lemma succ_swap_pred : forall k n m, n == (S^k) m -> m == (P^k) n.
Lemma itersucc_or_iterpred : forall n m, exists k, n == (S^k) m \/ n == (P^k) m.
Lemma itersucc0_or_iterpred0 : forall n, exists p:nat, n == (S^p) 0 \/ n == (P^p) 0.
Lemma initial_alt : forall n, initial n <-> S (P n) ~= n.
Lemma initial_alt2 : forall n, initial n <-> ~exists m, n == S m.
Lemma initial_unique : forall m, initial m -> m == init.
Lemma initial_ancestor : forall m, exists p, m == (S^p) init.
Lemma succ_pred_approx : forall n, ~initial n -> S (P n) == n.
Lemma succ_onto_gives_succ_pred : forall n, S (P n) == n.
Lemma succ_onto_pred_injective : forall n m, P n == P m -> n == m.
Lemma bi_induction_pred : forall A : t -> Prop, Proper (eq==>iff) A ->   A 0 -> (forall n, A n -> A (S n)) -> (forall n, A n -> A (P n)) ->   forall n, A n.
Lemma central_induction_pred : forall A : t -> Prop, Proper (eq==>iff) A -> forall n0,   A n0 -> (forall n, A n -> A (S n)) -> (forall n, A n -> A (P n)) ->   forall n, A n.
Lemma ofnat_zero : [O] == 0.
Lemma ofnat_succ : forall n, [Datatypes.S n] == succ [n].
Lemma ofnat_pred : forall n, n<>O -> [Peano.pred n] == P [n].
Lemma ofnat_injective : forall n m, [n]==[m] -> n = m.
Lemma ofnat_eq : forall n m, [n]==[m] <-> n = m.
Lemma ofnat_lt : forall n m : nat, [n]<[m] <-> (n<m)%nat.
Lemma ofnat_le : forall n m : nat, [n]<=[m] <-> (n<=m)%nat.
Lemma ofnat_add_l : forall n m, [n]+m == (S^n) m.
Lemma ofnat_add : forall n m, [n+m] == [n]+[m].
Lemma ofnat_mul : forall n m, [n*m] == [n]*[m].
Lemma ofnat_sub_r : forall n m, n-[m] == (P^m) n.
Lemma ofnat_sub : forall n m, m<=n -> [n-m] == [n]-[m].
Lemma CVN_R_cos : forall fn:nat -> R -> R,   fn = (fun (N:nat) (x:R) => (-1) ^ N / INR (fact (2 * N)) * x ^ (2 * N)) ->   CVN_R fn.
Lemma continuity_cos : continuity cos.
Lemma sin_gt_cos_7_8 : sin (7 / 8) > cos (7 / 8).
Lemma cos_pi2 : cos PI2 = 0.
Lemma pi2_int : 7/8 <= PI2 <= 7/4.
Lemma cos_minus : forall x y:R, cos (x - y) = cos x * cos y + sin x * sin y.
Lemma sin2_cos2 : forall x:R, Rsqr (sin x) + Rsqr (cos x) = 1.
Lemma cos2 : forall x:R, Rsqr (cos x) = 1 - Rsqr (sin x).
Lemma sin2 : forall x:R, Rsqr (sin x) = 1 - Rsqr (cos x).
Lemma cos_PI2 : cos (PI / 2) = 0.
Lemma sin_pos_tech : forall x, 0 < x < 2 -> 0 < sin x. 
Lemma sin_PI2 : sin (PI / 2) = 1.
Lemma PI_RGT_0 : PI > 0.
Lemma PI_4 : PI <= 4.
Lemma PI_neq0 : PI <> 0.
Lemma cos_PI : cos PI = -1.
Lemma sin_PI : sin PI = 0.
Lemma sin_bound : forall (a : R) (n : nat), 0 <= a -> a <= PI ->      sin_approx a (2 * n + 1) <= sin a <= sin_approx a (2 * (n + 1)).
Lemma cos_bound : forall (a : R) (n : nat), - PI / 2 <= a -> a <= PI / 2 ->      cos_approx a (2 * n + 1) <= cos a <= cos_approx a (2 * (n + 1)).
Lemma neg_cos : forall x:R, cos (x + PI) = - cos x.
Lemma sin_cos : forall x:R, sin x = - cos (PI / 2 + x).
Lemma sin_plus : forall x y:R, sin (x + y) = sin x * cos y + cos x * sin y.
Lemma sin_minus : forall x y:R, sin (x - y) = sin x * cos y - cos x * sin y.
Lemma tan_plus : forall x y:R,   cos x <> 0 ->   cos y <> 0 ->   cos (x + y) <> 0 ->   1 - tan x * tan y <> 0 ->   tan (x + y) = (tan x + tan y) / (1 - tan x * tan y).
Lemma sin_2a : forall x:R, sin (2 * x) = 2 * sin x * cos x.
Lemma cos_2a : forall x:R, cos (2 * x) = cos x * cos x - sin x * sin x.
Lemma cos_2a_cos : forall x:R, cos (2 * x) = 2 * cos x * cos x - 1.
Lemma cos_2a_sin : forall x:R, cos (2 * x) = 1 - 2 * sin x * sin x.
Lemma tan_2a : forall x:R,   cos x <> 0 ->   cos (2 * x) <> 0 ->   1 - tan x * tan x <> 0 -> tan (2 * x) = 2 * tan x / (1 - tan x * tan x).
Lemma sin_neg : forall x:R, sin (- x) = - sin x.
Lemma cos_neg : forall x:R, cos (- x) = cos x.
Lemma tan_0 : tan 0 = 0.
Lemma tan_neg : forall x:R, tan (- x) = - tan x.
Lemma tan_minus : forall x y:R,   cos x <> 0 ->   cos y <> 0 ->   cos (x - y) <> 0 ->   1 + tan x * tan y <> 0 ->   tan (x - y) = (tan x - tan y) / (1 + tan x * tan y).
Lemma cos_3PI2 : cos (3 * (PI / 2)) = 0.
Lemma sin_2PI : sin (2 * PI) = 0.
Lemma cos_2PI : cos (2 * PI) = 1.
Lemma neg_sin : forall x:R, sin (x + PI) = - sin x.
Lemma sin_PI_x : forall x:R, sin (PI - x) = sin x.
Lemma sin_period : forall (x:R) (k:nat), sin (x + 2 * INR k * PI) = sin x.
Lemma cos_period : forall (x:R) (k:nat), cos (x + 2 * INR k * PI) = cos x.
Lemma sin_shift : forall x:R, sin (PI / 2 - x) = cos x.
Lemma cos_shift : forall x:R, cos (PI / 2 - x) = sin x.
Lemma cos_sin : forall x:R, cos x = sin (PI / 2 + x).
Lemma PI2_RGT_0 : 0 < PI / 2.
Lemma SIN_bound : forall x:R, -1 <= sin x <= 1.
Lemma COS_bound : forall x:R, -1 <= cos x <= 1.
Lemma cos_sin_0 : forall x:R, ~ (cos x = 0 /\ sin x = 0).
Lemma cos_sin_0_var : forall x:R, cos x <> 0 \/ sin x <> 0.
Lemma sin_lb_gt_0 : forall a:R, 0 < a -> a <= PI / 2 -> 0 < sin_lb a.
Lemma SIN : forall a:R, 0 <= a -> a <= PI -> sin_lb a <= sin a <= sin_ub a.
Lemma COS : forall a:R, - PI / 2 <= a -> a <= PI / 2 -> cos_lb a <= cos a <= cos_ub a.
Lemma _PI2_RLT_0 : - (PI / 2) < 0.
Lemma PI4_RLT_PI2 : PI / 4 < PI / 2.
Lemma PI2_Rlt_PI : PI / 2 < PI.
Lemma sin_ge_0 : forall x:R, 0 <= x -> x <= PI -> 0 <= sin x.
Lemma cos_ge_0 : forall x:R, - (PI / 2) <= x -> x <= PI / 2 -> 0 <= cos x.
Lemma sin_le_0 : forall x:R, PI <= x -> x <= 2 * PI -> sin x <= 0.
Lemma cos_le_0 : forall x:R, PI / 2 <= x -> x <= 3 * (PI / 2) -> cos x <= 0.
Lemma sin_lt_0 : forall x:R, PI < x -> x < 2 * PI -> sin x < 0.
Lemma sin_lt_0_var : forall x:R, - PI < x -> x < 0 -> sin x < 0.
Lemma cos_lt_0 : forall x:R, PI / 2 < x -> x < 3 * (PI / 2) -> cos x < 0.
Lemma tan_gt_0 : forall x:R, 0 < x -> x < PI / 2 -> 0 < tan x.
Lemma tan_lt_0 : forall x:R, - (PI / 2) < x -> x < 0 -> tan x < 0.
Lemma cos_ge_0_3PI2 : forall x:R, 3 * (PI / 2) <= x -> x <= 2 * PI -> 0 <= cos x.
Lemma form1 : forall p q:R, cos p + cos q = 2 * cos ((p - q) / 2) * cos ((p + q) / 2).
Lemma form2 : forall p q:R, cos p - cos q = -2 * sin ((p - q) / 2) * sin ((p + q) / 2).
Lemma form3 : forall p q:R, sin p + sin q = 2 * cos ((p - q) / 2) * sin ((p + q) / 2).
Lemma form4 : forall p q:R, sin p - sin q = 2 * cos ((p + q) / 2) * sin ((p - q) / 2).
Lemma sin_increasing_0 : forall x y:R,   - (PI / 2) <= x ->   x <= PI / 2 -> - (PI / 2) <= y -> y <= PI / 2 -> sin x < sin y -> x < y.
Lemma sin_increasing_1 : forall x y:R,   - (PI / 2) <= x ->   x <= PI / 2 -> - (PI / 2) <= y -> y <= PI / 2 -> x < y -> sin x < sin y.
Lemma sin_decreasing_0 : forall x y:R,   x <= 3 * (PI / 2) ->   PI / 2 <= x -> y <= 3 * (PI / 2) -> PI / 2 <= y -> sin x < sin y -> y < x.
Lemma sin_decreasing_1 : forall x y:R,   x <= 3 * (PI / 2) ->   PI / 2 <= x -> y <= 3 * (PI / 2) -> PI / 2 <= y -> x < y -> sin y < sin x.
Lemma cos_increasing_0 : forall x y:R,   PI <= x -> x <= 2 * PI -> PI <= y -> y <= 2 * PI -> cos x < cos y -> x < y.
Lemma cos_increasing_1 : forall x y:R,   PI <= x -> x <= 2 * PI -> PI <= y -> y <= 2 * PI -> x < y -> cos x < cos y.
Lemma cos_decreasing_0 : forall x y:R,   0 <= x -> x <= PI -> 0 <= y -> y <= PI -> cos x < cos y -> y < x.
Lemma cos_decreasing_1 : forall x y:R,   0 <= x -> x <= PI -> 0 <= y -> y <= PI -> x < y -> cos y < cos x.
Lemma tan_diff : forall x y:R,   cos x <> 0 -> cos y <> 0 -> tan x - tan y = sin (x - y) / (cos x * cos y).
Lemma tan_increasing_0 : forall x y:R,   - (PI / 4) <= x ->   x <= PI / 4 -> - (PI / 4) <= y -> y <= PI / 4 -> tan x < tan y -> x < y.
Lemma tan_increasing_1 : forall x y:R,   - (PI / 4) <= x ->   x <= PI / 4 -> - (PI / 4) <= y -> y <= PI / 4 -> x < y -> tan x < tan y.
Lemma sin_incr_0 : forall x y:R,   - (PI / 2) <= x ->   x <= PI / 2 -> - (PI / 2) <= y -> y <= PI / 2 -> sin x <= sin y -> x <= y.
Lemma sin_incr_1 : forall x y:R,   - (PI / 2) <= x ->   x <= PI / 2 -> - (PI / 2) <= y -> y <= PI / 2 -> x <= y -> sin x <= sin y.
Lemma sin_decr_0 : forall x y:R,   x <= 3 * (PI / 2) ->   PI / 2 <= x ->   y <= 3 * (PI / 2) -> PI / 2 <= y -> sin x <= sin y -> y <= x.
Lemma sin_decr_1 : forall x y:R,   x <= 3 * (PI / 2) ->   PI / 2 <= x ->   y <= 3 * (PI / 2) -> PI / 2 <= y -> x <= y -> sin y <= sin x.
Lemma cos_incr_0 : forall x y:R,   PI <= x ->   x <= 2 * PI -> PI <= y -> y <= 2 * PI -> cos x <= cos y -> x <= y.
Lemma cos_incr_1 : forall x y:R,   PI <= x ->   x <= 2 * PI -> PI <= y -> y <= 2 * PI -> x <= y -> cos x <= cos y.
Lemma cos_decr_0 : forall x y:R,   0 <= x -> x <= PI -> 0 <= y -> y <= PI -> cos x <= cos y -> y <= x.
Lemma cos_decr_1 : forall x y:R,   0 <= x -> x <= PI -> 0 <= y -> y <= PI -> x <= y -> cos y <= cos x.
Lemma tan_incr_0 : forall x y:R,   - (PI / 4) <= x ->   x <= PI / 4 -> - (PI / 4) <= y -> y <= PI / 4 -> tan x <= tan y -> x <= y.
Lemma tan_incr_1 : forall x y:R,   - (PI / 4) <= x ->   x <= PI / 4 -> - (PI / 4) <= y -> y <= PI / 4 -> x <= y -> tan x <= tan y.
Lemma sin_eq_0_1 : forall x:R, (exists k : Z, x = IZR k * PI) -> sin x = 0.
Lemma sin_eq_0_0 (x:R) : sin x = 0 ->  exists k : Z, x = IZR k * PI.
Lemma cos_eq_0_0 (x:R) : cos x = 0 ->  exists k : Z, x = IZR k * PI + PI / 2.
Lemma cos_eq_0_1 (x:R) : (exists k : Z, x = IZR k * PI + PI / 2) -> cos x = 0.
Lemma sin_eq_O_2PI_0 (x:R) : 0 <= x -> x <= 2 * PI -> sin x = 0 -> x = 0 \/ x = PI \/ x = 2 * PI.
Lemma sin_eq_O_2PI_1 (x:R) : 0 <= x -> x <= 2 * PI -> x = 0 \/ x = PI \/ x = 2 * PI -> sin x = 0.
Lemma cos_eq_0_2PI_0 (x:R) : 0 <= x -> x <= 2 * PI -> cos x = 0 -> x = PI / 2 \/ x = 3 * (PI / 2).
Lemma cos_eq_0_2PI_1 (x:R) : 0 <= x -> x <= 2 * PI -> x = PI / 2 \/ x = 3 * (PI / 2) -> cos x = 0.
Lemma decide_left : forall (C:Prop) (decide:{C}+{~C}), C -> forall P:{C}+{~C}->Prop, (forall H:C, P (left _ H)) -> P decide.
Lemma decide_right : forall (C:Prop) (decide:{C}+{~C}), ~C -> forall P:{C}+{~C}->Prop, (forall H:~C, P (right _ H)) -> P decide.
Lemma mem_spec : mem x s = true <-> In x s.
Lemma equal_spec : equal s s' = true <-> Equal s s'.
Lemma subset_spec : subset s s' = true <-> Subset s s'.
Lemma empty_spec : Empty empty.
Lemma is_empty_spec : is_empty s = true <-> Empty s.
Lemma add_spec : In y (add x s) <-> E.eq y x \/ In y s.
Lemma remove_spec : In y (remove x s) <-> In y s /\ ~E.eq y x.
Lemma singleton_spec : In y (singleton x) <-> E.eq y x.
Lemma union_spec : In x (union s s') <-> In x s \/ In x s'.
Lemma inter_spec : In x (inter s s') <-> In x s /\ In x s'.
Lemma diff_spec : In x (diff s s') <-> In x s /\ ~In x s'.
Lemma fold_spec : forall (A : Type) (i : A) (f : elt -> A -> A),     fold f s i = fold_left (fun a e => f e a) (elements s) i.
Lemma cardinal_spec : cardinal s = length (elements s).
Lemma filter_spec : compatb f ->   (In x (filter f s) <-> In x s /\ f x = true).
Lemma for_all_spec : compatb f ->   (for_all f s = true <-> For_all (fun x => f x = true) s).
Lemma exists_spec : compatb f ->   (exists_ f s = true <-> Exists (fun x => f x = true) s).
Lemma partition_spec1 : compatb f -> Equal (fst (partition f s)) (filter f s).
Lemma partition_spec2 : compatb f ->     Equal (snd (partition f s)) (filter (fun x => negb (f x)) s).
Lemma elements_spec1 : InA E.eq x (elements s) <-> In x s.
Lemma elements_spec2w : NoDupA E.eq (elements s).
Lemma choose_spec1 : choose s = Some x -> In x s.
Lemma choose_spec2 : choose s = None -> Empty s.
Lemma compare_spec : CompSpec eq lt s s' (compare s s').
Lemma elements_spec2 : sort O.lt (elements s).
Lemma min_elt_spec1 : min_elt s = Some x -> In x s.
Lemma min_elt_spec2 : min_elt s = Some x -> In y s -> ~ O.lt y x.
Lemma min_elt_spec3 : min_elt s = None -> Empty s.
Lemma max_elt_spec1 : max_elt s = Some x -> In x s.
Lemma max_elt_spec2 : max_elt s = Some x -> In y s -> ~ O.lt x y.
Lemma max_elt_spec3 : max_elt s = None -> Empty s.
Lemma choose_spec3 :   choose s = Some x -> choose s' = Some y -> Equal s s' -> O.eq x y.
Lemma lt_empty_r : forall s s', Empty s' -> ~ lt s s'.
Lemma lt_empty_l : forall x s1 s2 s2', Empty s1 -> Above x s2 -> Add x s2 s2' -> lt s1 s2'.
Lemma lt_add_lt : forall x1 x2 s1 s1' s2 s2',  Above x1 s1 -> Above x2 s2 -> Add x1 s1 s1' -> Add x2 s2 s2' ->  O.lt x1 x2 -> lt s1' s2'.
Lemma lt_add_eq : forall x1 x2 s1 s1' s2 s2',  Above x1 s1 -> Above x2 s2 -> Add x1 s1 s1' -> Add x2 s2 s2' ->  O.eq x1 x2 -> lt s1 s2 -> lt s1' s2'.
Lemma eq_cons : forall l1 l2 x y, O.eq x y -> eq l1 l2 -> eq (x :: l1) (y :: l2).
Lemma cons_CompSpec : forall c x1 x2 l1 l2, O.eq x1 x2 ->
Lemma Qpower_positive_1 : forall n, Qpower_positive 1 n == 1.
Lemma Qpower_1 : forall n, 1^n == 1.
Lemma Qpower_positive_0 : forall n, Qpower_positive 0 n == 0.
Lemma Qpower_0 : forall n, (n<>0)%Z -> 0^n == 0.
Lemma Qpower_not_0_positive : forall a n, ~a==0 -> ~Qpower_positive a n == 0.
Lemma Qpower_pos_positive : forall p n, 0 <= p -> 0 <= Qpower_positive p n.
Lemma Qpower_pos : forall p n, 0 <= p -> 0 <= p^n.
Lemma Qmult_power_positive  : forall a b n, Qpower_positive (a*b) n == (Qpower_positive a n)*(Qpower_positive b n).
Lemma Qmult_power : forall a b n, (a*b)^n == a^n*b^n.
Lemma Qinv_power_positive  : forall a n, Qpower_positive (/a) n == /(Qpower_positive a n).
Lemma Qinv_power : forall a n, (/a)^n == /a^n.
Lemma Qdiv_power : forall a b n, (a/b)^n == (a^n/b^n).
Lemma Qinv_power_n : forall n p, (1#p)^n == /(inject_Z ('p))^n.
Lemma Qpower_plus_positive : forall a n m, Qpower_positive a (n+m) == (Qpower_positive a n)*(Qpower_positive a m).
Lemma Qpower_opp : forall a n, a^(-n) == /a^n.
Lemma Qpower_minus_positive : forall a (n m:positive), (m < n)%positive -> Qpower_positive a (n-m)%positive == (Qpower_positive a n)/(Qpower_positive a m).
Lemma Qpower_plus : forall a n m, ~a==0 -> a^(n+m) == a^n*a^m.
Lemma Qpower_plus' : forall a n m, (n+m <> 0)%Z -> a^(n+m) == a^n*a^m.
Lemma Qpower_mult_positive : forall a n m, Qpower_positive a (n*m) == Qpower_positive (Qpower_positive a n) m.
Lemma Qpower_mult : forall a n m, a^(n*m) ==  (a^n)^m.
Lemma Zpower_Qpower : forall (a n:Z), (0<=n)%Z -> inject_Z (a^n) == (inject_Z a)^n.
Lemma Qsqr_nonneg : forall a, 0 <= a^2.
Lemma N_to_Z_pos : forall x, (NN.to_Z x <> NN.to_Z NN.zero)%Z -> (0 < NN.to_Z x)%Z.
Lemma spec_0: [zero] == 0.
Lemma spec_1: [one] == 1.
Lemma spec_m1: [minus_one] == -(1).
Lemma spec_min : forall n m, [min n m] == Qmin [n] [m].
Lemma spec_max : forall n m, [max n m] == Qmax [n] [m].
Lemma spec_norm_denum : forall n d, [norm_denum n d] == [Qq n d].
Lemma spec_irred : forall n d, exists g, let (n',d') := irred n d in (ZZ.to_Z n' * g = ZZ.to_Z n)%Z /\ (NN.to_Z d' * g = NN.to_Z d)%Z.
Lemma spec_irred_zero : forall n d,  (NN.to_Z d = 0)%Z <-> (NN.to_Z (snd (irred n d)) = 0)%Z.
Lemma strong_spec_irred : forall n d, (NN.to_Z d <> 0%Z) ->
Lemma spec_mul_norm_Qz_Qq : forall z n d,  [mul_norm_Qz_Qq z n d] == [Qq (ZZ.mul z n) d].
Lemma quot_div_nonneg : forall a b, 0<=a -> 0<b -> a÷b == a/b.
Lemma rem_mod_nonneg : forall a b, 0<=a -> 0<b -> a rem b == a mod b.
Lemma quot_div : forall a b, b~=0 -> a÷b == (sgn a)*(sgn b)*(abs a / abs b).
Lemma rem_mod : forall a b, b~=0 -> a rem b == (sgn a) * ((abs a) mod (abs b)).
Lemma mod_divide : forall a b, b~=0 -> (a mod b == 0 <-> (b|a)).
Lemma rem_divide : forall a b, b~=0 -> (a rem b == 0 <-> (b|a)).
Lemma rem_mod_eq_0 : forall a b, b~=0 -> (a rem b == 0 <-> a mod b == 0).
Lemma quot_div_exact : forall a b, b~=0 -> (b|a) -> a÷b == a/b.
Lemma divide_div_mul_exact : forall a b c, b~=0 -> (b|a) -> (c*a)/b == c*(a/b).
Lemma divide_quot_mul_exact : forall a b c, b~=0 -> (b|a) -> (c*a)÷b == c*(a÷b).
Lemma gcd_div_factor : forall a b c, 0<c -> (c|a) -> (c|b) -> gcd (a/c) (b/c) == (gcd a b)/c.
Lemma gcd_quot_factor : forall a b c, 0<c -> (c|a) -> (c|b) -> gcd (a÷c) (b÷c) == (gcd a b)÷c.
Lemma gcd_div_gcd : forall a b g, g~=0 -> g == gcd a b -> gcd (a/g) (b/g) == 1.
Lemma gcd_quot_gcd : forall a b g, g~=0 -> g == gcd a b -> gcd (a÷g) (b÷g) == 1.
Lemma gcd_mod : forall a b, b~=0 -> gcd (a mod b) b == gcd b a.
Lemma gcd_rem : forall a b, b~=0 -> gcd (a rem b) b == gcd b a.
Lemma lcm_equiv1 : forall a b, gcd a b ~= 0 -> a * (b / gcd a b) == (a*b)/gcd a b.
Lemma lcm_equiv2 : forall a b, gcd a b ~= 0 -> (a / gcd a b) * b == (a*b)/gcd a b.
Lemma gcd_div_swap : forall a b, (a / gcd a b) * b == a * (b / gcd a b).
Lemma divide_lcm_l : forall a b, (a | lcm a b).
Lemma divide_lcm_r : forall a b, (b | lcm a b).
Lemma divide_div : forall a b c, a~=0 -> (a|b) -> (b|c) -> (b/a|c/a).
Lemma lcm_least : forall a b c, (a | c) -> (b | c) -> (lcm a b | c).
Lemma lcm_nonneg : forall a b, 0 <= lcm a b.
Lemma lcm_comm : forall a b, lcm a b == lcm b a.
Lemma lcm_divide_iff : forall n m p, (lcm n m | p) <-> (n | p) /\ (m | p).
Lemma lcm_unique : forall n m p, 0<=p -> (n|p) -> (m|p) -> (forall q, (n|q) -> (m|q) -> (p|q)) -> lcm n m == p.
Lemma lcm_unique_alt : forall n m p, 0<=p -> (forall q, (p|q) <-> (n|q) /\ (m|q)) -> lcm n m == p.
Lemma lcm_assoc : forall n m p, lcm n (lcm m p) == lcm (lcm n m) p.
Lemma lcm_0_l : forall n, lcm 0 n == 0.
Lemma lcm_0_r : forall n, lcm n 0 == 0.
Lemma lcm_1_l_nonneg : forall n, 0<=n -> lcm 1 n == n.
Lemma lcm_1_r_nonneg : forall n, 0<=n -> lcm n 1 == n.
Lemma lcm_diag_nonneg : forall n, 0<=n -> lcm n n == n.
Lemma lcm_eq_0 : forall n m, lcm n m == 0 <-> n == 0 \/ m == 0.
Lemma divide_lcm_eq_r : forall n m, 0<=m -> (n|m) -> lcm n m == m.
Lemma divide_lcm_iff : forall n m, 0<=m -> ((n|m) <-> lcm n m == m).
Lemma lcm_opp_l : forall n m, lcm (-n) m == lcm n m.
Lemma lcm_opp_r : forall n m, lcm n (-m) == lcm n m.
Lemma lcm_abs_l : forall n m, lcm (abs n) m == lcm n m.
Lemma lcm_abs_r : forall n m, lcm n (abs m) == lcm n m.
Lemma lcm_1_l : forall n, lcm 1 n == abs n.
Lemma lcm_1_r : forall n, lcm n 1 == abs n.
Lemma lcm_diag : forall n, lcm n n == abs n.
Lemma lcm_mul_mono_l : forall n m p, lcm (p * n) (p * m) == abs p * lcm n m.
Lemma lcm_mul_mono_l_nonneg : forall n m p, 0<=p -> lcm (p*n) (p*m) == p * lcm n m.
Lemma lcm_mul_mono_r : forall n m p, lcm (n * p) (m * p) == lcm n m * abs p.
Lemma lcm_mul_mono_r_nonneg : forall n m p, 0<=p -> lcm (n*p) (m*p) == lcm n m * p.
Lemma gcd_1_lcm_mul : forall n m, n~=0 -> m~=0 -> (gcd n m == 1 <-> lcm n m == abs (n*m)).
Lemma In_1: forall s x y, E.eq x y -> In x s -> In y s.
Lemma eq_refl: forall s, eq s s.
Lemma eq_sym: forall s s', eq s s' -> eq s' s.
Lemma eq_trans: forall s s' s'', eq s s' -> eq s' s'' -> eq s s''.
Lemma mem_1: forall s x, In x s -> mem x s = true.
Lemma mem_2: forall s x, mem x s = true -> In x s.
Lemma mem_Leaf: forall x, mem x Leaf = false.
Lemma empty_1 : Empty empty.
Lemma mem_node: forall x l o r, mem x (node l o r) = mem x (Node l o r).
Lemma is_empty_spec: forall s, Empty s <-> is_empty s = true.
Lemma is_empty_1: forall s, Empty s -> is_empty s = true.
Lemma is_empty_2: forall s, is_empty s = true -> Empty s.
Lemma subset_Leaf_s: forall s, Leaf [<=] s.
Lemma subset_spec: forall s s', s [<=] s' <-> subset s s' = true.
Lemma subset_1: forall s s', Subset s s' -> subset s s' = true.
Lemma subset_2: forall s s', subset s s' = true -> Subset s s'.
Lemma equal_subset: forall s s', equal s s' = subset s s' && subset s' s.
Lemma equal_spec: forall s s', Equal s s' <-> equal s s' = true.
Lemma equal_1: forall s s', Equal s s' -> equal s s' = true.
Lemma equal_2: forall s s', equal s s' = true -> Equal s s'.
Lemma eq_dec : forall s s', { eq s s' } + { ~ eq s s' }.
Lemma lex_Opp: forall u v u' v', u = CompOpp u' -> v = CompOpp v' ->   lex u v = CompOpp (lex u' v').
Lemma compare_bool_inv: forall b b',   compare_bool b b' = CompOpp (compare_bool b' b).
Lemma compare_inv: forall s s', compare_fun s s' = CompOpp (compare_fun s' s).
Lemma lex_Eq: forall u v, lex u v = Eq <-> u=Eq /\ v=Eq.
Lemma compare_bool_Eq: forall b1 b2,   compare_bool b1 b2 = Eq <-> eqb b1 b2 = true.
Lemma compare_equal: forall s s', compare_fun s s' = Eq <-> equal s s' = true.
Lemma compare_gt: forall s s', compare_fun s s' = Gt -> lt s' s.
Lemma compare_eq: forall s s', compare_fun s s' = Eq -> eq s s'.
Lemma compare : forall s s' : t, Compare lt eq s s'.
Lemma ct_cxe: forall x, ct (CompOpp x) x Eq.
Lemma ct_xce: forall x, ct x (CompOpp x) Eq.
Lemma ct_lxl: forall x, ct Lt x Lt.
Lemma ct_gxg: forall x, ct Gt x Gt.
Lemma ct_xll: forall x, ct x Lt Lt.
Lemma ct_xgg: forall x, ct x Gt Gt.
Lemma ct_lex: forall u v w u' v' w',   ct u v w -> ct u' v' w' -> ct (lex u u') (lex v v') (lex w w').
Lemma ct_compare_bool:   forall a b c, ct (compare_bool a b) (compare_bool b c) (compare_bool a c).
Lemma compare_x_Leaf: forall s,   compare_fun s Leaf = if is_empty s then Eq else Gt.
Lemma compare_empty_x: forall a, is_empty a = true ->   forall b, compare_fun a b = if is_empty b then Eq else Lt.
Lemma compare_x_empty: forall a, is_empty a = true ->   forall b, compare_fun b a = if is_empty b then Eq else Gt.
Lemma ct_compare_fun:   forall a b c, ct (compare_fun a b) (compare_fun b c) (compare_fun a c).
Lemma lt_trans: forall s s' s'', lt s s' -> lt s' s'' -> lt s s''.
Lemma lt_not_eq: forall s s', lt s s' -> ~ eq s s'.
Lemma add_spec: forall x y s, In y (add x s) <-> x=y \/ In y s.
Lemma add_1: forall s x y, x = y -> In y (add x s).
Lemma add_2: forall s x y, In y s -> In y (add x s).
Lemma add_3: forall s x y, x<>y -> In y (add x s) -> In y s.
Lemma remove_spec: forall x y s, In y (remove x s) <-> x<>y /\ In y s.
Lemma remove_1: forall s x y, x=y -> ~ In y (remove x s).
Lemma remove_2: forall s x y, x<>y -> In y s -> In y (remove x s).
Lemma remove_3: forall s x y, In y (remove x s) -> In y s.
Lemma singleton_1: forall x y, In y (singleton x) -> x=y.
Lemma singleton_2: forall x y, x = y -> In y (singleton x).
Lemma union_spec: forall x s s', In x (union s s') <-> In x s \/ In x s'.
Lemma union_1: forall s s' x, In x (union s s') -> In x s \/ In x s'.
Lemma union_2: forall s s' x, In x s -> In x (union s s').
Lemma union_3: forall s s' x, In x s' -> In x (union s s').
Lemma inter_spec: forall x s s', In x (inter s s') <-> In x s /\ In x s'.
Lemma inter_1: forall s s' x, In x (inter s s') -> In x s.
Lemma inter_2: forall s s' x, In x (inter s s') -> In x s'.
Lemma inter_3: forall s s' x, In x s -> In x s' -> In x (inter s s').
Lemma diff_spec: forall x s s', In x (diff s s') <-> In x s /\ ~ In x s'.
Lemma diff_1: forall s s' x, In x (diff s s') -> In x s.
Lemma diff_2: forall s s' x, In x (diff s s') -> ~ In x s'.
Lemma diff_3: forall s s' x, In x s -> ~ In x s' -> In x (diff s s').
Lemma fold_1: forall s (A : Type) (i : A) (f : elt -> A -> A),     fold f s i = fold_left (fun a e => f e a) (elements s) i.
Lemma cardinal_1: forall s, cardinal s = length (elements s).
Lemma xfilter_spec: forall f s x i,   In x (xfilter f s i) <-> In x s /\ f (i@x) = true.
Lemma filter_1 : forall s x f, compat_bool E.eq f ->
Lemma filter_2 : forall s x f, compat_bool E.eq f ->
Lemma filter_3 : forall s x f, compat_bool E.eq f -> In x s ->
Lemma xforall_spec: forall f s i,   xforall f s i = true <-> For_all (fun x => f (i@x) = true) s.
Lemma for_all_1 : forall s f, compat_bool E.eq f ->
Lemma for_all_2 : forall s f, compat_bool E.eq f ->
Lemma xexists_spec: forall f s i,   xexists f s i = true <-> Exists (fun x => f (i@x) = true) s.
Lemma exists_1 : forall s f, compat_bool E.eq f ->
Lemma exists_2 : forall s f, compat_bool E.eq f ->
Lemma partition_filter : forall s f,   partition f s = (filter f s, filter (fun x => negb (f x)) s).
Lemma partition_1 : forall s f, compat_bool E.eq f ->
Lemma partition_2 : forall s f, compat_bool E.eq f ->
Lemma xelements_spec: forall s j acc y,   InL y (xelements s j acc)   <->   InL y acc \/ exists x, y=(j@x) /\ mem x s = true.
Lemma elements_1: forall s x, In x s -> InL x (elements s).
Lemma elements_2: forall s x, InL x (elements s) -> In x s.
Lemma lt_rev_append: forall j x y, E.lt x y -> E.lt (j@x) (j@y).
Lemma elements_3: forall s, sort E.lt (elements s).
Lemma elements_3w: forall s, NoDupA E.eq (elements s).
Lemma choose_1: forall s x, choose s = Some x -> In x s.
Lemma choose_2: forall s, choose s = None -> Empty s.
Lemma choose_empty: forall s, is_empty s = true -> choose s = None.
Lemma choose_3': forall s s', Equal s s' -> choose s = choose s'.
Lemma choose_3: forall s s' x y,   choose s = Some x -> choose s' = Some y -> Equal s s' -> E.eq x y.
Lemma min_elt_1: forall s x, min_elt s = Some x -> In x s.
Lemma min_elt_3: forall s, min_elt s = None -> Empty s.
Lemma min_elt_2: forall s x y, min_elt s = Some x -> In y s -> ~ E.lt y x.
Lemma max_elt_1: forall s x, max_elt s = Some x -> In x s.
Lemma max_elt_3: forall s, max_elt s = None -> Empty s.
Lemma max_elt_2: forall s x y, max_elt s = Some x -> In y s -> ~ E.lt x y.
Lemma eq_refl : forall x, eq x x.
Lemma eq_sym : forall x y, eq x y -> eq y x.
Lemma lt_not_eq : forall x y, lt x y -> ~eq x y.
Lemma compare_sym :  forall x y, (y?=x) = CompOpp (x?=y).
Lemma compare_trans :  forall c x y z, (x?=y) = c -> (y?=z) = c -> (x?=z) = c.
Lemma Qred_identity : forall q:Q, Z.gcd (Qnum q) (QDen q) = 1%Z -> Qred q = q.
Lemma Qred_identity2 : forall q:Q, Qred q = q -> Z.gcd (Qnum q) (QDen q) = 1%Z.
Lemma Qred_iff : forall q:Q, Qred q = q <-> Z.gcd (Qnum q) (QDen q) = 1%Z.
Lemma Qred_involutive : forall q:Q, Qred (Qred q) = Qred q.
Lemma Qc_is_canon : forall q q' : Qc, q == q' -> q = q'.
Lemma Qceq_alt : forall p q, (p = q) <-> (p ?= q) = Eq.
Lemma Qclt_alt : forall p q, (p<q) <-> (p?=q = Lt).
Lemma Qcgt_alt : forall p q, (p>q) <-> (p?=q = Gt).
Lemma Qle_alt : forall p q, (p<=q) <-> (p?=q <> Gt).
Lemma Qge_alt : forall p q, (p>=q) <-> (p?=q <> Lt).
Lemma Q_apart_0_1 : 1 <> 0.
Lemma Qcplus_0_l : forall x, 0+x = x.
Lemma Qcplus_0_r : forall x, x+0 = x.
Lemma Qcopp_involutive : forall q, - -q = q.
Lemma Qcmult_1_l : forall n, 1*n = n.
Lemma Qcinv_mult_distr : forall p q, / (p * q) = /p * /q.
Lemma Qcle_refl : forall x, x<=x.
Lemma Qcle_antisym : forall x y, x<=y -> y<=x -> x=y.
Lemma Qcle_trans : forall x y z, x<=y -> y<=z -> x<=z.
Lemma Qclt_not_eq : forall x y, x<y -> x<>y.
Lemma Qclt_le_weak : forall x y, x<y -> x<=y.
Lemma Qcle_lt_trans : forall x y z, x<=y -> y<z -> x<z.
Lemma Qclt_le_trans : forall x y z, x<y -> y<=z -> x<z.
Lemma Qclt_trans : forall x y z, x<y -> y<z -> x<z.
Lemma Qcnot_lt_le : forall x y, ~ x<y -> y<=x.
Lemma Qcnot_le_lt : forall x y, ~ x<=y -> y<x.
Lemma Qclt_not_le : forall x y, x<y -> ~ y<=x.
Lemma Qcle_not_lt : forall x y, x<=y -> ~ y<x.
Lemma Qcle_lt_or_eq : forall x y, x<=y -> x<y \/ x==y.
Lemma Qc_dec : forall x y, {x<y} + {y<x} + {x=y}.
Lemma Qclt_le_dec : forall x y, {x<y} + {y<=x}.
Lemma Qcopp_le_compat : forall p q, p<=q -> -q <= -p.
Lemma Qcle_minus_iff : forall p q, p <= q <-> 0 <= q+-p.
Lemma Qclt_minus_iff : forall p q, p < q <-> 0 < q+-p.
Lemma Qcplus_le_compat : forall x y z t, x<=y -> z<=t -> x+z <= y+t.
Lemma Qcmult_le_compat_r : forall x y z, x <= y -> 0 <= z -> x*z <= y*z.
Lemma Qcmult_lt_0_le_reg_r : forall x y z, 0 <  z  -> x*z <= y*z -> x <= y.
Lemma Qcmult_lt_compat_r : forall x y z, 0 < z  -> x < y -> x*z < y*z.
Lemma Qcpower_1 : forall n, 1^n = 1.
Lemma Qcpower_0 : forall n, n<>O -> 0^n = 0.
Lemma Qcpower_pos : forall p n, 0 <= p -> 0 <= p^n.
Lemma Qc_eq_bool_correct : forall x y : Qc, Qc_eq_bool x y = true -> x=y.
Lemma InA_eqke_eqk :    forall x m, InA eqke x m -> InA eqk x m.
Lemma InA_eqk : forall p q m, eqk p q -> InA eqk p m -> InA eqk q m.
Lemma In_alt : forall k l, In k l <-> exists e, InA eqk (k,e) l.
Lemma In_alt2 : forall k l, In k l <-> Exists (fun p => eq k (fst p)) l.
Lemma In_nil : forall k, In k nil <-> False.
Lemma In_cons : forall k p l,  In k (p::l) <-> eq k (fst p) \/ In k l.
Lemma MapsTo_eq : forall l x y e, eq x y -> MapsTo x e l -> MapsTo y e l.
Lemma In_eq : forall l x y, eq x y -> In x l -> In y l.
Lemma In_inv : forall k k' e l, In k ((k',e) :: l) -> eq k k' \/ In k l.
Lemma In_inv_2 : forall k k' e e' l,     InA eqk (k, e) ((k', e') :: l) -> ~ eq k k' -> InA eqk (k, e) l.
Lemma In_inv_3 : forall x x' l,     InA eqke x (x' :: l) -> ~ eqk x x' -> InA eqke x l.
Lemma Iftrue_inv : forall (A B:Prop) (b:bool), IfProp A B b -> b = true -> A.
Lemma Iffalse_inv : forall (A B:Prop) (b:bool), IfProp A B b -> b = false -> B.
Lemma IfProp_true : forall A B:Prop, IfProp A B true -> A.
Lemma IfProp_false : forall A B:Prop, IfProp A B false -> B.
Lemma IfProp_or : forall (A B:Prop) (b:bool), IfProp A B b -> A \/ B.
Lemma IfProp_sum : forall (A B:Prop) (b:bool), IfProp A B b -> {A} + {B}.
Lemma Qred_correct : forall q, (Qred q) == q.
Lemma Qred_complete : forall p q,  p==q -> Qred p = Qred q.
Lemma Qplus'_correct : forall p q : Q, (Qplus' p q)==(Qplus p q).
Lemma Qmult'_correct : forall p q : Q, (Qmult' p q)==(Qmult p q).
Lemma Qminus'_correct : forall p q : Q, (Qminus' p q)==(Qminus p q).
Lemma Qred_opp: forall q, Qred (-q) = - (Qred q).
Lemma Zcompare_Gt_Lt_antisym : forall n m:Z, (n ?= m) = Gt <-> (m ?= n) = Lt.
Lemma Zcompare_antisym n m : CompOpp (n ?= m) = (m ?= n).
Lemma Zcompare_Lt_trans : forall n m p:Z, (n ?= m) = Lt -> (m ?= p) = Lt -> (n ?= p) = Lt.
Lemma Zcompare_Gt_trans : forall n m p:Z, (n ?= m) = Gt -> (m ?= p) = Gt -> (n ?= p) = Gt.
Lemma Zcompare_opp n m : (n ?= m) = (- m ?= - n).
Lemma Zcompare_Gt_spec n m : (n ?= m) = Gt ->  exists h, n + - m = Zpos h.
Lemma Zcompare_plus_compat n m p : (p + n ?= p + m) = (n ?= m).
Lemma Zplus_compare_compat (r:comparison) (n m p q:Z) : (n ?= m) = r -> (p ?= q) = r -> (n + p ?= m + q) = r.
Lemma Zcompare_succ_Gt n : (Z.succ n ?= n) = Gt.
Lemma Zcompare_Gt_not_Lt n m : (n ?= m) = Gt <-> (n ?= m+1) <> Lt.
Lemma Zcompare_succ_compat n m : (Z.succ n ?= Z.succ m) = (n ?= m).
Lemma Zcompare_mult_compat : forall (p:positive) (n m:Z), (Zpos p * n ?= Zpos p * m) = (n ?= m).
Lemma Zmult_compare_compat_l n m p: p > 0 -> (n ?= m) = (p * n ?= p * m).
Lemma Zmult_compare_compat_r n m p : p > 0 -> (n ?= m) = (n * p ?= m * p).
Lemma Zcompare_elim : forall (c1 c2 c3:Prop) (n m:Z),   (n = m -> c1) ->   (n < m -> c2) ->   (n > m -> c3) -> match n ?= m with                      | Eq => c1                      | Lt => c2                      | Gt => c3                    end.
Lemma Zcompare_eq_case : forall (c1 c2 c3:Prop) (n m:Z),   c1 -> n = m -> match n ?= m with                    | Eq => c1                    | Lt => c2                    | Gt => c3                  end.
Lemma Zle_compare : forall n m:Z,   n <= m -> match n ?= m with 	| Eq => True 	| Lt => True 	| Gt => False             end.
Lemma Zlt_compare : forall n m:Z,  n < m -> match n ?= m with             | Eq => False             | Lt => True             | Gt => False           end.
Lemma Zge_compare : forall n m:Z,   n >= m -> match n ?= m with 	| Eq => True 	| Lt => False 	| Gt => True             end.
Lemma Zgt_compare : forall n m:Z,   n > m -> match n ?= m with              | Eq => False              | Lt => False              | Gt => True            end.
Lemma divide_add_cancel_r : forall n m p, (n | m) -> (n | m + p) -> (n | p).
Lemma divide_sub_r : forall n m p, (n | m) -> (n | p) -> (n | m - p).
Lemma gcd_add_mult_diag_r : forall n m p, gcd n (m+p*n) == gcd n m.
Lemma gcd_add_diag_r : forall n m, gcd n (m+n) == gcd n m.
Lemma gcd_sub_diag_r : forall n m, n<=m -> gcd n (m-n) == gcd n m.
Lemma bezout_1_gcd : forall n m, Bezout n m 1 -> gcd n m == 1.
Lemma gcd_bezout_pos_pos : forall n, 0<n -> forall m, 0<m -> Bezout n m (gcd n m) /\ Bezout m n (gcd n m).
Lemma gcd_bezout_pos : forall n m, 0<n -> Bezout n m (gcd n m).
Lemma gcd_bezout : forall n m, Bezout n m (gcd n m) \/ Bezout m n (gcd n m).
Lemma gcd_mul_mono_l : forall n m p, gcd (p * n) (p * m) == p * gcd n m.
Lemma gcd_mul_mono_r : forall n m p, gcd (n*p) (m*p) == gcd n m * p.
Lemma gauss : forall n m p, (n | m * p) -> gcd n m == 1 -> (n | p).
Lemma divide_mul_split : forall n m p, n ~= 0 -> (n | m * p) -> exists q r, n == q*r /\ (q | m) /\ (r | p).
Lemma nequiv_equiv_trans : forall `{Setoid A} (x y z : A), x =/= y -> y == z -> x =/= z.
Lemma equiv_nequiv_trans : forall `{Setoid A} (x y z : A), x == y -> y =/= z -> x =/= z.
Lemma less_than_empty :   forall X:Ensemble U, Included U X (Empty_set U) -> X = Empty_set U.
Lemma Union_absorbs :   forall A B:Ensemble U, Included U B A -> Union U A B = A.
Lemma singlx : forall x y:U, In U (Add U (Empty_set U) x) y -> x = y.
Lemma incl_add :   forall (A B:Ensemble U) (x:U),     Included U A B -> Included U (Add U A x) (Add U B x).
Lemma incl_add_x :   forall (A B:Ensemble U) (x:U),     ~ In U A x -> Included U (Add U A x) (Add U B x) -> Included U A B.
Lemma Add_commutative :   forall (A:Ensemble U) (x y:U), Add U (Add U A x) y = Add U (Add U A y) x.
Lemma Add_commutative' :   forall (A:Ensemble U) (x y z:U),     Add U (Add U (Add U A x) y) z = Add U (Add U (Add U A z) x) y.
Lemma Add_distributes :   forall (A B:Ensemble U) (x y:U),     Included U B A -> Add U (Add U A x) y = Union U (Add U A x) (Add U B y).
Lemma setcover_intro :   forall (U:Type) (A x y:Ensemble U),     Strict_Included U x y ->     ~ (exists z : _, Strict_Included U x z /\ Strict_Included U z y) ->     covers (Ensemble U) (Power_set_PO U A) y x.
Lemma minus_n_O : forall n, n = n - 0.
Lemma minus_Sn_m : forall n m, m <= n -> S (n - m) = S n - m.
Lemma minus_diag : forall n, n - n = 0.
Lemma minus_diag_reverse : forall n, 0 = n - n.
Lemma minus_plus_simpl_l_reverse : forall n m p, n - m = p + n - (p + m).
Lemma plus_minus : forall n m p, n = m + p -> p = n - m.
Lemma minus_plus : forall n m, n + m - n = m.
Lemma le_plus_minus : forall n m, n <= m -> m = n + (m - n).
Lemma le_plus_minus_r : forall n m, n <= m -> n + (m - n) = m.
Lemma lt_minus : forall n m, m <= n -> 0 < m -> n - m < n.
Lemma lt_O_minus_lt : forall n m, 0 < n - m -> m < n.
Lemma Zpower_nat_0_r z : Zpower_nat z 0 = 1.
Lemma Zpower_nat_succ_r n z : Zpower_nat z (S n) = z * (Zpower_nat z n).
Lemma Zpower_nat_is_exp : forall (n m:nat) (z:Z),   Zpower_nat z (n + m) = Zpower_nat z n * Zpower_nat z m.
Lemma Zpower_pos_nat (z : Z) (p : positive) : Z.pow_pos z p = Zpower_nat z (Pos.to_nat p).
Lemma Zpower_nat_Z (z : Z) (n : nat) : Zpower_nat z n = z ^ (Z.of_nat n).
Lemma Zpower_pos_is_exp (n m : positive)(z:Z) : Z.pow_pos z (n + m) = Z.pow_pos z n * Z.pow_pos z m.
Lemma shift_nat_equiv n p : shift_nat n p = Pos.shiftl_nat p n.
Lemma shift_pos_equiv n p : shift_pos n p = Pos.shiftl p (Npos n).
Lemma shift_equiv n p : 0<=n -> Zpos (shift n p) = Z.shiftl (Zpos p) n.
Lemma two_power_nat_equiv n : two_power_nat n = 2 ^ (Z.of_nat n).
Lemma two_power_pos_equiv p : two_power_pos p = 2 ^ Zpos p.
Lemma two_p_equiv x : two_p x = 2 ^ x.
Lemma two_power_nat_S n : two_power_nat (S n) = 2 * two_power_nat n.
Lemma shift_nat_plus n m x :   shift_nat (n + m) x = shift_nat n (shift_nat m x).
Lemma shift_pos_nat p x : shift_pos p x = shift_nat (Pos.to_nat p) x.
Lemma two_power_pos_nat p : two_power_pos p = two_power_nat (Pos.to_nat p).
Lemma two_p_correct x : two_p x = 2^x.
Lemma two_p_gt_ZERO x : 0 <= x -> two_p x > 0.
Lemma two_p_S x : 0 <= x -> two_p (Z.succ x) = 2 * two_p x.
Lemma two_p_pred x : 0 <= x -> two_p (Z.pred x) < two_p x.
Lemma Zdiv_rest_correct1 (x:Z) (p:positive) :   let (_, d) := Pos.iter p Zdiv_rest_aux (x, 0, 1) in
Lemma Zdiv_rest_correct2 (x:Z) (p:positive) :   let '(q,r,d) := Pos.iter p Zdiv_rest_aux (x, 0, 1) in
Lemma Zdiv_rest_correct (x:Z) (p:positive) : Zdiv_rest_proofs x p.
Lemma Zdiv_rest_ok x p :   let (q,r) := Zdiv_rest x p in   x = q * 2^(Zpos p) + r /\ 0 <= r < 2^(Zpos p).
Lemma Zdiv_rest_shiftr x p :  fst (Zdiv_rest x p) = Z.shiftr x (Zpos p).
Lemma le_elim_rel : forall P:nat -> nat -> Prop,  (forall p, P 0 p) ->  (forall p (q:nat), p <= q -> P p q -> P (S p) (S q)) ->  forall n m, n <= m -> P n m.
Lemma spec_same_level : forall A (P:Z->Z->A->Prop) (f : forall n, dom_t n -> dom_t n -> A), (forall n x y, P (ZnZ.to_Z x) (ZnZ.to_Z y) (f n x y)) ->
Lemma digits_dom_op_incr : forall n m, (n<=m)%nat -> (ZnZ.digits (dom_op n) <= ZnZ.digits (dom_op m))%positive.
Lemma succ_fold : succ = iter_t succn.
Lemma spec_2 : [two] = 2.
Lemma add_fold : add = same_level addn.
Lemma pred_fold : pred = iter_t predn.
Lemma spec_pred x : [pred x] = Z.max 0 ([x]-1).
Lemma sub_fold : sub = same_level subn.
Lemma spec_sub : forall x y, [sub x y] = Z.max 0 ([x]-[y]).
Lemma compare_fold : compare = compare_folded.
Lemma mul_fold : mul = mul_folded.
Lemma spec_muln:  forall n (x: word _ (S n)) y,    [Nn (S n) (ZnZ.mul_c (Ops:=make_op n) x y)] = [Nn n x] * [Nn n y].
Lemma spec_mul_add_n1: forall n m x y z, let (q,r) := DoubleMul.double_mul_add_n1 ZnZ.zero ZnZ.WW ZnZ.OW
Lemma spec_wn_mul : forall n m x y,  [wn_mul n m x y] = (eval n (S m) x) * ZnZ.to_Z y.
Lemma div_gt_fold : div_gt = div_gt_folded.
Lemma spec_get_endn: forall n m x y, eval n m x  <= [mk_t n y] ->  [mk_t n (DoubleBase.get_low (zeron n) m x)] = eval n m x.
Lemma spec_div_gt_aux : forall x y, [x] > [y] -> 0 < [y] ->  let (q,r) := div_gt x y in  [x] = [q] * [y] + [r] /\ 0 <= [r] < [y].
Lemma mod_gt_fold : mod_gt = mod_gt_folded.
Lemma square_fold : square = iter_t squaren.
Lemma sqrt_fold : sqrt = iter_t sqrtn.
Lemma digits_fold : digits = iter_t digitsn.
Lemma digits_level : forall x, digits x = ZnZ.digits (dom_op (level x)).
Lemma even_fold : even = iter_t (fun n x => ZnZ.is_even x).
Lemma head0_fold : head0 = iter_t head0n.
Lemma pow2_pos_minus_1 : forall z, 0<z -> 2^(z-1) = 2^z / 2.
Lemma tail0_fold : tail0 = iter_t tail0n.
Lemma Ndigits_fold : Ndigits = iter_t Ndigitsn.
Lemma log2_fold :  log2 = fun x => if eqb x zero then zero else iter_t log2n x.
Lemma spec_log2_0 : forall x, [x] = 0 -> [log2 x] = 0.
Lemma head0_zdigits : forall n (x : dom_t n), 0 < ZnZ.to_Z x ->
Lemma spec_log2_pos : forall x, [x]<>0 ->  2^[log2 x] <= [x] < 2^([log2 x]+1).
Lemma spec_log2 : forall x, [log2 x] = Z.log2 [x].
Lemma log2_digits_head0 : forall x, 0 < [x] ->  [log2 x] = Zpos (digits x) - [head0 x] - 1.
Lemma shiftr_fold : shiftr = same_level shiftrn.
Lemma div_pow2_bound :forall x y z,  0 <= x -> 0 <= y -> x < z -> 0 <= x / 2 ^ y < z.
Lemma spec_shiftr: forall x p, [shiftr x p] = Z.shiftr [x] [p].
Lemma unsafe_shiftl_fold : unsafe_shiftl = same_level unsafe_shiftln.
Lemma double_size_fold : double_size = iter_t double_size_n.
Lemma double_size_level : forall x, level (double_size x) = S (level x).
Lemma spec_shiftl: forall x p, [shiftl x p] = Z.shiftl [x] [p].
Lemma spec_testbit: forall x p, testbit x p = Z.testbit [x] [p].
Lemma spec_div2: forall x, [div2 x] = Z.div2 [x].
Lemma spec_land: forall x y, [land x y] = Z.land [x] [y].
Lemma spec_lor: forall x y, [lor x y] = Z.lor [x] [y].
Lemma spec_ldiff: forall x y, [ldiff x y] = Z.ldiff [x] [y].
Lemma spec_lxor: forall x y, [lxor x y] = Z.lxor [x] [y].
Lemma pos_pred_spec p : Pos.pred_N p = pred (pos p).
Lemma succ_pos_spec n : pos (succ_pos n) = succ n.
Lemma pos_pred_succ n : Pos.pred_N (succ_pos n) = n.
Lemma succ_pos_pred p : succ (Pos.pred_N p) = pos p.
Lemma eqb_eq n m : eqb n m = true <-> n=m.
Lemma ltb_lt n m : (n <? m) = true <-> n < m.
Lemma leb_le n m : (n <=? m) = true <-> n <= m.
Lemma sub_add n m : n <= m -> m - n + n = m.
Lemma le_0_l n : 0<=n.
Lemma leb_spec n m : BoolSpec (n<=m) (m<n) (n <=? m).
Lemma add_lt_cancel_l n m p : p+n < p+m -> n<m.
Lemma lt_succ_r n m : n < succ m <-> n<=m.
Lemma double_spec n : double n = 2 * n.
Lemma succ_double_spec n : succ_double n = 2 * n + 1.
Lemma double_add n m : double (n+m) = double n + double m.
Lemma succ_double_add n m : succ_double (n+m) = double n + succ_double m.
Lemma double_mul n m : double (n*m) = double n * m.
Lemma succ_double_mul n m : succ_double n * m = double n * m + m.
Lemma div2_double n : div2 (double n) = n.
Lemma div2_succ_double n : div2 (succ_double n) = n.
Lemma double_inj n m : double n = double m -> n = m.
Lemma succ_double_inj n m : succ_double n = succ_double m -> n = m.
Lemma succ_double_lt n m : n<m -> succ_double n < double m.
Lemma pow_0_r n : n ^ 0 = 1.
Lemma pow_succ_r n p : 0<=p -> n^(succ p) = n * n^p.
Lemma pow_neg_r n p : p<0 -> n^p = 0.
Lemma square_spec n : square n = n * n.
Lemma size_log2 n : n<>0 -> size n = succ (log2 n).
Lemma size_gt n : n < 2^(size n).
Lemma size_le n : 2^(size n) <= succ_double n.
Lemma log2_spec n : 0 < n -> 2^(log2 n) <= n < 2^(succ (log2 n)).
Lemma log2_nonpos n : n<=0 -> log2 n = 0.
Lemma even_spec n : even n = true <-> Even n.
Lemma odd_spec n : odd n = true <-> Odd n.
Lemma sqrtrem_sqrt n : fst (sqrtrem n) = sqrt n.
Lemma sqrtrem_spec n : let (s,r) := sqrtrem n in n = s*s + r /\ r <= 2*s.
Lemma sqrt_spec n : 0<=n -> let s := sqrt n in s*s <= n < (succ s)*(succ s).
Lemma sqrt_neg n : n<0 -> sqrt n = 0.
Lemma ggcd_gcd a b : fst (ggcd a b) = gcd a b.
Lemma ggcd_correct_divisors a b : let '(g,(aa,bb)) := ggcd a b in a=g*aa /\ b=g*bb.
Lemma gcd_divide_l a b : (gcd a b | a).
Lemma gcd_divide_r a b : (gcd a b | b).
Lemma gcd_greatest a b c : (c|a) -> (c|b) -> (c|gcd a b).
Lemma gcd_nonneg a b : 0 <= gcd a b.
Lemma testbit_even_0 a : testbit (2*a) 0 = false.
Lemma testbit_odd_0 a : testbit (2*a+1) 0 = true.
Lemma testbit_succ_r_div2 a n : 0<=n -> testbit a (succ n) = testbit (div2 a) n.
Lemma testbit_odd_succ a n : 0<=n -> testbit (2*a+1) (succ n) = testbit a n.
Lemma testbit_even_succ a n : 0<=n -> testbit (2*a) (succ n) = testbit a n.
Lemma testbit_neg_r a n : n<0 -> testbit a n = false.
Lemma shiftr_succ_r a n : shiftr a (succ n) = div2 (shiftr a n).
Lemma shiftl_succ_r a n : shiftl a (succ n) = double (shiftl a n).
Lemma shiftr_spec a n m : 0<=m -> testbit (shiftr a n) m = testbit a (m+n).
Lemma shiftl_spec_high a n m : 0<=m -> n<=m -> testbit (shiftl a n) m = testbit a (m-n).
Lemma shiftl_spec_low a n m : m<n -> testbit (shiftl a n) m = false.
Lemma pos_lxor_spec p p' n : testbit (Pos.lxor p p') n = xorb (Pos.testbit p n) (Pos.testbit p' n).
Lemma lxor_spec a a' n : testbit (lxor a a') n = xorb (testbit a n) (testbit a' n).
Lemma pos_lor_spec p p' n : Pos.testbit (Pos.lor p p') n = (Pos.testbit p n) || (Pos.testbit p' n).
Lemma lor_spec a a' n : testbit (lor a a') n = (testbit a n) || (testbit a' n).
Lemma pos_land_spec p p' n : testbit (Pos.land p p') n = (Pos.testbit p n) && (Pos.testbit p' n).
Lemma land_spec a a' n : testbit (land a a') n = (testbit a n) && (testbit a' n).
Lemma pos_ldiff_spec p p' n : testbit (Pos.ldiff p p') n = (Pos.testbit p n) && negb (Pos.testbit p' n).
Lemma ldiff_spec a a' n : testbit (ldiff a a') n = (testbit a n) && negb (testbit a' n).
Lemma one_succ : 1 = succ 0.
Lemma two_succ : 2 = succ 1.
Lemma gt_lt_iff n m : n > m <-> m < n.
Lemma gt_lt n m : n > m -> m < n.
Lemma lt_gt n m : n < m -> m > n.
Lemma ge_le_iff n m : n >= m <-> m <= n.
Lemma ge_le n m : n >= m -> m <= n.
Lemma le_ge n m : n <= m -> m >= n.
Lemma pos_pred_shiftl_low : forall p n m, m<n -> testbit (Pos.pred_N (Pos.shiftl p n)) m = true.
Lemma pos_pred_shiftl_high : forall p n m, n<=m -> testbit (Pos.pred_N (Pos.shiftl p n)) m =
Lemma pred_div2_up p : Pos.pred_N (Pos.div2_up p) = div2 (Pos.pred_N p).
Lemma Nplus_reg_l n m p : n + m = n + p -> m = p.
Lemma Nmult_Sn_m n m : N.succ n * m = m + n * m.
Lemma Nmult_plus_distr_l n m p : p * (n + m) = p * n + p * m.
Lemma Nmult_reg_r n m p : p <> 0 -> n * p = m * p -> n = m.
Lemma Ncompare_antisym n m : CompOpp (n ?= m) = (m ?= n).
Lemma CVN_CVU : forall (fn:nat -> R -> R)   (cv:forall x:R, {l:R | Un_cv (fun N:nat => SP fn N x) l })   (r:posreal), CVN_r fn r -> CVU (fun n:nat => SP fn n) (SFL fn cv) 0 r.
Lemma CVU_continuity : forall (fn:nat -> R -> R) (f:R -> R) (x:R) (r:posreal),   CVU fn f x r ->   (forall (n:nat) (y:R), Boule x r y -> continuity_pt (fn n) y) ->   forall y:R, Boule x r y -> continuity_pt f y.
Lemma continuity_pt_finite_SF : forall (fn:nat -> R -> R) (N:nat) (x:R),   (forall n:nat, (n <= N)%nat -> continuity_pt (fn n) x) ->   continuity_pt (fun y:R => sum_f_R0 (fun k:nat => fn k y) N) x.
Lemma SFL_continuity_pt : forall (fn:nat -> R -> R)   (cv:forall x:R, { l:R | Un_cv (fun N:nat => SP fn N x) l })   (r:posreal),   CVN_r fn r ->   (forall (n:nat) (y:R), Boule 0 r y -> continuity_pt (fn n) y) ->   forall y:R, Boule 0 r y -> continuity_pt (SFL fn cv) y.
Lemma SFL_continuity : forall (fn:nat -> R -> R)   (cv:forall x:R, { l:R | Un_cv (fun N:nat => SP fn N x) l }),   CVN_R fn -> (forall n:nat, continuity (fn n)) -> continuity (SFL fn cv).
Lemma CVN_R_CVS : forall fn:nat -> R -> R,   CVN_R fn -> forall x:R, { l:R | Un_cv (fun N:nat => SP fn N x) l }.
Lemma test_push : forall P Q R : Prop,     decidable P ->     decidable Q ->     (~ True) ->     (~ False) ->     (~ ~ P) ->     (~ (P /\ Q) -> ~ R) ->     ((P /\ Q) \/ ~ R) ->     (~ (P /\ Q) \/ R) ->     (R \/ ~ (P /\ Q)) ->     (~ R \/ (P /\ Q)) ->     (~ P -> R) ->     (~ ((R -> P) \/ (Q -> R))) ->     (~ (P /\ R)) ->     (~ (P -> R)) ->     True.
Lemma test_pull : forall P Q R : Prop,     decidable P ->     decidable Q ->     (~ True) ->     (~ False) ->     (~ ~ P) ->     (~ (P /\ Q) -> ~ R) ->     ((P /\ Q) \/ ~ R) ->     (~ (P /\ Q) \/ R) ->     (R \/ ~ (P /\ Q)) ->     (~ R \/ (P /\ Q)) ->     (~ P -> R) ->     (~ (R -> P) /\ ~ (Q -> R)) ->     (~ P \/ ~ R) ->     (P /\ ~ R) ->     (~ R /\ P) ->     True.
Lemma eq_refl_iff (x : E.t) : E.eq x x <-> True.
Lemma dec_In : forall x s,     decidable (In x s).
Lemma dec_eq : forall (x y : E.t),
Lemma test_eq_trans_1 : forall x y z s,     E.eq x y ->
Lemma test_eq_trans_2 : forall x y z r s,     In x (singleton y) ->     ~ In z r ->     ~ ~ In z (add y r) ->     In x s ->     In z s.
Lemma test_eq_neq_trans_1 : forall w x y z s,     E.eq x w ->
Lemma test_eq_neq_trans_2 : forall w x y z r1 r2 s,     In x (singleton w) ->     ~ In x r1 ->     In x (add y r1) ->     In y r2 ->     In y (remove z r2) ->     In w s ->     In w (remove z s).
Lemma test_In_singleton : forall x,     In x (singleton x).
Lemma test_add_In : forall x y s,     In x (add y s) ->     ~ E.eq x y ->
Lemma test_Subset_add_remove : forall x s,     s [<=] (add x (remove x s)).
Lemma test_eq_disjunction : forall w x y z,     In w (add x (add y (singleton z))) ->     E.eq w x \/ E.eq w y \/ E.eq w z.
Lemma test_not_In_disj : forall x y s1 s2 s3 s4,     ~ In x (union s1 (union s2 (union s3 (add y s4)))) ->     ~ (In x s1 \/ In x s4 \/ E.eq y x).
Lemma test_not_In_conj : forall x y s1 s2 s3 s4,     ~ In x (union s1 (union s2 (union s3 (add y s4)))) ->     ~ In x s1 /\ ~ In x s4 /\ ~ E.eq y x.
Lemma test_iff_conj : forall a x s s',   (In a s' <-> E.eq x a \/ In a s) ->
Lemma test_set_ops_1 : forall x q r s,     (singleton x) [<=] s ->     Empty (union q r) ->     Empty (inter (diff s q) (diff s r)) ->     ~ In x s.
Lemma eq_chain_test : forall x1 x2 x3 x4 s1 s2 s3 s4,     Empty s1 ->     In x2 (add x1 s1) ->     In x3 s2 ->     ~ In x3 (remove x2 s2) ->     ~ In x4 s3 ->     In x4 (add x3 s3) ->     In x1 s4 ->     Subset (add x4 s4) s4.
Lemma test_too_complex : forall x y z r s,     E.eq x y ->
Lemma function_test_1 :     forall (f : t -> t),     forall (g : elt -> elt),     forall (s1 s2 : t),     forall (x1 x2 : elt),     Equal s1 (f s2) ->     E.eq x1 (g (g x2)) ->
Lemma function_test_2 :     forall (f : t -> t),     forall (g : elt -> elt),     forall (s1 s2 : t),     forall (x1 x2 : elt),     Equal s1 (f s2) ->     E.eq x1 (g x2) ->
Lemma test_baydemir :     forall (f : t -> t),     forall (s : t),     forall (x y : elt),     In x (add y (f s)) ->     ~ E.eq x y ->
Lemma pointwise_pointwise A B (R : relation B) : relation_equivalence (pointwise_relation A R) (@eq A ==> R).
Lemma subrelation_respectful `(subl : subrelation A R₂ R₁, subr : subrelation B S₁ S₂) : subrelation (R₁ ==> S₁) (R₂ ==> S₂).
Lemma subrelation_refl A R : @subrelation A R R.
Lemma subrelation_proper `(mor : Proper A R₁ m, unc : Unconvertible (relation A) R₁ R₂, sub : subrelation A R₁ R₂) : Proper R₂ m.
Lemma forall_subrelation A (B : A -> Type) (R S : forall x : A, relation (B x)) : (forall a, subrelation (R a) (S a)) -> subrelation (forall_relation R) (forall_relation S).
Lemma subrelation_symmetric A R `(Symmetric A R) : subrelation (inverse R) R.
Lemma symmetric_equiv_inverse `(Symmetric A R) : relation_equivalence R (flip R).
Lemma eq_proper_proxy A (x : A) : ProperProxy (@eq A) x.
Lemma reflexive_proper_proxy `(Reflexive A R) (x : A) : ProperProxy R x.
Lemma proper_proper_proxy `(Proper A R x) : ProperProxy R x.
Lemma Reflexive_partial_app_morphism `(Proper (A -> B) (R ==> R') m, ProperProxy A R x) :  Proper R' (m x).
Lemma inverse_respectful : forall (A : Type) (R : relation A) (B : Type) (R' : relation B), relation_equivalence (inverse (R ==> R')) (inverse R ==> inverse R').
Lemma inverse_atom A R : Normalizes A R (inverse (inverse R)).
Lemma inverse_arrow `(NA : Normalizes A R (inverse R'''), NB : Normalizes B R' (inverse R'')) : Normalizes (A -> B) (R ==> R') (inverse (R''' ==> R'')%signature).
Lemma inverse1 `(subrelation A R' R) : subrelation (inverse (inverse R')) R.
Lemma inverse2 `(subrelation A R R') : subrelation R (inverse (inverse R')).
Lemma eq_subrelation `(Reflexive A R) : subrelation (@eq A) R.
Lemma proper_normalizes_proper `(Normalizes A R0 R1, Proper A R1 m) : Proper R0 m.
Lemma reflexive_proper `{Reflexive A R} (x : A)  : Proper R x.
Lemma proper_eq A (x : A) : Proper (@eq A) x.
Lemma proper_sym_flip : forall `(Symmetric A R1)`(Proper (A->B) (R1==>R2) f), Proper (R1==>inverse R2) f.
Lemma proper_sym_flip_2 : forall `(Symmetric A R1)`(Symmetric B R2)`(Proper (A->B->C) (R1==>R2==>R3) f), Proper (R1==>R2==>inverse R3) f.
Lemma proper_sym_impl_iff : forall `(Symmetric A R)`(Proper _ (R==>impl) f), Proper (R==>iff) f.
Lemma proper_sym_impl_iff_2 : forall `(Symmetric A R)`(Symmetric B R')`(Proper _ (R==>R'==>impl) f), Proper (R==>R'==>iff) f.
Lemma PartialOrder_StrictOrder `(PartialOrder A eqA R) : StrictOrder (relation_conjunction R (complement eqA)).
Lemma StrictOrder_PreOrder `(Equivalence A eqA, StrictOrder A R, Proper _ (eqA==>eqA==>iff) R) : PreOrder (relation_disjunction R eqA).
Lemma StrictOrder_PartialOrder `(Equivalence A eqA, StrictOrder A R, Proper _ (eqA==>eqA==>iff) R) : PartialOrder eqA (relation_disjunction R eqA).
Lemma Qpower_theory : power_theory 1 Qmult Qeq Z.of_N Qpower.
Lemma Qopp_plus : forall a b,  -(a+b) == -a + -b.
Lemma Qopp_opp : forall q, - -q==q.
Lemma le_unique: forall m n (h1 h2: m <= n), h1 = h2.
Lemma Alembert_exp : Un_cv (fun n:nat => Rabs (/ INR (fact (S n)) * / / INR (fact n))) 0.
Lemma id a : N.of_nat (N.to_nat a) = a.
Lemma inj a a' : N.to_nat a = N.to_nat a' -> a = a'.
Lemma inj_iff a a' : N.to_nat a = N.to_nat a' <-> a = a'.
Lemma inj_double a : N.to_nat (N.double a) = 2*(N.to_nat a).
Lemma inj_succ_double a : N.to_nat (N.succ_double a) = S (2*(N.to_nat a)).
Lemma inj_succ a : N.to_nat (N.succ a) = S (N.to_nat a).
Lemma inj_add a a' : N.to_nat (a + a') = N.to_nat a + N.to_nat a'.
Lemma inj_mul a a' : N.to_nat (a * a') = N.to_nat a * N.to_nat a'.
Lemma inj_sub a a' : N.to_nat (a - a') = N.to_nat a - N.to_nat a'.
Lemma inj_pred a : N.to_nat (N.pred a) = pred (N.to_nat a).
Lemma inj_div2 a : N.to_nat (N.div2 a) = div2 (N.to_nat a).
Lemma inj_compare a a' : (a ?= a')%N = nat_compare (N.to_nat a) (N.to_nat a').
Lemma inj_max a a' : N.to_nat (N.max a a') = max (N.to_nat a) (N.to_nat a').
Lemma inj_min a a' : N.to_nat (N.min a a') = min (N.to_nat a) (N.to_nat a').
Lemma inj_iter a {A} (f:A->A) (x:A) : N.iter a f x = nat_iter (N.to_nat a) f x.
Lemma id n : N.to_nat (N.of_nat n) = n.
Lemma inj n n' : N.of_nat n = N.of_nat n' -> n = n'.
Lemma inj_iff n n' : N.of_nat n = N.of_nat n' <-> n = n'.
Lemma inj_double n : N.of_nat (2*n) = N.double (N.of_nat n).
Lemma inj_succ_double n : N.of_nat (S (2*n)) = N.succ_double (N.of_nat n).
Lemma inj_succ n : N.of_nat (S n) = N.succ (N.of_nat n).
Lemma inj_pred n : N.of_nat (pred n) = N.pred (N.of_nat n).
Lemma inj_add n n' : N.of_nat (n+n') = (N.of_nat n + N.of_nat n')%N.
Lemma inj_sub n n' : N.of_nat (n-n') = (N.of_nat n - N.of_nat n')%N.
Lemma inj_mul n n' : N.of_nat (n*n') = (N.of_nat n * N.of_nat n')%N.
Lemma inj_div2 n : N.of_nat (div2 n) = N.div2 (N.of_nat n).
Lemma inj_compare n n' : nat_compare n n' = (N.of_nat n ?= N.of_nat n')%N.
Lemma inj_min n n' : N.of_nat (min n n') = N.min (N.of_nat n) (N.of_nat n').
Lemma inj_max n n' : N.of_nat (max n n') = N.max (N.of_nat n) (N.of_nat n').
Lemma inj_iter n {A} (f:A->A) (x:A) : nat_iter n f x = N.iter (N.of_nat n) f x.
Lemma eq_sym_iff : forall x y, x==y <-> y==x.
Lemma sqrt_pos : forall x : R, 0 <= sqrt x.
Lemma sqrt_positivity : forall x:R, 0 <= x -> 0 <= sqrt x.
Lemma sqrt_sqrt : forall x:R, 0 <= x -> sqrt x * sqrt x = x.
Lemma sqrt_0 : sqrt 0 = 0.
Lemma sqrt_1 : sqrt 1 = 1.
Lemma sqrt_eq_0 : forall x:R, 0 <= x -> sqrt x = 0 -> x = 0.
Lemma sqrt_lem_0 : forall x y:R, 0 <= x -> 0 <= y -> sqrt x = y -> y * y = x.
Lemma sqrt_lem_1 : forall x y:R, 0 <= x -> 0 <= y -> y * y = x -> sqrt x = y.
Lemma sqrt_def : forall x:R, 0 <= x -> sqrt x * sqrt x = x.
Lemma sqrt_square : forall x:R, 0 <= x -> sqrt (x * x) = x.
Lemma sqrt_Rsqr : forall x:R, 0 <= x -> sqrt (Rsqr x) = x.
Lemma sqrt_Rsqr_abs : forall x:R, sqrt (Rsqr x) = Rabs x.
Lemma Rsqr_sqrt : forall x:R, 0 <= x -> Rsqr (sqrt x) = x.
Lemma sqrt_mult_alt : forall x y : R, 0 <= x -> sqrt (x * y) = sqrt x * sqrt y.
Lemma sqrt_mult : forall x y:R, 0 <= x -> 0 <= y -> sqrt (x * y) = sqrt x * sqrt y.
Lemma sqrt_lt_R0 : forall x:R, 0 < x -> 0 < sqrt x.
Lemma sqrt_div_alt : forall x y : R, 0 < y -> sqrt (x / y) = sqrt x / sqrt y.
Lemma sqrt_div : forall x y:R, 0 <= x -> 0 < y -> sqrt (x / y) = sqrt x / sqrt y.
Lemma sqrt_lt_0_alt : forall x y : R, sqrt x < sqrt y -> x < y.
Lemma sqrt_lt_0 : forall x y:R, 0 <= x -> 0 <= y -> sqrt x < sqrt y -> x < y.
Lemma sqrt_lt_1_alt : forall x y : R, 0 <= x < y -> sqrt x < sqrt y.
Lemma sqrt_lt_1 : forall x y:R, 0 <= x -> 0 <= y -> x < y -> sqrt x < sqrt y.
Lemma sqrt_le_0 : forall x y:R, 0 <= x -> 0 <= y -> sqrt x <= sqrt y -> x <= y.
Lemma sqrt_le_1_alt : forall x y : R, x <= y -> sqrt x <= sqrt y.
Lemma sqrt_le_1 : forall x y:R, 0 <= x -> 0 <= y -> x <= y -> sqrt x <= sqrt y.
Lemma sqrt_inj : forall x y:R, 0 <= x -> 0 <= y -> sqrt x = sqrt y -> x = y.
Lemma sqrt_less_alt : forall x : R, 1 < x -> sqrt x < x.
Lemma sqrt_less : forall x:R, 0 <= x -> 1 < x -> sqrt x < x.
Lemma sqrt_more : forall x:R, 0 < x -> x < 1 -> x < sqrt x.
Lemma sqrt_cauchy : forall a b c d:R,   a * c + b * d <= sqrt (Rsqr a + Rsqr b) * sqrt (Rsqr c + Rsqr d).
Lemma Rsqr_sol_eq_0_1 : forall (a:nonzeroreal) (b c x:R),   Delta_is_pos a b c ->   x = sol_x1 a b c \/ x = sol_x2 a b c -> a * Rsqr x + b * x + c = 0.
Lemma Rsqr_sol_eq_0_0 : forall (a:nonzeroreal) (b c x:R),   Delta_is_pos a b c ->   a * Rsqr x + b * x + c = 0 -> x = sol_x1 a b c \/ x = sol_x2 a b c.
Lemma MapsTo_In : forall k e m, MapsTo k e m -> In k m.
Lemma In_MapsTo : forall k m, In k m -> exists e, MapsTo k e m.
Lemma In_alt : forall k m, In0 k m <-> In k m.
Lemma MapsTo_1 : forall m x y e, X.eq x y -> MapsTo x e m -> MapsTo y e m.
Lemma In_1 : forall m x y, X.eq x y -> In x m -> In y m.
Lemma In_node_iff : forall l x e r h y, In y (Node l x e r h) <-> In y l \/ X.eq y x \/ In y r.
Lemma lt_leaf : forall x, lt_tree x (Leaf elt).
Lemma gt_leaf : forall x, gt_tree x (Leaf elt).
Lemma lt_tree_node : forall x y l r e h, lt_tree x l -> lt_tree x r -> X.lt y x -> lt_tree x (Node l y e r h).
Lemma gt_tree_node : forall x y l r e h, gt_tree x l -> gt_tree x r -> X.lt x y -> gt_tree x (Node l y e r h).
Lemma lt_left : forall x y l r e h, lt_tree x (Node l y e r h) -> lt_tree x l.
Lemma lt_right : forall x y l r e h, lt_tree x (Node l y e r h) -> lt_tree x r.
Lemma gt_left : forall x y l r e h, gt_tree x (Node l y e r h) -> gt_tree x l.
Lemma gt_right : forall x y l r e h, gt_tree x (Node l y e r h) -> gt_tree x r.
Lemma lt_tree_not_in : forall x m, lt_tree x m -> ~ In x m.
Lemma lt_tree_trans : forall x y, X.lt x y -> forall m, lt_tree x m -> lt_tree y m.
Lemma gt_tree_not_in : forall x m, gt_tree x m -> ~ In x m.
Lemma gt_tree_trans : forall x y, X.lt y x -> forall m, gt_tree x m -> gt_tree y m.
Lemma empty_bst : bst (empty elt).
Lemma empty_1 : Empty (empty elt).
Lemma is_empty_1 : forall m, Empty m -> is_empty m = true.
Lemma is_empty_2 : forall m, is_empty m = true -> Empty m.
Lemma mem_1 : forall m x, bst m -> In x m -> mem x m = true.
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Lemma find_1 : forall m x e, bst m -> MapsTo x e m -> find x m = Some e.
Lemma find_2 : forall m x e, find x m = Some e -> MapsTo x e m.
Lemma find_iff : forall m x e, bst m -> (find x m = Some e <-> MapsTo x e m).
Lemma find_in : forall m x, find x m <> None -> In x m.
Lemma in_find : forall m x, bst m -> In x m -> find x m <> None.
Lemma find_in_iff : forall m x, bst m -> (find x m <> None <-> In x m).
Lemma not_find_iff : forall m x, bst m -> (find x m = None <-> ~In x m).
Lemma find_find : forall m m' x, find x m = find x m' <-> (forall d, find x m = Some d <-> find x m' = Some d).
Lemma find_mapsto_equiv : forall m m' x, bst m -> bst m' -> (find x m = find x m' <-> (forall d, MapsTo x d m <-> MapsTo x d m')).
Lemma find_in_equiv : forall m m' x, bst m -> bst m' -> find x m = find x m' -> (In x m <-> In x m').
Lemma create_bst : forall l x e r, bst l -> bst r -> lt_tree x l -> gt_tree x r -> bst (create l x e r).
Lemma create_in : forall l x e r y, In y (create l x e r) <-> X.eq y x \/ In y l \/ In y r.
Lemma bal_bst : forall l x e r, bst l -> bst r -> lt_tree x l -> gt_tree x r -> bst (bal l x e r).
Lemma bal_in : forall l x e r y, In y (bal l x e r) <-> X.eq y x \/ In y l \/ In y r.
Lemma bal_mapsto : forall l x e r y e', MapsTo y e' (bal l x e r) <-> MapsTo y e' (create l x e r).
Lemma bal_find : forall l x e r y, bst l -> bst r -> lt_tree x l -> gt_tree x r -> find y (bal l x e r) = find y (create l x e r).
Lemma add_in : forall m x y e, In y (add x e m) <-> X.eq y x \/ In y m.
Lemma add_bst : forall m x e, bst m -> bst (add x e m).
Lemma add_1 : forall m x y e, X.eq x y -> MapsTo y e (add x e m).
Lemma add_2 : forall m x y e e', ~X.eq x y ->
Lemma add_3 : forall m x y e e', ~X.eq x y ->
Lemma add_find : forall m x y e, bst m -> find y (add x e m) = match X.compare y x with EQ _ => Some e | _ => find y m end.
Lemma remove_min_in : forall l x e r h y, In y (Node l x e r h) <-> X.eq y (remove_min l x e r)#2#1 \/ In y (remove_min l x e r)#1.
Lemma remove_min_mapsto : forall l x e r h y e', MapsTo y e' (Node l x e r h) <->  ((X.eq y (remove_min l x e r)#2#1) /\ e' = (remove_min l x e r)#2#2)
Lemma remove_min_bst : forall l x e r h, bst (Node l x e r h) -> bst (remove_min l x e r)#1.
Lemma remove_min_gt_tree : forall l x e r h, bst (Node l x e r h) -> gt_tree (remove_min l x e r)#2#1 (remove_min l x e r)#1.
Lemma remove_min_find : forall l x e r h y, bst (Node l x e r h) -> find y (Node l x e r h) =  match X.compare y (remove_min l x e r)#2#1 with
Lemma merge_in : forall m1 m2 y, bst m1 -> bst m2 -> (In y (merge m1 m2) <-> In y m1 \/ In y m2).
Lemma merge_mapsto : forall m1 m2 y e, bst m1 -> bst m2 -> (MapsTo y e (merge m1 m2) <-> MapsTo y e m1 \/ MapsTo y e m2).
Lemma merge_bst : forall m1 m2, bst m1 -> bst m2 -> (forall y1 y2 : key, In y1 m1 -> In y2 m2 -> X.lt y1 y2) ->
Lemma remove_in : forall m x y, bst m -> (In y (remove x m) <-> ~ X.eq y x /\ In y m).
Lemma remove_bst : forall m x, bst m -> bst (remove x m).
Lemma remove_1 : forall m x y, bst m -> X.eq x y -> ~ In y (remove x m).
Lemma remove_2 : forall m x y e, bst m -> ~X.eq x y ->
Lemma remove_3 : forall m x y e, bst m -> MapsTo y e (remove x m) -> MapsTo y e m.
Lemma join_in : forall l x d r y, In y (join l x d r) <-> X.eq y x \/ In y l \/ In y r.
Lemma join_bst : forall l x d r, bst l -> bst r -> lt_tree x l -> gt_tree x r -> bst (join l x d r).
Lemma join_find : forall l x d r y, bst l -> bst r -> lt_tree x l -> gt_tree x r -> find y (join l x d r) = find y (create l x d r).
Lemma split_in_1 : forall m x, bst m -> forall y, (In y (split x m)#l <-> In y m /\ X.lt y x).
Lemma split_in_2 : forall m x, bst m -> forall y, (In y (split x m)#r <-> In y m /\ X.lt x y).
Lemma split_in_3 : forall m x, bst m -> (split x m)#o = find x m.
Lemma split_bst : forall m x, bst m -> bst (split x m)#l /\ bst (split x m)#r.
Lemma split_lt_tree : forall m x, bst m -> lt_tree x (split x m)#l.
Lemma split_gt_tree : forall m x, bst m -> gt_tree x (split x m)#r.
Lemma split_find : forall m x y, bst m -> find y m = match X.compare y x with
Lemma concat_in : forall m1 m2 y, In y (concat m1 m2) <-> In y m1 \/ In y m2.
Lemma concat_bst : forall m1 m2, bst m1 -> bst m2 -> (forall y1 y2, In y1 m1 -> In y2 m2 -> X.lt y1 y2) ->
Lemma concat_find : forall m1 m2 y, bst m1 -> bst m2 -> (forall y1 y2, In y1 m1 -> In y2 m2 -> X.lt y1 y2) ->
Lemma elements_aux_mapsto : forall (s:t elt) acc x e, InA eqke (x,e) (elements_aux acc s) <-> MapsTo x e s \/ InA eqke (x,e) acc.
Lemma elements_mapsto : forall (s:t elt) x e, InA eqke (x,e) (elements s) <-> MapsTo x e s.
Lemma elements_in : forall (s:t elt) x, L.PX.In x (elements s) <-> In x s.
Lemma elements_aux_sort : forall (s:t elt) acc, bst s -> sort ltk acc -> (forall x e y, InA eqke (x,e) acc -> In y s -> X.lt y x) ->
Lemma elements_sort : forall s : t elt, bst s -> sort ltk (elements s).
Lemma elements_nodup : forall s : t elt, bst s -> NoDupA eqk (elements s).
Lemma elements_aux_cardinal : forall (m:t elt) acc, (length acc + cardinal m)%nat = length (elements_aux acc m).
Lemma elements_cardinal : forall (m:t elt), cardinal m = length (elements m).
Lemma elements_app : forall (s:t elt) acc, elements_aux acc s = elements s ++ acc.
Lemma elements_node : forall (t1 t2:t elt) x e z l, elements t1 ++ (x,e) :: elements t2 ++ l = elements (Node t1 x e t2 z) ++ l.
Lemma fold_equiv_aux : forall (A : Type) (s : t elt) (f : key -> elt -> A -> A) (a : A) acc, L.fold f (elements_aux acc s) a = L.fold f acc (fold f s a).
Lemma fold_equiv : forall (A : Type) (s : t elt) (f : key -> elt -> A -> A) (a : A), fold f s a = fold' f s a.
Lemma fold_1 : forall (s:t elt)(Hs:bst s)(A : Type)(i:A)(f : key -> elt -> A -> A), fold f s i = fold_left (fun a p => f p#1 p#2 a) (elements s) i.
Lemma flatten_e_elements : forall (l:t elt) r x d z e, elements l ++ flatten_e (More x d r e) = elements (Node l x d r z) ++ flatten_e e.
Lemma cons_1 : forall (s:t elt) e, flatten_e (cons s e) = elements s ++ flatten_e e.
Lemma cons_IfEq : forall b x1 x2 d1 d2 l1 l2, X.eq x1 x2 -> cmp d1 d2 = true ->
Lemma equal_end_IfEq : forall e2, IfEq (equal_end e2) nil (flatten_e e2).
Lemma equal_more_IfEq : forall x1 d1 (cont:enumeration elt -> bool) x2 d2 r2 e2 l, IfEq (cont (cons r2 e2)) l (elements r2 ++ flatten_e e2) ->   IfEq (equal_more cmp x1 d1 cont (More x2 d2 r2 e2)) ((x1,d1)::l)      (flatten_e (More x2 d2 r2 e2)).
Lemma equal_cont_IfEq : forall m1 cont e2 l, (forall e, IfEq (cont e) l (flatten_e e)) -> IfEq (equal_cont cmp m1 cont e2) (elements m1 ++ l) (flatten_e e2).
Lemma equal_IfEq : forall (m1 m2:t elt), IfEq (equal cmp m1 m2) (elements m1) (elements m2).
Lemma Equivb_elements : forall s s', Equivb s s' <-> L.Equivb cmp (elements s) (elements s').
Lemma equal_Equivb : forall (s s': t elt), bst s -> bst s' -> (equal cmp s s' = true <-> Equivb s s').
Lemma map_1 : forall (m: t elt)(x:key)(e:elt),   MapsTo x e m -> MapsTo x (f e) (map f m).
Lemma map_2 : forall (m: t elt)(x:key),   In x (map f m) -> In x m.
Lemma map_bst : forall m, bst m -> bst (map f m).
Lemma mapi_1 : forall (m: tree elt)(x:key)(e:elt),   MapsTo x e m -> exists y, X.eq y x /\ MapsTo x (f y e) (mapi f m).
Lemma mapi_2 : forall (m: t elt)(x:key),   In x (mapi f m) -> In x m.
Lemma mapi_bst : forall m, bst m -> bst (mapi f m).
Lemma map_option_2 : forall (m:t elt)(x:key), In x (map_option f m) -> exists d, MapsTo x d m /\ f x d <> None.
Lemma map_option_bst : forall m, bst m -> bst (map_option f m).
Lemma map_option_find : forall (m:t elt)(x:key), bst m -> find x (map_option f m) = match (find x m) with Some d => f x d | None => None end.
Lemma map2_opt_2 : forall m m' y, bst m -> bst m' -> In y (map2_opt m m') -> In y m \/ In y m'.
Lemma map2_opt_bst : forall m m', bst m -> bst m' -> bst (map2_opt m m').
Lemma map2_opt_1 : forall m m' y, bst m -> bst m' -> In y m \/ In y m' -> find y (map2_opt m m') = f0 y (find y m) (find y m').
Lemma map2_bst : forall m m', bst m -> bst m' -> bst (map2 f m m').
Lemma map2_1 : forall m m' y, bst m -> bst m' -> In y m \/ In y m' -> find y (map2 f m m') = f (find y m) (find y m').
Lemma map2_2 : forall m m' y, bst m -> bst m' -> In y (map2 f m m') -> In y m \/ In y m'.
Lemma MapsTo_1 : forall m x y e, E.eq x y -> MapsTo x e m -> MapsTo y e m.
Lemma mem_1 : forall m x, In x m -> mem x m = true.
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Lemma empty_1 : Empty empty.
Lemma is_empty_1 : forall m, Empty m -> is_empty m = true.
Lemma is_empty_2 : forall m, is_empty m = true -> Empty m.
Lemma add_1 : forall m x y e, E.eq x y -> MapsTo y e (add x e m).
Lemma add_2 : forall m x y e e', ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Lemma add_3 : forall m x y e e', ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Lemma remove_1 : forall m x y, E.eq x y -> ~ In y (remove x m).
Lemma remove_2 : forall m x y e, ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Lemma remove_3 : forall m x y e, MapsTo y e (remove x m) -> MapsTo y e m.
Lemma find_1 : forall m x e, MapsTo x e m -> find x m = Some e.
Lemma find_2 : forall m x e, find x m = Some e -> MapsTo x e m.
Lemma fold_1 : forall m (A : Type) (i : A) (f : key -> elt -> A -> A),       fold f m i = fold_left (fun a p => f (fst p) (snd p) a) (elements m) i.
Lemma elements_1 : forall m x e,  MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Lemma elements_2 : forall m x e,  InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Lemma elements_3 : forall m, sort lt_key (elements m).
Lemma elements_3w : forall m, NoDupA eq_key (elements m).
Lemma cardinal_1 : forall m, cardinal m = length (elements m).
Lemma Equivb_Equivb : forall cmp m m', Equivb cmp m m' <-> Raw.Proofs.Equivb cmp m m'.
Lemma equal_1 : forall m m' cmp,  Equivb cmp m m' -> equal cmp m m' = true.
Lemma equal_2 : forall m m' cmp,  equal cmp m m' = true -> Equivb cmp m m'.
Lemma map_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)(f:elt->elt'),       MapsTo x e m -> MapsTo x (f e) (map f m).
Lemma map_2 : forall (elt elt':Type)(m:t elt)(x:key)(f:elt->elt'), In x (map f m) -> In x m.
Lemma mapi_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)       (f:key->elt->elt'), MapsTo x e m ->       exists y, E.eq y x /\ MapsTo x (f y e) (mapi f m).
Lemma mapi_2 : forall (elt elt':Type)(m: t elt)(x:key)       (f:key->elt->elt'), In x (mapi f m) -> In x m.
Lemma map2_1 : forall (elt elt' elt'':Type)(m: t elt)(m': t elt')   (x:key)(f:option elt->option elt'->option elt''),   In x m \/ In x m' ->   find x (map2 f m m') = f (find x m) (find x m').
Lemma map2_2 : forall (elt elt' elt'':Type)(m: t elt)(m': t elt')    (x:key)(f:option elt->option elt'->option elt''),    In x (map2 f m m') -> In x m \/ In x m'.
Lemma cons_Cmp : forall c x1 x2 d1 d2 l1 l2,  X.eq x1 x2 -> D.eq d1 d2 ->
Lemma compare_end_Cmp :  forall e2, Cmp (compare_end e2) nil (P.flatten_e e2).
Lemma compare_more_Cmp : forall x1 d1 cont x2 d2 r2 e2 l,   Cmp (cont (R.cons r2 e2)) l (R.elements r2 ++ P.flatten_e e2) ->
Lemma compare_cont_Cmp : forall s1 cont e2 l,  (forall e, Cmp (cont e) l (P.flatten_e e)) ->
Lemma compare_Cmp : forall s1 s2,  Cmp (compare_pure s1 s2) (R.elements s1) (R.elements s2).
Lemma eq_seq : forall m1 m2, eq m1 m2 <-> seq m1 m2.
Lemma lt_slt : forall m1 m2, lt m1 m2 <-> slt m1 m2.
Lemma eq_1 : forall (m m' : t), Equivb cmp m m' -> eq m m'.
Lemma eq_2 : forall m m', eq m m' -> Equivb cmp m m'.
Lemma eq_refl : forall m : t, eq m m.
Lemma eq_sym : forall m1 m2 : t, eq m1 m2 -> eq m2 m1.
Lemma eq_trans : forall m1 m2 m3 : t, eq m1 m2 -> eq m2 m3 -> eq m1 m3.
Lemma lt_trans : forall m1 m2 m3 : t, lt m1 m2 -> lt m2 m3 -> lt m1 m3.
Lemma lt_not_eq : forall m1 m2 : t, lt m1 m2 -> ~ eq m1 m2.
Lemma Rle_refl : forall r, r <= r.
Lemma Rge_refl : forall r, r <= r.
Lemma Rlt_irrefl : forall r, ~ r < r.
Lemma Rgt_irrefl : forall r, ~ r > r.
Lemma Rlt_not_eq : forall r1 r2, r1 < r2 -> r1 <> r2.
Lemma Rgt_not_eq : forall r1 r2, r1 > r2 -> r1 <> r2.
Lemma Rlt_dichotomy_converse : forall r1 r2, r1 < r2 \/ r1 > r2 -> r1 <> r2.
Lemma Req_dec : forall r1 r2, r1 = r2 \/ r1 <> r2.
Lemma Rtotal_order : forall r1 r2, r1 < r2 \/ r1 = r2 \/ r1 > r2.
Lemma Rdichotomy : forall r1 r2, r1 <> r2 -> r1 < r2 \/ r1 > r2.
Lemma Rlt_le : forall r1 r2, r1 < r2 -> r1 <= r2.
Lemma Rgt_ge : forall r1 r2, r1 > r2 -> r1 >= r2.
Lemma Rle_ge : forall r1 r2, r1 <= r2 -> r2 >= r1.
Lemma Rge_le : forall r1 r2, r1 >= r2 -> r2 <= r1.
Lemma Rlt_gt : forall r1 r2, r1 < r2 -> r2 > r1.
Lemma Rgt_lt : forall r1 r2, r1 > r2 -> r2 < r1.
Lemma Rnot_le_lt : forall r1 r2, ~ r1 <= r2 -> r2 < r1.
Lemma Rnot_ge_gt : forall r1 r2, ~ r1 >= r2 -> r2 > r1.
Lemma Rnot_le_gt : forall r1 r2, ~ r1 <= r2 -> r1 > r2.
Lemma Rnot_ge_lt : forall r1 r2, ~ r1 >= r2 -> r1 < r2.
Lemma Rnot_lt_le : forall r1 r2, ~ r1 < r2 -> r2 <= r1.
Lemma Rnot_gt_le : forall r1 r2, ~ r1 > r2 -> r1 <= r2.
Lemma Rnot_gt_ge : forall r1 r2, ~ r1 > r2 -> r2 >= r1.
Lemma Rnot_lt_ge : forall r1 r2, ~ r1 < r2 -> r1 >= r2.
Lemma Rlt_not_le : forall r1 r2, r2 < r1 -> ~ r1 <= r2.
Lemma Rgt_not_le : forall r1 r2, r1 > r2 -> ~ r1 <= r2.
Lemma Rlt_not_ge : forall r1 r2, r1 < r2 -> ~ r1 >= r2.
Lemma Rgt_not_ge : forall r1 r2, r2 > r1 -> ~ r1 >= r2.
Lemma Rle_not_lt : forall r1 r2, r2 <= r1 -> ~ r1 < r2.
Lemma Rge_not_lt : forall r1 r2, r1 >= r2 -> ~ r1 < r2.
Lemma Rle_not_gt : forall r1 r2, r1 <= r2 -> ~ r1 > r2.
Lemma Rge_not_gt : forall r1 r2, r2 >= r1 -> ~ r1 > r2.
Lemma Req_le : forall r1 r2, r1 = r2 -> r1 <= r2.
Lemma Req_ge : forall r1 r2, r1 = r2 -> r1 >= r2.
Lemma Req_le_sym : forall r1 r2, r2 = r1 -> r1 <= r2.
Lemma Req_ge_sym : forall r1 r2, r2 = r1 -> r1 >= r2.
Lemma Rgt_asym : forall r1 r2:R, r1 > r2 -> ~ r2 > r1.
Lemma Rle_antisym : forall r1 r2, r1 <= r2 -> r2 <= r1 -> r1 = r2.
Lemma Rge_antisym : forall r1 r2, r1 >= r2 -> r2 >= r1 -> r1 = r2.
Lemma Rle_le_eq : forall r1 r2, r1 <= r2 /\ r2 <= r1 <-> r1 = r2.
Lemma Rge_ge_eq : forall r1 r2, r1 >= r2 /\ r2 >= r1 <-> r1 = r2.
Lemma Rlt_eq_compat : forall r1 r2 r3 r4, r1 = r2 -> r2 < r4 -> r4 = r3 -> r1 < r3.
Lemma Rgt_eq_compat : forall r1 r2 r3 r4, r1 = r2 -> r2 > r4 -> r4 = r3 -> r1 > r3.
Lemma Rle_trans : forall r1 r2 r3, r1 <= r2 -> r2 <= r3 -> r1 <= r3.
Lemma Rge_trans : forall r1 r2 r3, r1 >= r2 -> r2 >= r3 -> r1 >= r3.
Lemma Rgt_trans : forall r1 r2 r3, r1 > r2 -> r2 > r3 -> r1 > r3.
Lemma Rle_lt_trans : forall r1 r2 r3, r1 <= r2 -> r2 < r3 -> r1 < r3.
Lemma Rlt_le_trans : forall r1 r2 r3, r1 < r2 -> r2 <= r3 -> r1 < r3.
Lemma Rge_gt_trans : forall r1 r2 r3, r1 >= r2 -> r2 > r3 -> r1 > r3.
Lemma Rgt_ge_trans : forall r1 r2 r3, r1 > r2 -> r2 >= r3 -> r1 > r3.
Lemma Rlt_dec : forall r1 r2, {r1 < r2} + {~ r1 < r2}.
Lemma Rle_dec : forall r1 r2, {r1 <= r2} + {~ r1 <= r2}.
Lemma Rgt_dec : forall r1 r2, {r1 > r2} + {~ r1 > r2}.
Lemma Rge_dec : forall r1 r2, {r1 >= r2} + {~ r1 >= r2}.
Lemma Rlt_le_dec : forall r1 r2, {r1 < r2} + {r2 <= r1}.
Lemma Rgt_ge_dec : forall r1 r2, {r1 > r2} + {r2 >= r1}.
Lemma Rle_lt_dec : forall r1 r2, {r1 <= r2} + {r2 < r1}.
Lemma Rge_gt_dec : forall r1 r2, {r1 >= r2} + {r2 > r1}.
Lemma Rlt_or_le : forall r1 r2, r1 < r2 \/ r2 <= r1.
Lemma Rgt_or_ge : forall r1 r2, r1 > r2 \/ r2 >= r1.
Lemma Rle_or_lt : forall r1 r2, r1 <= r2 \/ r2 < r1.
Lemma Rge_or_gt : forall r1 r2, r1 >= r2 \/ r2 > r1.
Lemma Rle_lt_or_eq_dec : forall r1 r2, r1 <= r2 -> {r1 < r2} + {r1 = r2}.
Lemma inser_trans_R : forall r1 r2 r3 r4, r1 <= r2 < r3 -> {r1 <= r2 < r4} + {r4 <= r2 < r3}.
Lemma Rplus_0_r : forall r, r + 0 = r.
Lemma Rplus_ne : forall r, r + 0 = r /\ 0 + r = r.
Lemma Rplus_opp_l : forall r, - r + r = 0.
Lemma Rplus_opp_r_uniq : forall r1 r2, r1 + r2 = 0 -> r2 = - r1.
Lemma Rplus_eq_compat_l : forall r r1 r2, r1 = r2 -> r + r1 = r + r2.
Lemma Rplus_eq_reg_l : forall r r1 r2, r + r1 = r + r2 -> r1 = r2.
Lemma Rplus_0_r_uniq : forall r r1, r + r1 = r -> r1 = 0.
Lemma Rplus_eq_0_l : forall r1 r2, 0 <= r1 -> 0 <= r2 -> r1 + r2 = 0 -> r1 = 0.
Lemma Rplus_eq_R0 : forall r1 r2, 0 <= r1 -> 0 <= r2 -> r1 + r2 = 0 -> r1 = 0 /\ r2 = 0.
Lemma Rinv_r : forall r, r <> 0 -> r * / r = 1.
Lemma Rinv_l_sym : forall r, r <> 0 -> 1 = / r * r.
Lemma Rinv_r_sym : forall r, r <> 0 -> 1 = r * / r.
Lemma Rmult_0_r : forall r, r * 0 = 0.
Lemma Rmult_0_l : forall r, 0 * r = 0.
Lemma Rmult_ne : forall r, r * 1 = r /\ 1 * r = r.
Lemma Rmult_1_r : forall r, r * 1 = r.
Lemma Rmult_eq_compat_l : forall r r1 r2, r1 = r2 -> r * r1 = r * r2.
Lemma Rmult_eq_compat_r : forall r r1 r2, r1 = r2 -> r1 * r = r2 * r.
Lemma Rmult_eq_reg_l : forall r r1 r2, r * r1 = r * r2 -> r <> 0 -> r1 = r2.
Lemma Rmult_eq_reg_r : forall r r1 r2, r1 * r = r2 * r -> r <> 0 -> r1 = r2.
Lemma Rmult_integral : forall r1 r2, r1 * r2 = 0 -> r1 = 0 \/ r2 = 0.
Lemma Rmult_eq_0_compat : forall r1 r2, r1 = 0 \/ r2 = 0 -> r1 * r2 = 0.
Lemma Rmult_eq_0_compat_r : forall r1 r2, r1 = 0 -> r1 * r2 = 0.
Lemma Rmult_eq_0_compat_l : forall r1 r2, r2 = 0 -> r1 * r2 = 0.
Lemma Rmult_neq_0_reg : forall r1 r2, r1 * r2 <> 0 -> r1 <> 0 /\ r2 <> 0.
Lemma Rmult_integral_contrapositive : forall r1 r2, r1 <> 0 /\ r2 <> 0 -> r1 * r2 <> 0.
Lemma Rmult_integral_contrapositive_currified : forall r1 r2, r1 <> 0 -> r2 <> 0 -> r1 * r2 <> 0.
Lemma Rmult_plus_distr_r : forall r1 r2 r3, (r1 + r2) * r3 = r1 * r3 + r2 * r3.
Lemma Rsqr_0 : Rsqr 0 = 0.
Lemma Rsqr_0_uniq : forall r, Rsqr r = 0 -> r = 0.
Lemma Ropp_eq_compat : forall r1 r2, r1 = r2 -> - r1 = - r2.
Lemma Ropp_0 : -0 = 0.
Lemma Ropp_eq_0_compat : forall r, r = 0 -> - r = 0.
Lemma Ropp_involutive : forall r, - - r = r.
Lemma Ropp_neq_0_compat : forall r, r <> 0 -> - r <> 0.
Lemma Ropp_plus_distr : forall r1 r2, - (r1 + r2) = - r1 + - r2.
Lemma Ropp_mult_distr_l_reverse : forall r1 r2, - r1 * r2 = - (r1 * r2).
Lemma Rmult_opp_opp : forall r1 r2, - r1 * - r2 = r1 * r2.
Lemma Ropp_mult_distr_r_reverse : forall r1 r2, r1 * - r2 = - (r1 * r2).
Lemma Rminus_0_r : forall r, r - 0 = r.
Lemma Rminus_0_l : forall r, 0 - r = - r.
Lemma Ropp_minus_distr : forall r1 r2, - (r1 - r2) = r2 - r1.
Lemma Ropp_minus_distr' : forall r1 r2, - (r2 - r1) = r1 - r2.
Lemma Rminus_diag_eq : forall r1 r2, r1 = r2 -> r1 - r2 = 0.
Lemma Rminus_diag_uniq : forall r1 r2, r1 - r2 = 0 -> r1 = r2.
Lemma Rminus_diag_uniq_sym : forall r1 r2, r2 - r1 = 0 -> r1 = r2.
Lemma Rplus_minus : forall r1 r2, r1 + (r2 - r1) = r2.
Lemma Rminus_eq_contra : forall r1 r2, r1 <> r2 -> r1 - r2 <> 0.
Lemma Rminus_not_eq : forall r1 r2, r1 - r2 <> 0 -> r1 <> r2.
Lemma Rminus_not_eq_right : forall r1 r2, r2 - r1 <> 0 -> r1 <> r2.
Lemma Rmult_minus_distr_l : forall r1 r2 r3, r1 * (r2 - r3) = r1 * r2 - r1 * r3.
Lemma Rinv_1 : / 1 = 1.
Lemma Rinv_neq_0_compat : forall r, r <> 0 -> / r <> 0.
Lemma Rinv_involutive : forall r, r <> 0 -> / / r = r.
Lemma Rinv_mult_distr : forall r1 r2, r1 <> 0 -> r2 <> 0 -> / (r1 * r2) = / r1 * / r2.
Lemma Ropp_inv_permute : forall r, r <> 0 -> - / r = / - r.
Lemma Rinv_r_simpl_r : forall r1 r2, r1 <> 0 -> r1 * / r1 * r2 = r2.
Lemma Rinv_r_simpl_l : forall r1 r2, r1 <> 0 -> r2 * r1 * / r1 = r2.
Lemma Rinv_r_simpl_m : forall r1 r2, r1 <> 0 -> r1 * r2 * / r1 = r2.
Lemma Rinv_mult_simpl : forall r1 r2 r3, r1 <> 0 -> r1 * / r2 * (r3 * / r1) = r3 * / r2.
Lemma Rplus_gt_compat_l : forall r r1 r2, r1 > r2 -> r + r1 > r + r2.
Lemma Rplus_lt_compat_r : forall r r1 r2, r1 < r2 -> r1 + r < r2 + r.
Lemma Rplus_gt_compat_r : forall r r1 r2, r1 > r2 -> r1 + r > r2 + r.
Lemma Rplus_le_compat_l : forall r r1 r2, r1 <= r2 -> r + r1 <= r + r2.
Lemma Rplus_ge_compat_l : forall r r1 r2, r1 >= r2 -> r + r1 >= r + r2.
Lemma Rplus_le_compat_r : forall r r1 r2, r1 <= r2 -> r1 + r <= r2 + r.
Lemma Rplus_ge_compat_r : forall r r1 r2, r1 >= r2 -> r1 + r >= r2 + r.
Lemma Rplus_lt_compat : forall r1 r2 r3 r4, r1 < r2 -> r3 < r4 -> r1 + r3 < r2 + r4.
Lemma Rplus_le_compat : forall r1 r2 r3 r4, r1 <= r2 -> r3 <= r4 -> r1 + r3 <= r2 + r4.
Lemma Rplus_gt_compat : forall r1 r2 r3 r4, r1 > r2 -> r3 > r4 -> r1 + r3 > r2 + r4.
Lemma Rplus_ge_compat : forall r1 r2 r3 r4, r1 >= r2 -> r3 >= r4 -> r1 + r3 >= r2 + r4.
Lemma Rplus_lt_le_compat : forall r1 r2 r3 r4, r1 < r2 -> r3 <= r4 -> r1 + r3 < r2 + r4.
Lemma Rplus_le_lt_compat : forall r1 r2 r3 r4, r1 <= r2 -> r3 < r4 -> r1 + r3 < r2 + r4.
Lemma Rplus_gt_ge_compat : forall r1 r2 r3 r4, r1 > r2 -> r3 >= r4 -> r1 + r3 > r2 + r4.
Lemma Rplus_ge_gt_compat : forall r1 r2 r3 r4, r1 >= r2 -> r3 > r4 -> r1 + r3 > r2 + r4.
Lemma Rplus_lt_0_compat : forall r1 r2, 0 < r1 -> 0 < r2 -> 0 < r1 + r2.
Lemma Rplus_le_lt_0_compat : forall r1 r2, 0 <= r1 -> 0 < r2 -> 0 < r1 + r2.
Lemma Rplus_lt_le_0_compat : forall r1 r2, 0 < r1 -> 0 <= r2 -> 0 < r1 + r2.
Lemma Rplus_le_le_0_compat : forall r1 r2, 0 <= r1 -> 0 <= r2 -> 0 <= r1 + r2.
Lemma sum_inequa_Rle_lt : forall a x b c y d:R,   a <= x -> x < b -> c < y -> y <= d -> a + c < x + y < b + d.
Lemma Rplus_lt_reg_r : forall r r1 r2, r + r1 < r + r2 -> r1 < r2.
Lemma Rplus_le_reg_l : forall r r1 r2, r + r1 <= r + r2 -> r1 <= r2.
Lemma Rplus_le_reg_r : forall r r1 r2, r1 + r <= r2 + r -> r1 <= r2.
Lemma Rplus_gt_reg_l : forall r r1 r2, r + r1 > r + r2 -> r1 > r2.
Lemma Rplus_ge_reg_l : forall r r1 r2, r + r1 >= r + r2 -> r1 >= r2.
Lemma Rplus_le_reg_pos_r : forall r1 r2 r3, 0 <= r2 -> r1 + r2 <= r3 -> r1 <= r3.
Lemma Rplus_lt_reg_pos_r : forall r1 r2 r3, 0 <= r2 -> r1 + r2 < r3 -> r1 < r3.
Lemma Rplus_ge_reg_neg_r : forall r1 r2 r3, 0 >= r2 -> r1 + r2 >= r3 -> r1 >= r3.
Lemma Rplus_gt_reg_neg_r : forall r1 r2 r3, 0 >= r2 -> r1 + r2 > r3 -> r1 > r3.
Lemma Ropp_gt_lt_contravar : forall r1 r2, r1 > r2 -> - r1 < - r2.
Lemma Ropp_lt_gt_contravar : forall r1 r2, r1 < r2 -> - r1 > - r2.
Lemma Ropp_lt_contravar : forall r1 r2, r2 < r1 -> - r1 < - r2.
Lemma Ropp_gt_contravar : forall r1 r2, r2 > r1 -> - r1 > - r2.
Lemma Ropp_le_ge_contravar : forall r1 r2, r1 <= r2 -> - r1 >= - r2.
Lemma Ropp_ge_le_contravar : forall r1 r2, r1 >= r2 -> - r1 <= - r2.
Lemma Ropp_le_contravar : forall r1 r2, r2 <= r1 -> - r1 <= - r2.
Lemma Ropp_ge_contravar : forall r1 r2, r2 >= r1 -> - r1 >= - r2.
Lemma Ropp_0_lt_gt_contravar : forall r, 0 < r -> 0 > - r.
Lemma Ropp_0_gt_lt_contravar : forall r, 0 > r -> 0 < - r.
Lemma Ropp_lt_gt_0_contravar : forall r, r > 0 -> - r < 0.
Lemma Ropp_gt_lt_0_contravar : forall r, r < 0 -> - r > 0.
Lemma Ropp_0_le_ge_contravar : forall r, 0 <= r -> 0 >= - r.
Lemma Ropp_0_ge_le_contravar : forall r, 0 >= r -> 0 <= - r.
Lemma Ropp_lt_cancel : forall r1 r2, - r2 < - r1 -> r1 < r2.
Lemma Ropp_gt_cancel : forall r1 r2, - r2 > - r1 -> r1 > r2.
Lemma Ropp_le_cancel : forall r1 r2, - r2 <= - r1 -> r1 <= r2.
Lemma Ropp_ge_cancel : forall r1 r2, - r2 >= - r1 -> r1 >= r2.
Lemma Rmult_lt_compat_r : forall r r1 r2, 0 < r -> r1 < r2 -> r1 * r < r2 * r.
Lemma Rmult_gt_compat_r : forall r r1 r2, r > 0 -> r1 > r2 -> r1 * r > r2 * r.
Lemma Rmult_gt_compat_l : forall r r1 r2, r > 0 -> r1 > r2 -> r * r1 > r * r2.
Lemma Rmult_le_compat_l : forall r r1 r2, 0 <= r -> r1 <= r2 -> r * r1 <= r * r2.
Lemma Rmult_le_compat_r : forall r r1 r2, 0 <= r -> r1 <= r2 -> r1 * r <= r2 * r.
Lemma Rmult_ge_compat_l : forall r r1 r2, r >= 0 -> r1 >= r2 -> r * r1 >= r * r2.
Lemma Rmult_ge_compat_r : forall r r1 r2, r >= 0 -> r1 >= r2 -> r1 * r >= r2 * r.
Lemma Rmult_le_compat : forall r1 r2 r3 r4,   0 <= r1 -> 0 <= r3 -> r1 <= r2 -> r3 <= r4 -> r1 * r3 <= r2 * r4.
Lemma Rmult_ge_compat : forall r1 r2 r3 r4,   r2 >= 0 -> r4 >= 0 -> r1 >= r2 -> r3 >= r4 -> r1 * r3 >= r2 * r4.
Lemma Rmult_gt_0_lt_compat : forall r1 r2 r3 r4,   r3 > 0 -> r2 > 0 -> r1 < r2 -> r3 < r4 -> r1 * r3 < r2 * r4.
Lemma Rmult_le_0_lt_compat : forall r1 r2 r3 r4,   0 <= r1 -> 0 <= r3 -> r1 < r2 -> r3 < r4 -> r1 * r3 < r2 * r4.
Lemma Rmult_lt_0_compat : forall r1 r2, 0 < r1 -> 0 < r2 -> 0 < r1 * r2.
Lemma Rmult_gt_0_compat : forall r1 r2, r1 > 0 -> r2 > 0 -> r1 * r2 > 0.
Lemma Rmult_le_compat_neg_l : forall r r1 r2, r <= 0 -> r1 <= r2 -> r * r2 <= r * r1.
Lemma Rmult_le_ge_compat_neg_l : forall r r1 r2, r <= 0 -> r1 <= r2 -> r * r1 >= r * r2.
Lemma Rmult_lt_gt_compat_neg_l : forall r r1 r2, r < 0 -> r1 < r2 -> r * r1 > r * r2.
Lemma Rmult_lt_reg_l : forall r r1 r2, 0 < r -> r * r1 < r * r2 -> r1 < r2.
Lemma Rmult_lt_reg_r : forall r r1 r2 : R, 0 < r -> r1 * r < r2 * r -> r1 < r2.
Lemma Rmult_gt_reg_l : forall r r1 r2, 0 < r -> r * r1 < r * r2 -> r1 < r2.
Lemma Rmult_le_reg_l : forall r r1 r2, 0 < r -> r * r1 <= r * r2 -> r1 <= r2.
Lemma Rmult_le_reg_r : forall r r1 r2, 0 < r -> r1 * r <= r2 * r -> r1 <= r2.
Lemma Rlt_minus : forall r1 r2, r1 < r2 -> r1 - r2 < 0.
Lemma Rgt_minus : forall r1 r2, r1 > r2 -> r1 - r2 > 0.
Lemma Rle_minus : forall r1 r2, r1 <= r2 -> r1 - r2 <= 0.
Lemma Rge_minus : forall r1 r2, r1 >= r2 -> r1 - r2 >= 0.
Lemma Rminus_lt : forall r1 r2, r1 - r2 < 0 -> r1 < r2.
Lemma Rminus_gt : forall r1 r2, r1 - r2 > 0 -> r1 > r2.
Lemma Rminus_le : forall r1 r2, r1 - r2 <= 0 -> r1 <= r2.
Lemma Rminus_ge : forall r1 r2, r1 - r2 >= 0 -> r1 >= r2.
Lemma tech_Rplus : forall r (s:R), 0 <= r -> 0 < s -> r + s <> 0.
Lemma Rle_0_sqr : forall r, 0 <= Rsqr r.
Lemma Rlt_0_sqr : forall r, r <> 0 -> 0 < Rsqr r.
Lemma Rplus_sqr_eq_0_l : forall r1 r2, Rsqr r1 + Rsqr r2 = 0 -> r1 = 0.
Lemma Rplus_sqr_eq_0 : forall r1 r2, Rsqr r1 + Rsqr r2 = 0 -> r1 = 0 /\ r2 = 0.
Lemma Rlt_0_1 : 0 < 1.
Lemma Rle_0_1 : 0 <= 1.
Lemma Rinv_0_lt_compat : forall r, 0 < r -> 0 < / r.
Lemma Rinv_lt_0_compat : forall r, r < 0 -> / r < 0.
Lemma Rinv_lt_contravar : forall r1 r2, 0 < r1 * r2 -> r1 < r2 -> / r2 < / r1.
Lemma Rinv_1_lt_contravar : forall r1 r2, 1 <= r1 -> r1 < r2 -> / r2 < / r1.
Lemma Rle_lt_0_plus_1 : forall r, 0 <= r -> 0 < r + 1.
Lemma Rlt_plus_1 : forall r, r < r + 1.
Lemma tech_Rgt_minus : forall r1 r2, 0 < r2 -> r1 > r1 - r2.
Lemma S_INR : forall n:nat, INR (S n) = INR n + 1.
Lemma S_O_plus_INR : forall n:nat, INR (1 + n) = INR 1 + INR n.
Lemma plus_INR : forall n m:nat, INR (n + m) = INR n + INR m.
Lemma minus_INR : forall n m:nat, (m <= n)%nat -> INR (n - m) = INR n - INR m.
Lemma mult_INR : forall n m:nat, INR (n * m) = INR n * INR m.
Lemma lt_0_INR : forall n:nat, (0 < n)%nat -> 0 < INR n.
Lemma lt_INR : forall n m:nat, (n < m)%nat -> INR n < INR m.
Lemma lt_1_INR : forall n:nat, (1 < n)%nat -> 1 < INR n.
Lemma pos_INR_nat_of_P : forall p:positive, 0 < INR (Pos.to_nat p).
Lemma pos_INR : forall n:nat, 0 <= INR n.
Lemma INR_lt : forall n m:nat, INR n < INR m -> (n < m)%nat.
Lemma le_INR : forall n m:nat, (n <= m)%nat -> INR n <= INR m.
Lemma INR_not_0 : forall n:nat, INR n <> 0 -> n <> 0%nat.
Lemma not_0_INR : forall n:nat, n <> 0%nat -> INR n <> 0.
Lemma not_INR : forall n m:nat, n <> m -> INR n <> INR m.
Lemma INR_eq : forall n m:nat, INR n = INR m -> n = m.
Lemma INR_le : forall n m:nat, INR n <= INR m -> (n <= m)%nat.
Lemma not_1_INR : forall n:nat, n <> 1%nat -> INR n <> 1.
Lemma IZN : forall n:Z, (0 <= n)%Z ->  exists m : nat, n = Z.of_nat m.
Lemma INR_IZR_INZ : forall n:nat, INR n = IZR (Z.of_nat n).
Lemma plus_IZR_NEG_POS : forall p q:positive, IZR (Zpos p + Zneg q) = IZR (Zpos p) + IZR (Zneg q).
Lemma plus_IZR : forall n m:Z, IZR (n + m) = IZR n + IZR m.
Lemma mult_IZR : forall n m:Z, IZR (n * m) = IZR n * IZR m.
Lemma pow_IZR : forall z n, pow (IZR z) n = IZR (Z.pow z (Z.of_nat n)).
Lemma succ_IZR : forall n:Z, IZR (Z.succ n) = IZR n + 1.
Lemma opp_IZR : forall n:Z, IZR (- n) = - IZR n.
Lemma minus_IZR : forall n m:Z, IZR (n - m) = IZR n - IZR m.
Lemma Z_R_minus : forall n m:Z, IZR n - IZR m = IZR (n - m).
Lemma lt_0_IZR : forall n:Z, 0 < IZR n -> (0 < n)%Z.
Lemma lt_IZR : forall n m:Z, IZR n < IZR m -> (n < m)%Z.
Lemma eq_IZR_R0 : forall n:Z, IZR n = 0 -> n = 0%Z.
Lemma eq_IZR : forall n m:Z, IZR n = IZR m -> n = m.
Lemma not_0_IZR : forall n:Z, n <> 0%Z -> IZR n <> 0.
Lemma le_0_IZR : forall n:Z, 0 <= IZR n -> (0 <= n)%Z.
Lemma le_IZR : forall n m:Z, IZR n <= IZR m -> (n <= m)%Z.
Lemma le_IZR_R1 : forall n:Z, IZR n <= 1 -> (n <= 1)%Z.
Lemma IZR_ge : forall n m:Z, (n >= m)%Z -> IZR n >= IZR m.
Lemma IZR_le : forall n m:Z, (n <= m)%Z -> IZR n <= IZR m.
Lemma IZR_lt : forall n m:Z, (n < m)%Z -> IZR n < IZR m.
Lemma one_IZR_lt1 : forall n:Z, -1 < IZR n < 1 -> n = 0%Z.
Lemma one_IZR_r_R1 : forall r (n m:Z), r < IZR n <= r + 1 -> r < IZR m <= r + 1 -> n = m.
Lemma single_z_r_R1 : forall r (n m:Z),   r < IZR n -> IZR n <= r + 1 -> r < IZR m -> IZR m <= r + 1 -> n = m.
Lemma tech_single_z_r_R1 : forall r (n:Z),   r < IZR n ->   IZR n <= r + 1 ->   (exists s : Z, s <> n /\ r < IZR s /\ IZR s <= r + 1) -> False.
Lemma Rmult_le_pos : forall r1 r2, 0 <= r1 -> 0 <= r2 -> 0 <= r1 * r2.
Lemma Rle_Rinv : forall x y:R, 0 < x -> 0 < y -> x <= y -> / y <= / x.
Lemma double : forall r1, 2 * r1 = r1 + r1.
Lemma double_var : forall r1, r1 = r1 / 2 + r1 / 2.
Lemma Rmult_ge_0_gt_0_lt_compat : forall r1 r2 r3 r4,   r3 >= 0 -> r2 > 0 -> r1 < r2 -> r3 < r4 -> r1 * r3 < r2 * r4.
Lemma le_epsilon : forall r1 r2, (forall eps:R, 0 < eps -> r1 <= r2 + eps) -> r1 <= r2.
Lemma completeness_weak : forall E:R -> Prop,   bound E -> (exists x : R, E x) ->  exists m : R, is_lub E m.
Lemma mod_always_pos a b : b<>0 -> 0 <= modulo a b < Z.abs b.
Lemma mod_bound_pos a b : 0<=a -> 0<b -> 0 <= modulo a b < b.
Lemma formule : forall (x h l1 l2:R) (f1 f2:R -> R),   h <> 0 ->   f2 x <> 0 ->   f2 (x + h) <> 0 ->   (f1 (x + h) / f2 (x + h) - f1 x / f2 x) / h -   (l1 * f2 x - l2 * f1 x) / Rsqr (f2 x) =   / f2 (x + h) * ((f1 (x + h) - f1 x) / h - l1) +   l1 / (f2 x * f2 (x + h)) * (f2 x - f2 (x + h)) -   f1 x / (f2 x * f2 (x + h)) * ((f2 (x + h) - f2 x) / h - l2) +   l2 * f1 x / (Rsqr (f2 x) * f2 (x + h)) * (f2 (x + h) - f2 x).
Lemma maj_term1 : forall (x h eps l1 alp_f2:R) (eps_f2 alp_f1d:posreal)   (f1 f2:R -> R),   0 < eps ->   f2 x <> 0 ->   f2 (x + h) <> 0 ->   (forall h:R,     h <> 0 ->     Rabs h < alp_f1d ->     Rabs ((f1 (x + h) - f1 x) / h - l1) < Rabs (eps * f2 x / 8)) ->   (forall a:R,     Rabs a < Rmin eps_f2 alp_f2 -> / Rabs (f2 (x + a)) < 2 / Rabs (f2 x)) ->   h <> 0 ->   Rabs h < alp_f1d ->   Rabs h < Rmin eps_f2 alp_f2 ->   Rabs (/ f2 (x + h) * ((f1 (x + h) - f1 x) / h - l1)) < eps / 4.
Lemma maj_term2 : forall (x h eps l1 alp_f2 alp_f2t2:R) (eps_f2:posreal)   (f2:R -> R),   0 < eps ->   f2 x <> 0 ->   f2 (x + h) <> 0 ->   (forall a:R,     Rabs a < alp_f2t2 ->     Rabs (f2 (x + a) - f2 x) < Rabs (eps * Rsqr (f2 x) / (8 * l1))) ->   (forall a:R,     Rabs a < Rmin eps_f2 alp_f2 -> / Rabs (f2 (x + a)) < 2 / Rabs (f2 x)) ->   h <> 0 ->   Rabs h < alp_f2t2 ->   Rabs h < Rmin eps_f2 alp_f2 ->   l1 <> 0 -> Rabs (l1 / (f2 x * f2 (x + h)) * (f2 x - f2 (x + h))) < eps / 4.
Lemma maj_term3 : forall (x h eps l2 alp_f2:R) (eps_f2 alp_f2d:posreal)   (f1 f2:R -> R),   0 < eps ->   f2 x <> 0 ->   f2 (x + h) <> 0 ->   (forall h:R,     h <> 0 ->     Rabs h < alp_f2d ->     Rabs ((f2 (x + h) - f2 x) / h - l2) <     Rabs (Rsqr (f2 x) * eps / (8 * f1 x))) ->   (forall a:R,     Rabs a < Rmin eps_f2 alp_f2 -> / Rabs (f2 (x + a)) < 2 / Rabs (f2 x)) ->   h <> 0 ->   Rabs h < alp_f2d ->   Rabs h < Rmin eps_f2 alp_f2 ->   f1 x <> 0 ->   Rabs (f1 x / (f2 x * f2 (x + h)) * ((f2 (x + h) - f2 x) / h - l2)) <   eps / 4.
Lemma maj_term4 : forall (x h eps l2 alp_f2 alp_f2c:R) (eps_f2:posreal)   (f1 f2:R -> R),   0 < eps ->   f2 x <> 0 ->   f2 (x + h) <> 0 ->   (forall a:R,     Rabs a < alp_f2c ->     Rabs (f2 (x + a) - f2 x) <     Rabs (Rsqr (f2 x) * f2 x * eps / (8 * f1 x * l2))) ->   (forall a:R,     Rabs a < Rmin eps_f2 alp_f2 -> / Rabs (f2 (x + a)) < 2 / Rabs (f2 x)) ->   h <> 0 ->   Rabs h < alp_f2c ->   Rabs h < Rmin eps_f2 alp_f2 ->   f1 x <> 0 ->   l2 <> 0 ->   Rabs (l2 * f1 x / (Rsqr (f2 x) * f2 (x + h)) * (f2 (x + h) - f2 x)) <   eps / 4.
Lemma D_x_no_cond : forall x a:R, a <> 0 -> D_x no_cond x (x + a).
Lemma Rabs_4 : forall a b c d:R, Rabs (a + b + c + d) <= Rabs a + Rabs b + Rabs c + Rabs d.
Lemma Rlt_4 : forall a b c d e f g h:R,   a < b -> c < d -> e < f -> g < h -> a + c + e + g < b + d + f + h.
Lemma quadruple : forall x:R, 4 * x = x + x + x + x.
Lemma quadruple_var : forall x:R, x = x / 4 + x / 4 + x / 4 + x / 4.
Lemma continuous_neq_0 : forall (f:R -> R) (x0:R),   continuity_pt f x0 ->   f x0 <> 0 ->   exists eps : posreal, (forall h:R, Rabs h < eps -> f (x0 + h) <> 0).
Lemma eq_refl : forall x : t, eq x x.
Lemma eq_sym : forall x y : t, eq x y -> eq y x.
Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.
Lemma meq_refl : forall x:multiset, meq x x.
Lemma meq_trans : forall x y z:multiset, meq x y -> meq y z -> meq x z.
Lemma meq_sym : forall x y:multiset, meq x y -> meq y x.
Lemma munion_empty_left : forall x:multiset, meq x (munion EmptyBag x).
Lemma munion_empty_right : forall x:multiset, meq x (munion x EmptyBag).
Lemma munion_comm : forall x y:multiset, meq (munion x y) (munion y x).
Lemma munion_ass :   forall x y z:multiset, meq (munion (munion x y) z) (munion x (munion y z)).
Lemma meq_left :   forall x y z:multiset, meq x y -> meq (munion x z) (munion y z).
Lemma meq_right :   forall x y z:multiset, meq x y -> meq (munion z x) (munion z y).
Lemma munion_rotate :   forall x y z:multiset, meq (munion x (munion y z)) (munion z (munion x y)).
Lemma meq_congr :   forall x y z t:multiset, meq x y -> meq z t -> meq (munion x z) (munion y t).
Lemma munion_perm_left :   forall x y z:multiset, meq (munion x (munion y z)) (munion y (munion x z)).
Lemma multiset_twist1 :   forall x y z t:multiset,     meq (munion x (munion (munion y z) t)) (munion (munion y (munion x t)) z).
Lemma multiset_twist2 :   forall x y z t:multiset,     meq (munion x (munion (munion y z) t)) (munion (munion y (munion x z)) t).
Lemma treesort_twist1 :   forall x y z t u:multiset,     meq u (munion y z) ->     meq (munion x (munion u t)) (munion (munion y (munion x t)) z).
Lemma treesort_twist2 :   forall x y z t u:multiset,     meq u (munion y z) ->     meq (munion x (munion u t)) (munion (munion y (munion x z)) t).
Lemma meq_singleton : forall a a',   eqA a a' -> meq (SingletonBag a) (SingletonBag a').
Lemma pow_sub_r : forall a b c, a~=0 -> c<=b -> a^(b-c) == a^b / a^c.
Lemma pow_div_l : forall a b c, b~=0 -> a mod b == 0 -> (a/b)^c == a^c / b^c.
Lemma exists_div2 a : exists a' (b:bool), a == 2*a' + b.
Lemma testbit_0_r a (b:bool) : testbit (2*a+b) 0 = b.
Lemma testbit_succ_r a (b:bool) n : testbit (2*a+b) (succ n) = testbit a n.
Lemma testbit_spec' a n : a.[n] == (a / 2^n) mod 2.
Lemma testbit_spec a n : exists l h, 0<=l<2^n /\ a == l + (a.[n] + 2*h)*2^n.
Lemma testbit_true : forall a n, a.[n] = true <-> (a / 2^n) mod 2 == 1.
Lemma testbit_false : forall a n, a.[n] = false <-> (a / 2^n) mod 2 == 0.
Lemma testbit_eqb : forall a n, a.[n] = eqb ((a / 2^n) mod 2) 1.
Lemma b2n_inj : forall (a0 b0:bool), a0 == b0 -> a0 = b0.
Lemma add_b2n_double_div2 : forall (a0:bool) a, (a0+2*a)/2 == a.
Lemma add_b2n_double_bit0 : forall (a0:bool) a, (a0+2*a).[0] = a0.
Lemma b2n_div2 : forall (a0:bool), a0/2 == 0.
Lemma b2n_bit0 : forall (a0:bool), a0.[0] = a0.
Lemma testbit_unique : forall a n (a0:bool) l h, l<2^n -> a == l + (a0 + 2*h)*2^n -> a.[n] = a0.
Lemma bits_0 : forall n, 0.[n] = false.
Lemma bit0_odd : forall a, a.[0] = odd a.
Lemma bit0_eqb : forall a, a.[0] = eqb (a mod 2) 1.
Lemma bit0_mod : forall a, a.[0] == a mod 2.
Lemma testbit_odd : forall a n, a.[n] = odd (a>>n).
Lemma bit_log2 : forall a, a~=0 -> a.[log2 a] = true.
Lemma bits_above_log2 : forall a n, log2 a < n -> a.[n] = false.
Lemma div2_bits : forall a n, (a/2).[n] = a.[S n].
Lemma div_pow2_bits : forall a n m, (a/2^n).[m] = a.[m+n].
Lemma double_bits_succ : forall a n, (2*a).[S n] = a.[n].
Lemma mul_pow2_bits_add : forall a n m, (a*2^n).[m+n] = a.[m].
Lemma mul_pow2_bits_high : forall a n m, n<=m -> (a*2^n).[m] = a.[m-n].
Lemma mul_pow2_bits_low : forall a n m, m<n -> (a*2^n).[m] = false.
Lemma mod_pow2_bits_high : forall a n m, n<=m -> (a mod 2^n).[m] = false.
Lemma mod_pow2_bits_low : forall a n m, m<n -> (a mod 2^n).[m] = a.[m].
Lemma bits_inj_0 : forall a, (forall n, a.[n] = false) -> a == 0.
Lemma bits_inj : forall a b, testbit a === testbit b -> a == b.
Lemma bits_inj_iff : forall a b, testbit a === testbit b <-> a == b.
Lemma are_bits : forall (f:t->bool), Proper (eq==>Logic.eq) f ->
Lemma shiftr_spec' : forall a n m, (a >> n).[m] = a.[m+n].
Lemma shiftl_spec_high' : forall a n m, n<=m -> (a << n).[m] = a.[m-n].
Lemma shiftr_div_pow2 : forall a n, a >> n == a / 2^n.
Lemma shiftl_mul_pow2 : forall a n, a << n == a * 2^n.
Lemma shiftl_spec_alt : forall a n m, (a << n).[m+n] = a.[m].
Lemma shiftl_shiftl : forall a n m, (a << n) << m == a << (n+m).
Lemma shiftr_shiftr : forall a n m, (a >> n) >> m == a >> (n+m).
Lemma shiftr_shiftl_l : forall a n m, m<=n -> (a << n) >> m == a << (n-m).
Lemma shiftr_shiftl_r : forall a n m, n<=m -> (a << n) >> m == a >> (m-n).
Lemma shiftl_1_l : forall n, 1 << n == 2^n.
Lemma shiftl_0_r : forall a, a << 0 == a.
Lemma shiftr_0_r : forall a, a >> 0 == a.
Lemma shiftl_0_l : forall n, 0 << n == 0.
Lemma shiftr_0_l : forall n, 0 >> n == 0.
Lemma shiftl_eq_0_iff : forall a n, a << n == 0 <-> a == 0.
Lemma shiftr_eq_0_iff : forall a n, a >> n == 0 <-> a==0 \/ (0<a /\ log2 a < n).
Lemma shiftr_eq_0 : forall a n, log2 a < n -> a >> n == 0.
Lemma div2_div : forall a, div2 a == a/2.
Lemma div2_odd : forall a, a == 2*(div2 a) + odd a.
Lemma lxor_eq : forall a a', lxor a a' == 0 -> a == a'.
Lemma lxor_nilpotent : forall a, lxor a a == 0.
Lemma lxor_eq_0_iff : forall a a', lxor a a' == 0 <-> a == a'.
Lemma lxor_0_l : forall a, lxor 0 a == a.
Lemma lxor_0_r : forall a, lxor a 0 == a.
Lemma lxor_comm : forall a b, lxor a b == lxor b a.
Lemma lxor_assoc : forall a b c, lxor (lxor a b) c == lxor a (lxor b c).
Lemma lor_0_l : forall a, lor 0 a == a.
Lemma lor_0_r : forall a, lor a 0 == a.
Lemma lor_comm : forall a b, lor a b == lor b a.
Lemma lor_assoc : forall a b c, lor a (lor b c) == lor (lor a b) c.
Lemma lor_diag : forall a, lor a a == a.
Lemma lor_eq_0_l : forall a b, lor a b == 0 -> a == 0.
Lemma lor_eq_0_iff : forall a b, lor a b == 0 <-> a == 0 /\ b == 0.
Lemma land_0_l : forall a, land 0 a == 0.
Lemma land_0_r : forall a, land a 0 == 0.
Lemma land_comm : forall a b, land a b == land b a.
Lemma land_assoc : forall a b c, land a (land b c) == land (land a b) c.
Lemma land_diag : forall a, land a a == a.
Lemma ldiff_0_l : forall a, ldiff 0 a == 0.
Lemma ldiff_0_r : forall a, ldiff a 0 == a.
Lemma ldiff_diag : forall a, ldiff a a == 0.
Lemma lor_land_distr_l : forall a b c, lor (land a b) c == land (lor a c) (lor b c).
Lemma lor_land_distr_r : forall a b c, lor a (land b c) == land (lor a b) (lor a c).
Lemma land_lor_distr_l : forall a b c, land (lor a b) c == lor (land a c) (land b c).
Lemma land_lor_distr_r : forall a b c, land a (lor b c) == lor (land a b) (land a c).
Lemma ldiff_ldiff_l : forall a b c, ldiff (ldiff a b) c == ldiff a (lor b c).
Lemma lor_ldiff_and : forall a b, lor (ldiff a b) (land a b) == a.
Lemma land_ldiff : forall a b, land (ldiff a b) b == 0.
Lemma setbit_spec' : forall a n, setbit a n == lor a (2^n).
Lemma clearbit_spec' : forall a n, clearbit a n == ldiff a (2^n).
Lemma pow2_bits_true : forall n, (2^n).[n] = true.
Lemma pow2_bits_false : forall n m, n~=m -> (2^n).[m] = false.
Lemma pow2_bits_eqb : forall n m, (2^n).[m] = eqb n m.
Lemma setbit_eqb : forall a n m, (setbit a n).[m] = eqb n m || a.[m].
Lemma setbit_iff : forall a n m, (setbit a n).[m] = true <-> n==m \/ a.[m] = true.
Lemma setbit_eq : forall a n, (setbit a n).[n] = true.
Lemma setbit_neq : forall a n m, n~=m -> (setbit a n).[m] = a.[m].
Lemma clearbit_eqb : forall a n m, (clearbit a n).[m] = a.[m] && negb (eqb n m).
Lemma clearbit_iff : forall a n m, (clearbit a n).[m] = true <-> a.[m] = true /\ n~=m.
Lemma clearbit_eq : forall a n, (clearbit a n).[n] = false.
Lemma clearbit_neq : forall a n m, n~=m -> (clearbit a n).[m] = a.[m].
Lemma shiftl_lxor : forall a b n, (lxor a b) << n == lxor (a << n) (b << n).
Lemma shiftr_lxor : forall a b n, (lxor a b) >> n == lxor (a >> n) (b >> n).
Lemma shiftl_land : forall a b n, (land a b) << n == land (a << n) (b << n).
Lemma shiftr_land : forall a b n, (land a b) >> n == land (a >> n) (b >> n).
Lemma shiftl_lor : forall a b n, (lor a b) << n == lor (a << n) (b << n).
Lemma shiftr_lor : forall a b n, (lor a b) >> n == lor (a >> n) (b >> n).
Lemma shiftl_ldiff : forall a b n, (ldiff a b) << n == ldiff (a << n) (b << n).
Lemma shiftr_ldiff : forall a b n, (ldiff a b) >> n == ldiff (a >> n) (b >> n).
Lemma ones_equiv : forall n, ones n == P (2^n).
Lemma ones_add : forall n m, ones (m+n) == 2^m * ones n + ones m.
Lemma ones_div_pow2 : forall n m, m<=n -> ones n / 2^m == ones (n-m).
Lemma ones_mod_pow2 : forall n m, m<=n -> (ones n) mod (2^m) == ones m.
Lemma ones_spec_low : forall n m, m<n -> (ones n).[m] = true.
Lemma ones_spec_high : forall n m, n<=m -> (ones n).[m] = false.
Lemma ones_spec_iff : forall n m, (ones n).[m] = true <-> m<n.
Lemma lnot_spec_low : forall a n m, m<n -> (lnot a n).[m] = negb a.[m].
Lemma lnot_spec_high : forall a n m, n<=m -> (lnot a n).[m] = a.[m].
Lemma lnot_involutive : forall a n, lnot (lnot a n) n == a.
Lemma lnot_0_l : forall n, lnot 0 n == ones n.
Lemma lnot_ones : forall n, lnot (ones n) n == 0.
Lemma lor_ones_low : forall a n, log2 a < n -> lor a (ones n) == ones n.
Lemma land_ones : forall a n, land a (ones n) == a mod 2^n.
Lemma land_ones_low : forall a n, log2 a < n -> land a (ones n) == a.
Lemma ldiff_ones_r : forall a n, ldiff a (ones n) == (a >> n) << n.
Lemma ldiff_ones_r_low : forall a n, log2 a < n -> ldiff a (ones n) == 0.
Lemma ldiff_ones_l_low : forall a n, log2 a < n -> ldiff (ones n) a == lnot a n.
Lemma lor_lnot_diag : forall a n, lor a (lnot a n) == lor a (ones n).
Lemma lor_lnot_diag_low : forall a n, log2 a < n -> lor a (lnot a n) == ones n.
Lemma land_lnot_diag : forall a n, land a (lnot a n) == ldiff a (ones n).
Lemma land_lnot_diag_low : forall a n, log2 a < n -> land a (lnot a n) == 0.
Lemma lnot_lor_low : forall a b n, log2 a < n -> log2 b < n -> lnot (lor a b) n == land (lnot a n) (lnot b n).
Lemma lnot_land_low : forall a b n, log2 a < n -> log2 b < n -> lnot (land a b) n == lor (lnot a n) (lnot b n).
Lemma ldiff_land_low : forall a b n, log2 a < n -> ldiff a b == land a (lnot b n).
Lemma lnot_ldiff_low : forall a b n, log2 a < n -> log2 b < n -> lnot (ldiff a b) n == lor (lnot a n) b.
Lemma lxor_lnot_lnot : forall a b n, lxor (lnot a n) (lnot b n) == lxor a b.
Lemma lnot_lxor_l : forall a b n, lnot (lxor a b) n == lxor (lnot a n) b.
Lemma lnot_lxor_r : forall a b n, lnot (lxor a b) n == lxor a (lnot b n).
Lemma lxor_lor : forall a b, land a b == 0 -> lxor a b == lor a b.
Lemma log2_bits_unique : forall a n, a.[n] = true ->
Lemma log2_shiftr : forall a n, log2 (a >> n) == log2 a - n.
Lemma log2_shiftl : forall a n, a~=0 -> log2 (a << n) == log2 a + n.
Lemma log2_lor : forall a b, log2 (lor a b) == max (log2 a) (log2 b).
Lemma log2_land : forall a b, log2 (land a b) <= min (log2 a) (log2 b).
Lemma log2_lxor : forall a b, log2 (lxor a b) <= max (log2 a) (log2 b).
Lemma add_bit0 : forall a b, (a+b).[0] = xorb a.[0] b.[0].
Lemma add3_bit0 : forall a b c, (a+b+c).[0] = xor3 a.[0] b.[0] c.[0].
Lemma add3_bits_div2 : forall (a0 b0 c0 : bool), (a0 + b0 + c0)/2 == nextcarry a0 b0 c0.
Lemma add_carry_div2 : forall a b (c0:bool), (a + b + c0)/2 == a/2 + b/2 + nextcarry a.[0] b.[0] c0.
Lemma add_carry_bits : forall a b (c0:bool), exists c, a+b+c0 == lxor3 a b c /\ c/2 == lnextcarry a b c /\ c.[0] = c0.
Lemma add_bit1 : forall a b, (a+b).[1] = xor3 a.[1] b.[1] (a.[0] && b.[0]).
Lemma nocarry_equiv : forall a b c, c/2 == lnextcarry a b c -> c.[0] = false ->
Lemma add_nocarry_lxor : forall a b, land a b == 0 -> a+b == lxor a b.
Lemma ldiff_le : forall a b, ldiff a b == 0 -> a <= b.
Lemma sub_nocarry_ldiff : forall a b, ldiff b a == 0 -> a-b == ldiff a b.
Lemma add_lnot_diag_low : forall a n, log2 a < n -> a + lnot a n == ones n.
Lemma lnot_sub_low : forall a n, log2 a < n -> lnot a n == ones n - a.
Lemma add_nocarry_lt_pow2 : forall a b n, land a b == 0 -> a < 2^n -> b < 2^n -> a+b < 2^n.
Lemma add_nocarry_mod_lt_pow2 : forall a b n, land a b == 0 -> a mod 2^n + b mod 2^n < 2^n.
Lemma equal_f : forall {A B : Type} {f g : A -> B}, f = g -> forall x, f x = g x.
Lemma functional_extensionality {A B} (f g : A -> B) : (forall x, f x = g x) -> f = g.
Lemma eta_expansion_dep {A} {B : A -> Type} (f : forall x : A, B x) : f = fun x => f x.
Lemma eta_expansion {A B} (f : A -> B) : f = fun x => f x.
Lemma In_eq_iff : E.eq x y -> (In x s <-> In y s).
Lemma mem_iff : In x s <-> mem x s = true.
Lemma not_mem_iff : ~In x s <-> mem x s = false.
Lemma equal_iff : s[=]s' <-> equal s s' = true.
Lemma subset_iff : s[<=]s' <-> subset s s' = true.
Lemma empty_iff : In x empty <-> False.
Lemma is_empty_iff : Empty s <-> is_empty s = true.
Lemma singleton_iff : In y (singleton x) <-> E.eq x y.
Lemma add_iff : In y (add x s) <-> E.eq x y \/ In y s.
Lemma add_neq_iff : ~ E.eq x y -> (In y (add x s)  <-> In y s).
Lemma remove_iff : In y (remove x s) <-> In y s /\ ~E.eq x y.
Lemma remove_neq_iff : ~ E.eq x y -> (In y (remove x s) <-> In y s).
Lemma union_iff : In x (union s s') <-> In x s \/ In x s'.
Lemma inter_iff : In x (inter s s') <-> In x s /\ In x s'.
Lemma diff_iff : In x (diff s s') <-> In x s /\ ~ In x s'.
Lemma filter_iff :  compat_bool E.eq f -> (In x (filter f s) <-> In x s /\ f x = true).
Lemma for_all_iff : compat_bool E.eq f ->
Lemma exists_iff : compat_bool E.eq f ->
Lemma elements_iff : In x s <-> InA E.eq x (elements s).
Lemma mem_b : E.eq x y -> mem x s = mem y s.
Lemma empty_b : mem y empty = false.
Lemma add_b : mem y (add x s) = eqb x y || mem y s.
Lemma add_neq_b : ~ E.eq x y -> mem y (add x s) = mem y s.
Lemma remove_b : mem y (remove x s) = mem y s && negb (eqb x y).
Lemma remove_neq_b : ~ E.eq x y -> mem y (remove x s) = mem y s.
Lemma singleton_b : mem y (singleton x) = eqb x y.
Lemma union_b : mem x (union s s') = mem x s || mem x s'.
Lemma inter_b : mem x (inter s s') = mem x s && mem x s'.
Lemma diff_b : mem x (diff s s') = mem x s && negb (mem x s').
Lemma elements_b : mem x s = existsb (eqb x) (elements s).
Lemma filter_b : compat_bool E.eq f -> mem x (filter f s) = mem x s && f x.
Lemma for_all_b : compat_bool E.eq f ->
Lemma exists_b : compat_bool E.eq f ->
Lemma Subset_refl : forall s, s[<=]s.
Lemma Subset_trans : forall s s' s'', s[<=]s'->s'[<=]s''->s[<=]s''.
Lemma filter_equal : forall f, compat_bool E.eq f ->
Lemma filter_ext : forall f f', compat_bool E.eq f -> (forall x, f x = f' x) ->
Lemma filter_subset : forall f, compat_bool E.eq f ->
Lemma pos_sub_spec p q : pos_sub p q = match (p ?= q)%positive with  | Eq => 0  | Lt => neg (q - p)  | Gt => pos (p - q) end.
Lemma pos_sub_discr p q : match pos_sub p q with | Z0 => p = q | pos k => p = q + k | neg k => q = p + k end%positive.
Lemma pos_sub_diag p : pos_sub p p = 0.
Lemma pos_sub_lt p q : (p < q)%positive -> pos_sub p q = neg (q - p).
Lemma pos_sub_gt p q : (q < p)%positive -> pos_sub p q = pos (p - q).
Lemma pos_sub_opp p q : - pos_sub p q = pos_sub q p.
Lemma add_0_r n : n + 0 = n.
Lemma add_comm n m : n + m = m + n.
Lemma opp_add_distr n m : - (n + m) = - n + - m.
Lemma opp_inj n m : -n = -m -> n = m.
Lemma pos_sub_add p q r : pos_sub (p + q) r = pos p + pos_sub q r.
Lemma add_assoc n m p : n + (m + p) = n + m + p.
Lemma sub_succ_l n m : succ n - m = succ (n - m).
Lemma add_opp_diag_r n : n + - n = 0.
Lemma add_opp_diag_l n : - n + n = 0.
Lemma mul_comm n m : n * m = m * n.
Lemma mul_assoc n m p : n * (m * p) = n * m * p.
Lemma mul_1_l n : 1 * n = n.
Lemma mul_1_r n : n * 1 = n.
Lemma mul_opp_l n m : - n * m = - (n * m).
Lemma mul_opp_r n m : n * - m = - (n * m).
Lemma mul_opp_opp n m : - n * - m = n * m.
Lemma mul_opp_comm n m : - n * m = n * - m.
Lemma mul_add_distr_pos (p:positive) n m : pos p * (n + m) = pos p * n + pos p * m.
Lemma mul_add_distr_l n m p : n * (m + p) = n * m + n * p.
Lemma mul_add_distr_r n m p : (n + m) * p = n * p + m * p.
Lemma divide_Zpos p q : (pos p|pos q) <-> (p|q)%positive.
Lemma divide_Zpos_Zneg_r n p : (n|pos p) <-> (n|neg p).
Lemma divide_Zpos_Zneg_l n p : (pos p|n) <-> (neg p|n).
Lemma testbit_of_N a n : testbit (of_N a) (of_N n) = N.testbit a n.
Lemma testbit_of_N' a n : 0<=n -> testbit (of_N a) n = N.testbit a (to_N n).
Lemma testbit_Zpos a n : 0<=n -> testbit (pos a) n = N.testbit (N.pos a) (to_N n).
Lemma testbit_Zneg a n : 0<=n -> testbit (neg a) n = negb (N.testbit (Pos.pred_N a) (to_N n)).
Lemma one_succ : 1 = succ 0.
Lemma two_succ : 2 = succ 1.
Lemma add_0_l n : 0 + n = n.
Lemma add_succ_l n m : succ n + m = succ (n + m).
Lemma opp_0 : -0 = 0.
Lemma opp_succ n : -(succ n) = pred (-n).
Lemma succ_pred n : succ (pred n) = n.
Lemma pred_succ n : pred (succ n) = n.
Lemma sub_0_r n : n - 0 = n.
Lemma sub_succ_r n m : n - succ m = pred (n - m).
Lemma mul_0_l n : 0 * n = 0.
Lemma mul_succ_l n m : succ n * m = n * m + m.
Lemma eqb_eq n m : (n =? m) = true <-> n = m.
Lemma ltb_lt n m : (n <? m) = true <-> n < m.
Lemma leb_le n m : (n <=? m) = true <-> n <= m.
Lemma compare_eq_iff n m : (n ?= m) = Eq <-> n = m.
Lemma compare_sub n m : (n ?= m) = (n - m ?= 0).
Lemma compare_antisym n m : (m ?= n) = CompOpp (n ?= m).
Lemma compare_lt_iff n m : (n ?= m) = Lt <-> n < m.
Lemma compare_le_iff n m : (n ?= m) <> Gt <-> n <= m.
Lemma lt_succ_r n m : n < succ m <-> n<=m.
Lemma max_l n m : m<=n -> max n m = n.
Lemma max_r n m :  n<=m -> max n m = m.
Lemma min_l n m : n<=m -> min n m = n.
Lemma min_r n m : m<=n -> min n m = m.
Lemma abs_eq n : 0 <= n -> abs n = n.
Lemma abs_neq n : n <= 0 -> abs n = - n.
Lemma sgn_null n : n = 0 -> sgn n = 0.
Lemma sgn_pos n : 0 < n -> sgn n = 1.
Lemma sgn_neg n : n < 0 -> sgn n = -1.
Lemma pow_0_r n : n^0 = 1.
Lemma pow_succ_r n m : 0<=m -> n^(succ m) = n * n^m.
Lemma pow_neg_r n m : m<0 -> n^m = 0.
Lemma pow_pos_fold n p : pow_pos n p = n ^ (pos p).
Lemma square_spec n : square n = n * n.
Lemma sqrtrem_spec n : 0<=n -> let (s,r) := sqrtrem n in n = s*s + r /\ 0 <= r <= 2*s.
Lemma sqrt_spec n : 0<=n -> let s := sqrt n in s*s <= n < (succ s)*(succ s).
Lemma sqrt_neg n : n<0 -> sqrt n = 0.
Lemma sqrtrem_sqrt n : fst (sqrtrem n) = sqrt n.
Lemma log2_spec n : 0 < n -> 2^(log2 n) <= n < 2^(succ (log2 n)).
Lemma log2_nonpos n : n<=0 -> log2 n = 0.
Lemma even_spec n : even n = true <-> Even n.
Lemma odd_spec n : odd n = true <-> Odd n.
Lemma double_spec n : double n = 2*n.
Lemma succ_double_spec n : succ_double n = 2*n + 1.
Lemma pred_double_spec n : pred_double n = 2*n - 1.
Lemma pos_div_eucl_eq a b : 0 < b -> let (q, r) := pos_div_eucl a b in pos a = q * b + r.
Lemma div_eucl_eq a b : b<>0 -> let (q, r) := div_eucl a b in a = b * q + r.
Lemma div_mod a b : b<>0 -> a = b*(a/b) + (a mod b).
Lemma pos_div_eucl_bound a b : 0<b -> 0 <= snd (pos_div_eucl a b) < b.
Lemma mod_pos_bound a b : 0 < b -> 0 <= a mod b < b.
Lemma mod_neg_bound a b : b < 0 -> b < a mod b <= 0.
Lemma quot_rem' a b : a = b*(a÷b) + rem a b.
Lemma quot_rem a b : b<>0 -> a = b*(a÷b) + rem a b.
Lemma rem_bound_pos a b : 0<=a -> 0<b -> 0 <= rem a b < b.
Lemma rem_opp_l' a b : rem (-a) b = - (rem a b).
Lemma rem_opp_r' a b : rem a (-b) = rem a b.
Lemma rem_opp_l a b : b<>0 -> rem (-a) b = - (rem a b).
Lemma rem_opp_r a b : b<>0 -> rem a (-b) = rem a b.
Lemma ggcd_gcd a b : fst (ggcd a b) = gcd a b.
Lemma ggcd_correct_divisors a b : let '(g,(aa,bb)) := ggcd a b in a = g*aa /\ b = g*bb.
Lemma gcd_divide_l a b : (gcd a b | a).
Lemma gcd_divide_r a b : (gcd a b | b).
Lemma gcd_greatest a b c : (c|a) -> (c|b) -> (c | gcd a b).
Lemma gcd_nonneg a b : 0 <= gcd a b.
Lemma div2_spec a : div2 a = shiftr a 1.
Lemma testbit_0_l n : testbit 0 n = false.
Lemma testbit_neg_r a n : n<0 -> testbit a n = false.
Lemma testbit_odd_0 a : testbit (2*a+1) 0 = true.
Lemma testbit_even_0 a : testbit (2*a) 0 = false.
Lemma testbit_odd_succ a n : 0<=n -> testbit (2*a+1) (succ n) = testbit a n.
Lemma testbit_even_succ a n : 0<=n -> testbit (2*a) (succ n) = testbit a n.
Lemma shiftr_spec_aux a n m : 0<=n -> 0<=m -> testbit (shiftr a n) m = testbit a (m+n).
Lemma shiftl_spec_low a n m : m<n -> testbit (shiftl a n) m = false.
Lemma shiftl_spec_high a n m : 0<=m -> n<=m -> testbit (shiftl a n) m = testbit a (m-n).
Lemma shiftr_spec a n m : 0<=m -> testbit (shiftr a n) m = testbit a (m+n).
Lemma lor_spec a b n : testbit (lor a b) n = testbit a n || testbit b n.
Lemma land_spec a b n : testbit (land a b) n = testbit a n && testbit b n.
Lemma ldiff_spec a b n : testbit (ldiff a b) n = testbit a n && negb (testbit b n).
Lemma lxor_spec a b n : testbit (lxor a b) n = xorb (testbit a n) (testbit b n).
Lemma peano_ind (P : Z -> Prop) : P 0 -> (forall x, P x -> P (succ x)) -> (forall x, P x -> P (pred x)) -> forall z, P z.
Lemma bi_induction (P : Z -> Prop) : Proper (eq ==> iff) P -> P 0 -> (forall x, P x <-> P (succ x)) -> forall z, P z.
Lemma gt_lt_iff n m : n > m <-> m < n.
Lemma gt_lt n m : n > m -> m < n.
Lemma lt_gt n m : n < m -> m > n.
Lemma ge_le_iff n m : n >= m <-> m <= n.
Lemma ge_le n m : n >= m -> m <= n.
Lemma le_ge n m : n <= m -> m >= n.
Lemma gtb_ltb n m : (n >? m) = (m <? n).
Lemma geb_leb n m : (n >=? m) = (m <=? n).
Lemma gtb_lt n m : (n >? m) = true <-> m < n.
Lemma geb_le n m : (n >=? m) = true <-> m <= n.
Lemma gtb_spec n m : BoolSpec (m<n) (n<=m) (n >? m).
Lemma geb_spec n m : BoolSpec (m<=n) (n<m) (n >=? m).
Lemma add_reg_l n m p : n + m = n + p -> m = p.
Lemma mul_reg_l n m p : p <> 0 -> p * n = p * m -> n = m.
Lemma mul_reg_r n m p : p <> 0 -> n * p = m * p -> n = m.
Lemma opp_eq_mul_m1 n : - n = n * -1.
Lemma add_diag n : n + n = 2 * n.
Lemma compare_opp n m : (- n ?= - m) = (m ?= n).
Lemma add_compare_mono_l n m p : (n + m ?= n + p) = (m ?= p).
Lemma id p : Z.to_pos (Z.pos p) = p.
Lemma inj p q : Z.pos p = Z.pos q -> p = q.
Lemma inj_iff p q : Z.pos p = Z.pos q <-> p = q.
Lemma is_pos p : 0 < Z.pos p.
Lemma is_nonneg p : 0 <= Z.pos p.
Lemma inj_1 : Z.pos 1 = 1.
Lemma inj_xO p : Z.pos p~0 = 2 * Z.pos p.
Lemma inj_xI p : Z.pos p~1 = 2 * Z.pos p + 1.
Lemma inj_succ p : Z.pos (Pos.succ p) = Z.succ (Z.pos p).
Lemma inj_add p q : Z.pos (p+q) = Z.pos p + Z.pos q.
Lemma inj_sub p q : (p < q)%positive -> Z.pos (q-p) = Z.pos q - Z.pos p.
Lemma inj_sub_max p q : Z.pos (p - q) = Z.max 1 (Z.pos p - Z.pos q).
Lemma inj_pred p : p <> 1%positive -> Z.pos (Pos.pred p) = Z.pred (Z.pos p).
Lemma inj_mul p q : Z.pos (p*q) = Z.pos p * Z.pos q.
Lemma inj_pow_pos p q : Z.pos (p^q) = Z.pow_pos (Z.pos p) q.
Lemma inj_pow p q : Z.pos (p^q) = (Z.pos p)^(Z.pos q).
Lemma inj_square p : Z.pos (Pos.square p) = Z.square (Z.pos p).
Lemma inj_compare p q : (p ?= q)%positive = (Z.pos p ?= Z.pos q).
Lemma inj_leb p q : (p <=? q)%positive = (Z.pos p <=? Z.pos q).
Lemma inj_ltb p q : (p <? q)%positive = (Z.pos p <? Z.pos q).
Lemma inj_eqb p q : (p =? q)%positive = (Z.pos p =? Z.pos q).
Lemma inj_max p q : Z.pos (Pos.max p q) = Z.max (Z.pos p) (Z.pos q).
Lemma inj_min p q : Z.pos (Pos.min p q) = Z.min (Z.pos p) (Z.pos q).
Lemma inj_sqrt p : Z.pos (Pos.sqrt p) = Z.sqrt (Z.pos p).
Lemma inj_gcd p q : Z.pos (Pos.gcd p q) = Z.gcd (Z.pos p) (Z.pos q).
Lemma inj_testbit a n : 0<=n -> Z.testbit (Z.pos a) n = N.testbit (N.pos a) (Z.to_N n).
Lemma inj_neg p q : Z.neg p = Z.neg q -> p = q.
Lemma inj_neg_iff p q : Z.neg p = Z.neg q <-> p = q.
Lemma neg_is_neg p : Z.neg p < 0.
Lemma neg_is_nonpos p : Z.neg p <= 0.
Lemma neg_xO p : Z.neg p~0 = 2 * Z.neg p.
Lemma neg_xI p : Z.neg p~1 = 2 * Z.neg p - 1.
Lemma opp_neg p : - Z.neg p = Z.pos p.
Lemma opp_pos p : - Z.pos p = Z.neg p.
Lemma add_neg_neg p q : Z.neg p + Z.neg q = Z.neg (p+q).
Lemma add_pos_neg p q : Z.pos p + Z.neg q = Z.pos_sub p q.
Lemma add_neg_pos p q : Z.neg p + Z.pos q = Z.pos_sub q p.
Lemma divide_pos_neg_r n p : (n|Z.pos p) <-> (n|Z.neg p).
Lemma divide_pos_neg_l n p : (Z.pos p|n) <-> (Z.neg p|n).
Lemma testbit_neg a n : 0<=n -> Z.testbit (Z.neg a) n = negb (N.testbit (Pos.pred_N a) (Z.to_N n)).
Lemma id x : 0 < x -> Z.pos (Z.to_pos x) = x.
Lemma inj x y : 0 < x -> 0 < y -> Z.to_pos x = Z.to_pos y -> x = y.
Lemma inj_iff x y : 0 < x -> 0 < y -> (Z.to_pos x = Z.to_pos y <-> x = y).
Lemma to_pos_nonpos x : x <= 0 -> Z.to_pos x = 1%positive.
Lemma inj_1 : Z.to_pos 1 = 1%positive.
Lemma inj_double x : 0 < x -> Z.to_pos (Z.double x) = (Z.to_pos x)~0%positive.
Lemma inj_succ_double x : 0 < x -> Z.to_pos (Z.succ_double x) = (Z.to_pos x)~1%positive.
Lemma inj_succ x : 0 < x -> Z.to_pos (Z.succ x) = Pos.succ (Z.to_pos x).
Lemma inj_add x y : 0 < x -> 0 < y -> Z.to_pos (x+y) = (Z.to_pos x + Z.to_pos y)%positive.
Lemma inj_sub x y : 0 < x < y -> Z.to_pos (y-x) = (Z.to_pos y - Z.to_pos x)%positive.
Lemma inj_pred x : 1 < x -> Z.to_pos (Z.pred x) = Pos.pred (Z.to_pos x).
Lemma inj_mul x y : 0 < x -> 0 < y -> Z.to_pos (x*y) = (Z.to_pos x * Z.to_pos y)%positive.
Lemma inj_pow x y : 0 < x -> 0 < y -> Z.to_pos (x^y) = (Z.to_pos x ^ Z.to_pos y)%positive.
Lemma inj_pow_pos x p : 0 < x -> Z.to_pos (Z.pow_pos x p) = ((Z.to_pos x)^p)%positive.
Lemma inj_compare x y : 0 < x -> 0 < y -> (x ?= y) = (Z.to_pos x ?= Z.to_pos y)%positive.
Lemma inj_leb x y : 0 < x -> 0 < y -> (x <=? y) = (Z.to_pos x <=? Z.to_pos y)%positive.
Lemma inj_ltb x y : 0 < x -> 0 < y -> (x <? y) = (Z.to_pos x <? Z.to_pos y)%positive.
Lemma inj_eqb x y : 0 < x -> 0 < y -> (x =? y) = (Z.to_pos x =? Z.to_pos y)%positive.
Lemma inj_max x y : Z.to_pos (Z.max x y) = Pos.max (Z.to_pos x) (Z.to_pos y).
Lemma inj_min x y : Z.to_pos (Z.min x y) = Pos.min (Z.to_pos x) (Z.to_pos y).
Lemma inj_sqrt x : Z.to_pos (Z.sqrt x) = Pos.sqrt (Z.to_pos x).
Lemma inj_gcd x y : 0 < x -> 0 < y -> Z.to_pos (Z.gcd x y) = Pos.gcd (Z.to_pos x) (Z.to_pos y).
Lemma Zplus_assoc_reverse : forall n m p, n+m+p = n+(m+p).
Lemma Zplus_succ_r_reverse : forall n m, Z.succ (n+m) = n+Z.succ m.
Lemma Zplus_0_r_reverse : forall n, n = n + 0.
Lemma Zplus_eq_compat : forall n m p q, n=m -> p=q -> n+p=m+q.
Lemma Zsucc_pred : forall n, n = Z.succ (Z.pred n).
Lemma Zpred_succ : forall n, n = Z.pred (Z.succ n).
Lemma Zsucc_eq_compat : forall n m, n = m -> Z.succ n = Z.succ m.
Lemma Zminus_0_l_reverse : forall n, n = n - 0.
Lemma Zminus_diag_reverse : forall n, 0 = n-n.
Lemma Zminus_succ_l : forall n m, Z.succ (n - m) = Z.succ n - m.
Lemma Zplus_minus_eq : forall n m p, n = m + p -> p = n - m.
Lemma Zplus_minus : forall n m, n + (m - n) = m.
Lemma Zminus_plus_simpl_l : forall n m p, p + n - (p + m) = n - m.
Lemma Zminus_plus_simpl_l_reverse : forall n m p, n - m = p + n - (p + m).
Lemma Zminus_plus_simpl_r : forall n m p, n + p - (m + p) = n - m.
Lemma Zeq_minus : forall n m, n = m -> n - m = 0.
Lemma Zminus_eq : forall n m, n - m = 0 -> n = m.
Lemma Zmult_0_r_reverse : forall n, 0 = n * 0.
Lemma Zmult_assoc_reverse : forall n m p, n * m * p = n * (m * p).
Lemma Zmult_integral : forall n m, n * m = 0 -> n = 0 \/ m = 0.
Lemma Zmult_integral_l : forall n m, n <> 0 -> m * n = 0 -> m = 0.
Lemma Zopp_mult_distr_l : forall n m, - (n * m) = - n * m.
Lemma Zopp_mult_distr_r : forall n m, - (n * m) = n * - m.
Lemma Zmult_minus_distr_l : forall n m p, p * (n - m) = p * n - p * m.
Lemma Zmult_succ_r_reverse : forall n m, n * m + n = n * Z.succ m.
Lemma Zmult_succ_l_reverse : forall n m, n * m + m = Z.succ n * m.
Lemma Zpos_eq : forall p q, p = q -> Z.pos p = Z.pos q.
Lemma Zpos_eq_iff : forall p q, p = q <-> Z.pos p = Z.pos q.
Lemma ZL0 : 2%nat = (1 + 1)%nat.
Lemma Zplus_diag_eq_mult_2 n : n + n = n * 2.
Lemma Z_eq_mult n m : m = 0 -> m * n = 0.
Lemma FstRel_ProdRel {A B}(RA:relation A) : relation_equivalence (RA @@1) (RA*(fun _ _ : B => True)).
Lemma SndRel_ProdRel {A B}(RB:relation B) : relation_equivalence (RB @@2) ((fun _ _ : A =>True) * RB).
Lemma incl_clos_trans : inclusion A R trans_clos.
Lemma Acc_clos_trans : forall x:A, Acc R x -> Acc trans_clos x.
Lemma Acc_inv_trans : forall x y:A, trans_clos y x -> Acc R x -> Acc R y.
Lemma left_prefix : forall x y z:List, ltl (x ++ y) z -> ltl x z.
Lemma right_prefix :   forall x y z:List,     ltl x (y ++ z) -> ltl x y \/ (exists y' : List, x = y ++ y' /\ ltl y' z).
Lemma desc_prefix : forall (x:List) (a:A), Descl (x ++ Cons a Nil) -> Descl x.
Lemma desc_tail :   forall (x:List) (a b:A),     Descl (Cons b (x ++ Cons a Nil)) -> clos_trans A leA a b.
Lemma dist_aux :   forall z:List, Descl z -> forall x y:List, z = x ++ y -> Descl x /\ Descl y.
Lemma dist_Desc_concat :   forall x y:List, Descl (x ++ y) -> Descl x /\ Descl y.
Lemma desc_end :   forall (a b:A) (x:List),     Descl (x ++ Cons a Nil) /\ ltl (x ++ Cons a Nil) (Cons b Nil) ->     clos_trans A leA a b.
Lemma ltl_unit :   forall (x:List) (a b:A),     Descl (x ++ Cons a Nil) ->     ltl (x ++ Cons a Nil) (Cons b Nil) -> ltl x (Cons b Nil).
Lemma acc_app :   forall (x1 x2:List) (y1:Descl (x1 ++ x2)),     Acc Lex_Exp << x1 ++ x2, y1 >> ->     forall (x:List) (y:Descl x), ltl x (x1 ++ x2) -> Acc Lex_Exp << x, y >>.
Lemma E1_cvg : forall x:R, Un_cv (E1 x) (exp x).
Lemma exp_form : forall (x y:R) (n:nat),   (0 < n)%nat -> E1 x n * E1 y n - Reste_E x y n = E1 (x + y) n.
Lemma div2_double : forall N:nat, div2 (2 * N) = N.
Lemma div2_S_double : forall N:nat, div2 (S (2 * N)) = N.
Lemma div2_not_R0 : forall N:nat, (1 < N)%nat -> (0 < div2 N)%nat.
Lemma Reste_E_maj : forall (x y:R) (N:nat),   (0 < N)%nat -> Rabs (Reste_E x y N) <= maj_Reste_E x y N.
Lemma maj_Reste_cv_R0 : forall x y:R, Un_cv (maj_Reste_E x y) 0.
Lemma Reste_E_cv : forall x y:R, Un_cv (Reste_E x y) 0.
Lemma exp_plus : forall x y:R, exp (x + y) = exp x * exp y.
Lemma exp_pos_pos : forall x:R, 0 < x -> 0 < exp x.
Lemma exp_pos : forall x:R, 0 < exp x.
Lemma derivable_pt_lim_exp_0 : derivable_pt_lim exp 0 1.
Lemma derivable_pt_lim_exp : forall x:R, derivable_pt_lim exp x (exp x).
Lemma prod_SO_split : forall (An:nat -> R) (n k:nat),   (k < n)%nat ->   prod_f_R0 An n =   prod_f_R0 An k * prod_f_R0 (fun l:nat => An (k +1+l)%nat) (n - k -1).
Lemma prod_SO_pos : forall (An:nat -> R) (N:nat),   (forall n:nat, (n <= N)%nat -> 0 <= An n) -> 0 <= prod_f_R0 An N.
Lemma prod_SO_Rle : forall (An Bn:nat -> R) (N:nat),   (forall n:nat, (n <= N)%nat -> 0 <= An n <= Bn n) ->   prod_f_R0 An N <= prod_f_R0 Bn N.
Lemma fact_prodSO : forall n:nat, INR (fact n) = prod_f_R0 (fun k:nat =>    (match (eq_nat_dec k 0) with         | left   _ => 1%R         | right _ => INR k                       end)) n.
Lemma le_n_2n : forall n:nat, (n <= 2 * n)%nat.
Lemma RfactN_fact2N_factk : forall N k:nat,   (k <= 2 * N)%nat ->   Rsqr (INR (fact N)) <= INR (fact (2 * N - k)) * INR (fact k).
Lemma INR_fact_lt_0 : forall n:nat, 0 < INR (fact n).
Lemma C_maj : forall N k:nat, (k <= 2 * N)%nat -> C (2 * N) k <= C (2 * N) N.
Lemma spec_ww_to_Z : forall x, 0 <= [[x]] < wwB.
Lemma spec_ww_to_Z_wBwB : forall x, 0 <= [[x]] < wB^2.
Lemma wBwB_lex: forall a b c d,     a * wB^2 + [[b]] <= c * wB^2 + [[d]] ->     a <= c.
Lemma wBwB_lex_inv: forall a b c d,     a < c ->     a * wB^2 + [[b]] < c * wB^2 + [[d]].
Lemma sum_mul_carry : forall xh xl yh yl wc cc,  [|wc|]*wB^2 + [[cc]] = [|xh|] * [|yl|] + [|xl|] * [|yh|] ->  0 <= [|wc|] <= 1.
Lemma spec_mul_aux : forall xh xl yh yl wc (cc:zn2z w) hh ll,  [[hh]] = [|xh|] * [|yh|] ->  [[ll]] = [|xl|] * [|yl|] ->  [|wc|]*wB^2 + [[cc]] = [|xh|] * [|yl|] + [|xl|] * [|yh|] ->   [||match cc with     | W0 => WW (ww_add hh (w_W0 wc)) ll     | WW cch ccl =>         match ww_add_c (w_W0 ccl) ll with         | C0 l => WW (ww_add hh (w_WW wc cch)) l         | C1 l => WW (ww_add_carry hh (w_WW wc cch)) l         end     end||] = ([|xh|] * wB + [|xl|]) * ([|yh|] * wB + [|yl|]).
Lemma spec_double_mul_c : forall cross:w->w->w->w->zn2z w -> zn2z w -> w*zn2z w,    (forall xh xl yh yl hh ll,       [[hh]] = [|xh|]*[|yh|] ->       [[ll]] = [|xl|]*[|yl|] ->       let (wc,cc) :=  cross xh xl yh yl hh ll in       [|wc|]*wwB + [[cc]] = [|xh|]*[|yl|] + [|xl|]*[|yh|]) ->    forall x y, [||double_mul_c cross x y||] = [[x]] * [[y]].
Lemma spec_ww_mul_c : forall x y, [||ww_mul_c x y||] = [[x]] * [[y]].
Lemma spec_w_2: [|w_2|] = 2.
Lemma kara_prod_aux : forall xh xl yh yl,  xh*yh + xl*yl - (xh-xl)*(yh-yl) = xh*yl + xl*yh.
Lemma spec_kara_prod : forall xh xl yh yl hh ll,  [[hh]] = [|xh|]*[|yh|] ->  [[ll]] = [|xl|]*[|yl|] ->  let (wc,cc) := kara_prod xh xl yh yl hh ll in  [|wc|]*wwB + [[cc]] = [|xh|]*[|yl|] + [|xl|]*[|yh|].
Lemma sub_carry : forall xh xl yh yl z,   0 <= z ->   [|xh|]*[|yl|] + [|xl|]*[|yh|] = wwB + z ->   z < wwB.
Lemma spec_ww_karatsuba_c : forall x y, [||ww_karatsuba_c x y||]=[[x]]*[[y]].
Lemma spec_ww_mul : forall x y, [[ww_mul x y]] = [[x]]*[[y]] mod wwB.
Lemma spec_ww_square_c : forall x, [||ww_square_c x||] = [[x]]*[[x]].
Lemma spec_double_mul_add_n1 : forall n x y r,    let (h,l) := double_mul_add_n1 w_mul_add n x y r in    [|h|]*double_wB w_digits n + [!n|l!] = [!n|x!]*[|y|]+[|r|].
Lemma spec_w_mul_add : forall x y r,   let (h,l):= w_mul_add x y r in   [|h|]*wB+[|l|] = [|x|]*[|y|] + [|r|].
Lemma CV_ALT_step0 : forall Un:nat -> R,   Un_decreasing Un ->   Un_growing (fun N:nat => sum_f_R0 (tg_alt Un) (S (2 * N))).
Lemma CV_ALT_step1 : forall Un:nat -> R,   Un_decreasing Un ->   Un_decreasing (fun N:nat => sum_f_R0 (tg_alt Un) (2 * N)).
Lemma CV_ALT_step2 : forall (Un:nat -> R) (N:nat),   Un_decreasing Un ->   positivity_seq Un ->   sum_f_R0 (fun i:nat => tg_alt Un (S i)) (S (2 * N)) <= 0.
Lemma CV_ALT_step3 : forall (Un:nat -> R) (N:nat),   Un_decreasing Un ->   positivity_seq Un -> sum_f_R0 (fun i:nat => tg_alt Un (S i)) N <= 0.
Lemma CV_ALT_step4 : forall Un:nat -> R,   Un_decreasing Un ->   positivity_seq Un ->   has_ub (fun N:nat => sum_f_R0 (tg_alt Un) (S (2 * N))).
Lemma CV_ALT : forall Un:nat -> R,   Un_decreasing Un ->   positivity_seq Un ->   Un_cv Un 0 ->   { l:R | Un_cv (fun N:nat => sum_f_R0 (tg_alt Un) N) l }.
Lemma PI_tg_pos : forall n:nat, 0 <= PI_tg n.
Lemma PI_tg_decreasing : Un_decreasing PI_tg.
Lemma PI_tg_cv : Un_cv PI_tg 0.
Lemma exist_PI : { l:R | Un_cv (fun N:nat => sum_f_R0 (tg_alt PI_tg) N) l }.
Lemma Alt_PI_ineq : forall N:nat,   sum_f_R0 (tg_alt PI_tg) (S (2 * N)) <= Alt_PI / 4 <=   sum_f_R0 (tg_alt PI_tg) (2 * N).
Lemma Alt_PI_RGT_0 : 0 < Alt_PI.
Lemma plus_comm : forall n m, n + m = m + n.
Lemma plus_assoc : forall n m p, n + (m + p) = n + m + p.
Lemma plus_permute : forall n m p, n + (m + p) = m + (n + p).
Lemma plus_assoc_reverse : forall n m p, n + m + p = n + (m + p).
Lemma plus_reg_l : forall n m p, p + n = p + m -> n = m.
Lemma plus_le_reg_l : forall n m p, p + n <= p + m -> n <= m.
Lemma plus_lt_reg_l : forall n m p, p + n < p + m -> n < m.
Lemma plus_le_compat_l : forall n m p, n <= m -> p + n <= p + m.
Lemma plus_le_compat_r : forall n m p, n <= m -> n + p <= m + p.
Lemma le_plus_l : forall n m, n <= n + m.
Lemma le_plus_r : forall n m, m <= n + m.
Lemma plus_lt_compat_l : forall n m p, n < m -> p + n < p + m.
Lemma plus_lt_compat_r : forall n m p, n < m -> n + p < m + p.
Lemma plus_le_compat : forall n m p q, n <= m -> p <= q -> n + p <= m + q.
Lemma plus_le_lt_compat : forall n m p q, n <= m -> p < q -> n + p < m + q.
Lemma plus_lt_le_compat : forall n m p q, n < m -> p <= q -> n + p < m + q.
Lemma plus_lt_compat : forall n m p q, n < m -> p < q -> n + p < m + q.
Lemma plus_is_O : forall n m, n + m = 0 -> n = 0 /\ m = 0.
Lemma plus_permute_2_in_4 : forall n m p q, n + m + (p + q) = n + p + (m + q).
Lemma plus_tail_plus : forall n m, n + m = tail_plus n m.
Lemma succ_plus_discr : forall n m, n <> S (plus m n).
Lemma n_SSn : forall n, n <> S (S n).
Lemma n_SSSn : forall n, n <> S (S (S n)).
Lemma n_SSSSn : forall n, n <> S (S (S (S n))).
Lemma tan_PI : tan PI = 0.
Lemma sin_3PI2 : sin (3 * (PI / 2)) = -1.
Lemma tan_2PI : tan (2 * PI) = 0.
Lemma sin_cos_PI4 : sin (PI / 4) = cos (PI / 4).
Lemma sin_PI3_cos_PI6 : sin (PI / 3) = cos (PI / 6).
Lemma sin_PI6_cos_PI3 : cos (PI / 3) = sin (PI / 6).
Lemma PI6_RGT_0 : 0 < PI / 6.
Lemma PI6_RLT_PI2 : PI / 6 < PI / 2.
Lemma sin_PI6 : sin (PI / 6) = 1 / 2.
Lemma sqrt2_neq_0 : sqrt 2 <> 0.
Lemma R1_sqrt2_neq_0 : 1 / sqrt 2 <> 0.
Lemma sqrt3_2_neq_0 : 2 * sqrt 3 <> 0.
Lemma Rlt_sqrt2_0 : 0 < sqrt 2.
Lemma Rlt_sqrt3_0 : 0 < sqrt 3.
Lemma PI4_RGT_0 : 0 < PI / 4.
Lemma cos_PI4 : cos (PI / 4) = 1 / sqrt 2.
Lemma sin_PI4 : sin (PI / 4) = 1 / sqrt 2.
Lemma tan_PI4 : tan (PI / 4) = 1.
Lemma cos3PI4 : cos (3 * (PI / 4)) = -1 / sqrt 2.
Lemma sin3PI4 : sin (3 * (PI / 4)) = 1 / sqrt 2.
Lemma cos_PI6 : cos (PI / 6) = sqrt 3 / 2.
Lemma tan_PI6 : tan (PI / 6) = 1 / sqrt 3.
Lemma sin_PI3 : sin (PI / 3) = sqrt 3 / 2.
Lemma cos_PI3 : cos (PI / 3) = 1 / 2.
Lemma tan_PI3 : tan (PI / 3) = sqrt 3.
Lemma sin_2PI3 : sin (2 * (PI / 3)) = sqrt 3 / 2.
Lemma cos_2PI3 : cos (2 * (PI / 3)) = -1 / 2.
Lemma tan_2PI3 : tan (2 * (PI / 3)) = - sqrt 3.
Lemma cos_5PI4 : cos (5 * (PI / 4)) = -1 / sqrt 2.
Lemma sin_5PI4 : sin (5 * (PI / 4)) = -1 / sqrt 2.
Lemma sin_cos5PI4 : cos (5 * (PI / 4)) = sin (5 * (PI / 4)).
Lemma Rgt_3PI2_0 : 0 < 3 * (PI / 2).
Lemma Rgt_2PI_0 : 0 < 2 * PI.
Lemma Rlt_PI_3PI2 : PI < 3 * (PI / 2).
Lemma Rlt_3PI2_2PI : 3 * (PI / 2) < 2 * PI.
Lemma rad_deg : forall x:R, toRad (toDeg x) = x.
Lemma toRad_inj : forall x y:R, toRad x = toRad y -> x = y.
Lemma deg_rad : forall x:R, toDeg (toRad x) = x.
Lemma Rsqr_sin_cos_d_one : forall x:R, Rsqr (sind x) + Rsqr (cosd x) = 1.
Lemma sin_lb_ge_0 : forall a:R, 0 <= a -> a <= PI / 2 -> 0 <= sin_lb a.
Lemma Extension : forall B C:Ensemble U, B = C -> Same_set U B C.
Lemma Noone_in_empty : forall x:U, ~ In U (Empty_set U) x.
Lemma Included_Empty : forall A:Ensemble U, Included U (Empty_set U) A.
Lemma Add_intro1 :   forall (A:Ensemble U) (x y:U), In U A y -> In U (Add U A x) y.
Lemma Add_intro2 : forall (A:Ensemble U) (x:U), In U (Add U A x) x.
Lemma Inhabited_add : forall (A:Ensemble U) (x:U), Inhabited U (Add U A x).
Lemma Inhabited_not_empty :   forall X:Ensemble U, Inhabited U X -> X <> Empty_set U.
Lemma Add_not_Empty : forall (A:Ensemble U) (x:U), Add U A x <> Empty_set U.
Lemma not_Empty_Add : forall (A:Ensemble U) (x:U), Empty_set U <> Add U A x.
Lemma Singleton_inv : forall x y:U, In U (Singleton U x) y -> x = y.
Lemma Singleton_intro : forall x y:U, x = y -> In U (Singleton U x) y.
Lemma Union_inv :   forall (B C:Ensemble U) (x:U), In U (Union U B C) x -> In U B x \/ In U C x.
Lemma Add_inv :   forall (A:Ensemble U) (x y:U), In U (Add U A x) y -> In U A y \/ x = y.
Lemma Intersection_inv :   forall (B C:Ensemble U) (x:U),     In U (Intersection U B C) x -> In U B x /\ In U C x.
Lemma Couple_inv : forall x y z:U, In U (Couple U x y) z -> z = x \/ z = y.
Lemma Setminus_intro :   forall (A B:Ensemble U) (x:U),     In U A x -> ~ In U B x -> In U (Setminus U A B) x.
Lemma Strict_Included_intro :   forall X Y:Ensemble U, Included U X Y /\ X <> Y -> Strict_Included U X Y.
Lemma Strict_Included_strict : forall X:Ensemble U, ~ Strict_Included U X X.
Lemma leb_refl : forall b:bool, leb b b.
Lemma incl_left : forall s1 s2:uniset, seq s1 s2 -> incl s1 s2.
Lemma incl_right : forall s1 s2:uniset, seq s1 s2 -> incl s2 s1.
Lemma seq_refl : forall x:uniset, seq x x.
Lemma seq_trans : forall x y z:uniset, seq x y -> seq y z -> seq x z.
Lemma seq_sym : forall x y:uniset, seq x y -> seq y x.
Lemma union_empty_left : forall x:uniset, seq x (union Emptyset x).
Lemma union_empty_right : forall x:uniset, seq x (union x Emptyset).
Lemma union_comm : forall x y:uniset, seq (union x y) (union y x).
Lemma union_ass : forall x y z:uniset, seq (union (union x y) z) (union x (union y z)).
Lemma seq_left : forall x y z:uniset, seq x y -> seq (union x z) (union y z).
Lemma seq_right : forall x y z:uniset, seq x y -> seq (union z x) (union z y).
Lemma union_rotate : forall x y z:uniset, seq (union x (union y z)) (union z (union x y)).
Lemma seq_congr : forall x y z t:uniset, seq x y -> seq z t -> seq (union x z) (union y t).
Lemma union_perm_left : forall x y z:uniset, seq (union x (union y z)) (union y (union x z)).
Lemma uniset_twist1 : forall x y z t:uniset,  seq (union x (union (union y z) t)) (union (union y (union x t)) z).
Lemma uniset_twist2 : forall x y z t:uniset,  seq (union x (union (union y z) t)) (union (union y (union x z)) t).
Lemma treesort_twist1 : forall x y z t u:uniset,  seq u (union y z) ->  seq (union x (union u t)) (union (union y (union x t)) z).
Lemma treesort_twist2 : forall x y z t u:uniset,  seq u (union y z) ->  seq (union x (union u t)) (union (union y (union x z)) t).
Lemma Qopp_lt_compat: forall p q : Q, p < q -> - q < - p.
Lemma Qfloor_Z : forall z:Z, Qfloor z = z.
Lemma Qceiling_Z : forall z:Z, Qceiling z = z.
Lemma Qfloor_le : forall x, Qfloor x <= x.
Lemma Qle_ceiling : forall x, x <= Qceiling x.
Lemma Qle_floor_ceiling : forall x, Qfloor x <= Qceiling x.
Lemma Qlt_floor : forall x, x < (Qfloor x+1)%Z.
Lemma Qceiling_lt : forall x, (Qceiling x-1)%Z < x.
Lemma Qfloor_resp_le : forall x y, x <= y -> (Qfloor x <= Qfloor y)%Z.
Lemma Qceiling_resp_le : forall x y, x <= y -> (Qceiling x <= Qceiling y)%Z.
Lemma Zdiv_Qdiv (n m: Z): (n / m)%Z = Qfloor (n / m).
Lemma IZN_var : forall z:Z, (0 <= z)%Z -> {n : nat | z = Z.of_nat n}.
Lemma Nzorn : forall I:nat -> Prop,   (exists n : nat, I n) ->   Nbound I -> { n:nat | I n /\ (forall i:nat, I i -> (i <= n)%nat) }.
Lemma StepFun_P1 : forall (a b:R) (f:StepFun a b),   adapted_couple f a b (subdivision f) (subdivision_val f).
Lemma StepFun_P2 : forall (a b:R) (f:R -> R) (l lf:Rlist),   adapted_couple f a b l lf -> adapted_couple f b a l lf.
Lemma StepFun_P3 : forall a b c:R,   a <= b ->   adapted_couple (fct_cte c) a b (cons a (cons b nil)) (cons c nil).
Lemma StepFun_P4 : forall a b c:R, IsStepFun (fct_cte c) a b.
Lemma StepFun_P5 : forall (a b:R) (f:R -> R) (l:Rlist),   is_subdivision f a b l -> is_subdivision f b a l.
Lemma StepFun_P6 : forall (f:R -> R) (a b:R), IsStepFun f a b -> IsStepFun f b a.
Lemma StepFun_P7 : forall (a b r1 r2 r3:R) (f:R -> R) (l lf:Rlist),   a <= b ->   adapted_couple f a b (cons r1 (cons r2 l)) (cons r3 lf) ->   adapted_couple f r2 b (cons r2 l) lf.
Lemma StepFun_P8 : forall (f:R -> R) (l1 lf1:Rlist) (a b:R),   adapted_couple f a b l1 lf1 -> a = b -> Int_SF lf1 l1 = 0.
Lemma StepFun_P9 : forall (a b:R) (f:R -> R) (l lf:Rlist),   adapted_couple f a b l lf -> a <> b -> (2 <= Rlength l)%nat.
Lemma StepFun_P10 : forall (f:R -> R) (l lf:Rlist) (a b:R),   a <= b ->   adapted_couple f a b l lf ->   exists l' : Rlist,     (exists lf' : Rlist, adapted_couple_opt f a b l' lf').
Lemma StepFun_P11 : forall (a b r r1 r3 s1 s2 r4:R) (r2 lf1 s3 lf2:Rlist)   (f:R -> R),   a < b ->   adapted_couple f a b (cons r (cons r1 r2)) (cons r3 lf1) ->   adapted_couple_opt f a b (cons s1 (cons s2 s3)) (cons r4 lf2) -> r1 <= s2.
Lemma StepFun_P12 : forall (a b:R) (f:R -> R) (l lf:Rlist),   adapted_couple_opt f a b l lf -> adapted_couple_opt f b a l lf.
Lemma StepFun_P13 : forall (a b r r1 r3 s1 s2 r4:R) (r2 lf1 s3 lf2:Rlist)   (f:R -> R),   a <> b ->   adapted_couple f a b (cons r (cons r1 r2)) (cons r3 lf1) ->   adapted_couple_opt f a b (cons s1 (cons s2 s3)) (cons r4 lf2) -> r1 <= s2.
Lemma StepFun_P14 : forall (f:R -> R) (l1 l2 lf1 lf2:Rlist) (a b:R),   a <= b ->   adapted_couple f a b l1 lf1 ->   adapted_couple_opt f a b l2 lf2 -> Int_SF lf1 l1 = Int_SF lf2 l2.
Lemma StepFun_P15 : forall (f:R -> R) (l1 l2 lf1 lf2:Rlist) (a b:R),   adapted_couple f a b l1 lf1 ->   adapted_couple_opt f a b l2 lf2 -> Int_SF lf1 l1 = Int_SF lf2 l2.
Lemma StepFun_P16 : forall (f:R -> R) (l lf:Rlist) (a b:R),   adapted_couple f a b l lf ->   exists l' : Rlist,     (exists lf' : Rlist, adapted_couple_opt f a b l' lf').
Lemma StepFun_P17 : forall (f:R -> R) (l1 l2 lf1 lf2:Rlist) (a b:R),   adapted_couple f a b l1 lf1 ->   adapted_couple f a b l2 lf2 -> Int_SF lf1 l1 = Int_SF lf2 l2.
Lemma StepFun_P18 : forall a b c:R, RiemannInt_SF (mkStepFun (StepFun_P4 a b c)) = c * (b - a).
Lemma StepFun_P19 : forall (l1:Rlist) (f g:R -> R) (l:R),   Int_SF (FF l1 (fun x:R => f x + l * g x)) l1 =   Int_SF (FF l1 f) l1 + l * Int_SF (FF l1 g) l1.
Lemma StepFun_P20 : forall (l:Rlist) (f:R -> R),   (0 < Rlength l)%nat -> Rlength l = S (Rlength (FF l f)).
Lemma StepFun_P21 : forall (a b:R) (f:R -> R) (l:Rlist),   is_subdivision f a b l -> adapted_couple f a b l (FF l f).
Lemma StepFun_P22 : forall (a b:R) (f g:R -> R) (lf lg:Rlist),   a <= b ->   is_subdivision f a b lf ->   is_subdivision g a b lg -> is_subdivision f a b (cons_ORlist lf lg).
Lemma StepFun_P23 : forall (a b:R) (f g:R -> R) (lf lg:Rlist),   is_subdivision f a b lf ->   is_subdivision g a b lg -> is_subdivision f a b (cons_ORlist lf lg).
Lemma StepFun_P24 : forall (a b:R) (f g:R -> R) (lf lg:Rlist),   a <= b ->   is_subdivision f a b lf ->   is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg).
Lemma StepFun_P25 : forall (a b:R) (f g:R -> R) (lf lg:Rlist),   is_subdivision f a b lf ->   is_subdivision g a b lg -> is_subdivision g a b (cons_ORlist lf lg).
Lemma StepFun_P26 : forall (a b l:R) (f g:R -> R) (l1:Rlist),   is_subdivision f a b l1 ->   is_subdivision g a b l1 ->   is_subdivision (fun x:R => f x + l * g x) a b l1.
Lemma StepFun_P27 : forall (a b l:R) (f g:R -> R) (lf lg:Rlist),   is_subdivision f a b lf ->   is_subdivision g a b lg ->   is_subdivision (fun x:R => f x + l * g x) a b (cons_ORlist lf lg).
Lemma StepFun_P28 : forall (a b l:R) (f g:StepFun a b), IsStepFun (fun x:R => f x + l * g x) a b.
Lemma StepFun_P29 : forall (a b:R) (f:StepFun a b), is_subdivision f a b (subdivision f).
Lemma StepFun_P30 : forall (a b l:R) (f g:StepFun a b),   RiemannInt_SF (mkStepFun (StepFun_P28 l f g)) =   RiemannInt_SF f + l * RiemannInt_SF g.
Lemma StepFun_P31 : forall (a b:R) (f:R -> R) (l lf:Rlist),   adapted_couple f a b l lf ->   adapted_couple (fun x:R => Rabs (f x)) a b l (app_Rlist lf Rabs).
Lemma StepFun_P32 : forall (a b:R) (f:StepFun a b), IsStepFun (fun x:R => Rabs (f x)) a b.
Lemma StepFun_P33 : forall l2 l1:Rlist,   ordered_Rlist l1 -> Rabs (Int_SF l2 l1) <= Int_SF (app_Rlist l2 Rabs) l1.
Lemma StepFun_P34 : forall (a b:R) (f:StepFun a b),   a <= b ->   Rabs (RiemannInt_SF f) <= RiemannInt_SF (mkStepFun (StepFun_P32 f)).
Lemma StepFun_P35 : forall (l:Rlist) (a b:R) (f g:R -> R),   ordered_Rlist l ->   pos_Rl l 0 = a ->   pos_Rl l (pred (Rlength l)) = b ->   (forall x:R, a < x < b -> f x <= g x) ->   Int_SF (FF l f) l <= Int_SF (FF l g) l.
Lemma StepFun_P36 : forall (a b:R) (f g:StepFun a b) (l:Rlist),   a <= b ->   is_subdivision f a b l ->   is_subdivision g a b l ->   (forall x:R, a < x < b -> f x <= g x) ->   RiemannInt_SF f <= RiemannInt_SF g.
Lemma StepFun_P37 : forall (a b:R) (f g:StepFun a b),   a <= b ->   (forall x:R, a < x < b -> f x <= g x) ->   RiemannInt_SF f <= RiemannInt_SF g.
Lemma StepFun_P38 : forall (l:Rlist) (a b:R) (f:R -> R),   ordered_Rlist l ->   pos_Rl l 0 = a ->   pos_Rl l (pred (Rlength l)) = b ->   { g:StepFun a b |     g b = f b /\     (forall i:nat,       (i < pred (Rlength l))%nat ->       constant_D_eq g (co_interval (pos_Rl l i) (pos_Rl l (S i)))       (f (pos_Rl l i))) }.
Lemma StepFun_P39 : forall (a b:R) (f:StepFun a b),   RiemannInt_SF f = - RiemannInt_SF (mkStepFun (StepFun_P6 (pre f))).
Lemma StepFun_P40 : forall (f:R -> R) (a b c:R) (l1 l2 lf1 lf2:Rlist),   a < b ->   b < c ->   adapted_couple f a b l1 lf1 ->   adapted_couple f b c l2 lf2 ->   adapted_couple f a c (cons_Rlist l1 l2) (FF (cons_Rlist l1 l2) f).
Lemma StepFun_P41 : forall (f:R -> R) (a b c:R),   a <= b -> b <= c -> IsStepFun f a b -> IsStepFun f b c -> IsStepFun f a c.
Lemma StepFun_P42 : forall (l1 l2:Rlist) (f:R -> R),   pos_Rl l1 (pred (Rlength l1)) = pos_Rl l2 0 ->   Int_SF (FF (cons_Rlist l1 l2) f) (cons_Rlist l1 l2) =   Int_SF (FF l1 f) l1 + Int_SF (FF l2 f) l2.
Lemma StepFun_P43 : forall (f:R -> R) (a b c:R) (pr1:IsStepFun f a b)   (pr2:IsStepFun f b c) (pr3:IsStepFun f a c),   RiemannInt_SF (mkStepFun pr1) + RiemannInt_SF (mkStepFun pr2) =   RiemannInt_SF (mkStepFun pr3).
Lemma StepFun_P44 : forall (f:R -> R) (a b c:R),   IsStepFun f a b -> a <= c <= b -> IsStepFun f a c.
Lemma StepFun_P45 : forall (f:R -> R) (a b c:R),   IsStepFun f a b -> a <= c <= b -> IsStepFun f c b.
Lemma StepFun_P46 : forall (f:R -> R) (a b c:R),   IsStepFun f a b -> IsStepFun f b c -> IsStepFun f a c.
Lemma constructive_definite_description : forall (A : Type) (P : A->Prop),   (exists! x, P x) -> { x : A | P x }.
Lemma epsilon_inh_irrelevance :  forall (A:Type) (i j : inhabited A) (P:A->Prop),  (exists x, P x) -> epsilon i P = epsilon j P.
Lemma Psize_log_inf : forall p, Zpos (Pos.size p) = Z.succ (log_inf p).
Lemma Zlog2_log_inf : forall p, Z.log2 (Zpos p) = log_inf p.
Lemma Zlog2_up_log_sup : forall p, Z.log2_up (Zpos p) = log_sup p.
Lemma log_sup_correct1 : forall p:positive, 0 <= log_sup p.
Lemma log_inf_le_log_sup : forall p:positive, log_inf p <= log_sup p.
Lemma log_sup_le_Slog_inf : forall p:positive, log_sup p <= Z.succ (log_inf p).
Lemma ZERO_le_N_digits : forall x:Z, 0 <= N_digits x.
Lemma log_inf_shift_nat : forall n:nat, log_inf (shift_nat n 1) = Z.of_nat n.
Lemma log_sup_shift_nat : forall n:nat, log_sup (shift_nat n 1) = Z.of_nat n.
Lemma Is_power_correct :   forall p:positive, Is_power p <-> (exists y : nat, p = shift_nat y 1).
Lemma Is_power_or : forall p:positive, Is_power p \/ ~ Is_power p.
Lemma trunc : forall {A} {n} (p:nat), n > p -> t A n -> t A (n - p).
Lemma iff_and : forall A B : Prop, (A <-> B) -> (A -> B) /\ (B -> A).
Lemma iff_to_and : forall A B : Prop, (A <-> B) <-> (A -> B) /\ (B -> A).
Lemma unique_existence : forall (A:Type) (P:A->Prop), ((exists x, P x) /\ uniqueness P) <-> (exists! x, P x).
Lemma forall_exists_unique_domain_coincide : forall A (P:A->Prop), (exists! x, P x) -> forall Q:A->Prop, (forall x, P x -> Q x) <-> (exists x, P x /\ Q x).
Lemma forall_exists_coincide_unique_domain : forall A (P:A->Prop), (forall Q:A->Prop, (forall x, P x -> Q x) <-> (exists x, P x /\ Q x)) -> (exists! x, P x).
Lemma exists_inhabited : forall (A:Type) (P:A->Prop), (exists x, P x) -> inhabited A.
Lemma eq_stepl : forall (A : Type) (x y z : A), x = y -> x = z -> z = y.
Lemma iff_stepl : forall A B C : Prop, (A <-> B) -> (A <-> C) -> (C <-> B).
Lemma spec_ww_add_mul_div : forall x y p,      [|p|] <= Zpos _ww_digits ->      [| add_mul_div p x y |] =        ([|x|] * (2 ^ [|p|]) +         [|y|] / (2 ^ ((Zpos _ww_digits) - [|p|]))) mod wwB.
Lemma spec_mul_add: forall x y z,    let (zh, zl) := mul_add x y z in [||WW zh zl||] = [|x|] * [|y|] + [|z|].
Lemma BigZring : ring_theory 0 1 BigZ.add BigZ.mul BigZ.sub BigZ.opp BigZ.eq.
Lemma BigZeqb_correct : forall x y, (x =? y) = true -> x==y.
Lemma BigZpower : power_theory 1 BigZ.mul BigZ.eq BigZ_of_N BigZ.pow.
Lemma BigZdiv : div_theory BigZ.eq BigZ.add BigZ.mul (@id _)
Lemma divide_opp_l : forall n m, (-n | m) <-> (n | m).
Lemma divide_opp_r : forall n m, (n | -m) <-> (n | m).
Lemma divide_abs_l : forall n m, (abs n | m) <-> (n | m).
Lemma divide_abs_r : forall n m, (n | abs m) <-> (n | m).
Lemma divide_1_r_abs : forall n, (n | 1) -> abs n == 1.
Lemma divide_1_r : forall n, (n | 1) -> n==1 \/ n==-1.
Lemma divide_antisym_abs : forall n m, (n | m) -> (m | n) -> abs n == abs m.
Lemma divide_antisym : forall n m, (n | m) -> (m | n) -> n == m \/ n == -m.
Lemma divide_sub_r : forall n m p, (n | m) -> (n | p) -> (n | m - p).
Lemma divide_add_cancel_r : forall n m p, (n | m) -> (n | m + p) -> (n | p).
Lemma gcd_opp_l : forall n m, gcd (-n) m == gcd n m.
Lemma gcd_opp_r : forall n m, gcd n (-m) == gcd n m.
Lemma gcd_abs_l : forall n m, gcd (abs n) m == gcd n m.
Lemma gcd_abs_r : forall n m, gcd n (abs m) == gcd n m.
Lemma gcd_0_l : forall n, gcd 0 n == abs n.
Lemma gcd_0_r : forall n, gcd n 0 == abs n.
Lemma gcd_diag : forall n, gcd n n == abs n.
Lemma gcd_add_mult_diag_r : forall n m p, gcd n (m+p*n) == gcd n m.
Lemma gcd_add_diag_r : forall n m, gcd n (m+n) == gcd n m.
Lemma gcd_sub_diag_r : forall n m, gcd n (m-n) == gcd n m.
Lemma bezout_1_gcd : forall n m, Bezout n m 1 -> gcd n m == 1.
Lemma gcd_bezout : forall n m p, gcd n m == p -> Bezout n m p.
Lemma gcd_mul_mono_l : forall n m p, gcd (p * n) (p * m) == abs p * gcd n m.
Lemma gcd_mul_mono_l_nonneg : forall n m p, 0<=p -> gcd (p*n) (p*m) == p * gcd n m.
Lemma gcd_mul_mono_r : forall n m p, gcd (n * p) (m * p) == gcd n m * abs p.
Lemma gcd_mul_mono_r_nonneg : forall n m p, 0<=p -> gcd (n*p) (m*p) == gcd n m * p.
Lemma gauss : forall n m p, (n | m * p) -> gcd n m == 1 -> (n | p).
Lemma divide_mul_split : forall n m p, n ~= 0 -> (n | m * p) -> exists q r, n == q*r /\ (q | m) /\ (r | p).
Lemma spec_ww_pos_mod : forall w p,      [[ww_pos_mod p w]] = [[w]] mod (2 ^ [[p]]).
Lemma Zmult_lt_0_reg_r_2 : forall n m : Z, 0 <= n -> 0 < m * n -> 0 < m.
Lemma to_Z_div_minus_p : forall x p,  0 < [|p|] < Zpos w_digits  ->  0 <= [|x|] / 2 ^ (Zpos w_digits - [|p|]) < 2 ^ [|p|].
Lemma spec_ww_div_gt_aux : forall ah al bh bl,     [[WW ah al]] > [[WW bh bl]] ->     0 < [|bh|] ->     let (q,r) := ww_div_gt_aux ah al bh bl in     [[WW ah al]] = [[q]] * [[WW bh bl]] + [[r]] /\     0 <= [[r]] < [[WW bh bl]].
Lemma spec_ww_div_gt : forall a b, [[a]] > [[b]] -> 0 < [[b]] ->     let (q,r) := ww_div_gt a b in     [[a]] = [[q]] * [[b]] + [[r]] /\     0 <= [[r]] < [[b]].
Lemma spec_ww_mod_gt_aux_eq : forall ah al bh bl,  ww_mod_gt_aux ah al bh bl = snd (ww_div_gt_aux ah al bh bl).
Lemma spec_ww_mod_gt_aux : forall ah al bh bl,  [[WW ah al]] > [[WW bh bl]] ->   0 < [|bh|] ->   [[ww_mod_gt_aux ah al bh bl]] = [[WW ah al]] mod [[WW bh bl]].
Lemma spec_w_mod_gt_eq : forall a b, [|a|] > [|b|] -> 0 <[|b|] ->   [|w_mod_gt a b|] = [|snd (w_div_gt a b)|].
Lemma spec_ww_mod_gt_eq : forall a b, [[a]] > [[b]] -> 0 < [[b]] ->     [[ww_mod_gt a b]] = [[snd (ww_div_gt a b)]].
Lemma spec_ww_mod_gt : forall a b, [[a]] > [[b]] -> 0 < [[b]] ->     [[ww_mod_gt a b]] = [[a]] mod [[b]].
Lemma Zis_gcd_mod : forall a b d,  0 < b -> Zis_gcd b (a mod b) d -> Zis_gcd a b d.
Lemma spec_ww_gcd_gt_aux_body :  forall ah al bh bl n cont,   [[WW bh bl]] <= 2^n ->   [[WW ah al]] > [[WW bh bl]] ->   (forall xh xl yh yl,    [[WW xh xl]] > [[WW yh yl]] -> [[WW yh yl]] <= 2^(n-1) ->    Zis_gcd [[WW xh xl]] [[WW yh yl]] [[cont xh xl yh yl]]) ->   Zis_gcd [[WW ah al]] [[WW bh bl]] [[ww_gcd_gt_body cont ah al bh bl]].
Lemma spec_ww_gcd_gt_aux :  forall p cont n,  (forall xh xl yh yl,    [[WW xh xl]] > [[WW yh yl]] ->    [[WW yh yl]] <= 2^n ->     Zis_gcd [[WW xh xl]] [[WW yh yl]] [[cont xh xl yh yl]]) ->  forall ah al bh bl , [[WW ah al]] > [[WW bh bl]] ->    [[WW bh bl]] <= 2^(Zpos p + n) ->    Zis_gcd [[WW ah al]] [[WW bh bl]]       [[ww_gcd_gt_aux p cont ah al bh bl]].
Lemma spec_ww_div : forall a b, 0 < [[b]] ->     let (q,r) := ww_div a b in     [[a]] = [[q]] * [[b]] + [[r]] /\     0 <= [[r]] < [[b]].
Lemma  spec_ww_mod :  forall a b, 0 < [[b]] ->     [[ww_mod a b]] = [[a]] mod [[b]].
Lemma spec_gcd_cont : forall xh xl yh yl,    [[WW xh xl]] > [[WW yh yl]] ->    [[WW yh yl]] <= 1 ->     Zis_gcd [[WW xh xl]] [[WW yh yl]] [[gcd_cont xh xl yh yl]].
Lemma spec_ww_gcd_gt : forall a b, [[a]] > [[b]] ->     Zis_gcd [[a]] [[b]] [[ww_gcd_gt a b]].
Lemma spec_ww_gcd : forall a b, Zis_gcd [[a]] [[b]] [[ww_gcd a b]].
Lemma ltb_tree_iff : forall x s, lt_tree x s <-> ltb_tree x s = true.
Lemma gtb_tree_iff : forall x s, gt_tree x s <-> gtb_tree x s = true.
Lemma isok_iff : forall s, Ok s <-> isok s = true.
Lemma In_1 : forall s x y, X.eq x y -> InT x s -> InT y s.
Lemma In_node_iff : forall c l x r y, InT y (Node c l x r) <-> InT y l \/ X.eq y x \/ InT y r.
Lemma In_leaf_iff : forall x, InT x Leaf <-> False.
Lemma lt_leaf : forall x : elt, lt_tree x Leaf.
Lemma gt_leaf : forall x : elt, gt_tree x Leaf.
Lemma lt_tree_node : forall (x y : elt) (l r : tree) (i : Info.t),
Lemma gt_tree_node : forall (x y : elt) (l r : tree) (i : Info.t),
Lemma lt_tree_not_in : forall (x : elt) (t : tree), lt_tree x t -> ~ InT x t.
Lemma lt_tree_trans : forall x y, X.lt x y -> forall t, lt_tree x t -> lt_tree y t.
Lemma gt_tree_not_in : forall (x : elt) (t : tree), gt_tree x t -> ~ InT x t.
Lemma gt_tree_trans : forall x y, X.lt y x -> forall t, gt_tree x t -> gt_tree y t.
Lemma empty_spec : Empty empty.
Lemma is_empty_spec : forall s, is_empty s = true <-> Empty s.
Lemma mem_spec : forall s x `{Ok s}, mem x s = true <-> InT x s.
Lemma min_elt_spec1 s x : min_elt s = Some x -> InT x s.
Lemma min_elt_spec2 s x y `{Ok s} : min_elt s = Some x -> InT y s -> ~ X.lt y x.
Lemma min_elt_spec3 s : min_elt s = None -> Empty s.
Lemma max_elt_spec1 s x : max_elt s = Some x -> InT x s.
Lemma max_elt_spec2 s x y `{Ok s} : max_elt s = Some x -> InT y s -> ~ X.lt x y.
Lemma max_elt_spec3 s : max_elt s = None -> Empty s.
Lemma choose_spec1 : forall s x, choose s = Some x -> InT x s.
Lemma choose_spec2 : forall s, choose s = None -> Empty s.
Lemma choose_spec3 : forall s s' x x' `{Ok s, Ok s'}, choose s = Some x -> choose s' = Some x' -> Equal s s' -> X.eq x x'.
Lemma elements_spec1' : forall s acc x, InA X.eq x (elements_aux acc s) <-> InT x s \/ InA X.eq x acc.
Lemma elements_spec1 : forall s x, InA X.eq x (elements s) <-> InT x s.
Lemma elements_spec2' : forall s acc `{Ok s}, sort X.lt acc ->
Lemma elements_spec2 : forall s `(Ok s), sort X.lt (elements s).
Lemma elements_spec2w : forall s `(Ok s), NoDupA X.eq (elements s).
Lemma elements_aux_cardinal : forall s acc, (length acc + cardinal s)%nat = length (elements_aux acc s).
Lemma elements_cardinal : forall s : tree, cardinal s = length (elements s).
Lemma elements_app : forall s acc, elements_aux acc s = elements s ++ acc.
Lemma elements_node c l x r : elements (Node c l x r) = elements l ++ x :: elements r.
Lemma rev_elements_app : forall s acc, rev_elements_aux acc s = rev_elements s ++ acc.
Lemma rev_elements_node c l x r : rev_elements (Node c l x r) = rev_elements r ++ x :: rev_elements l.
Lemma rev_elements_rev s : rev_elements s = rev (elements s).
Lemma sorted_app_inv l1 l2 : sort X.lt (l1++l2) ->
Lemma elements_sort_ok s : sort X.lt (elements s) -> Ok s.
Lemma for_all_spec s f : Proper (X.eq==>eq) f ->
Lemma exists_spec s f : Proper (X.eq==>eq) f ->
Lemma fold_spec' {A} (f : elt -> A -> A) (s : tree) (i : A) (acc : list elt) : fold_left (flip f) (elements_aux acc s) i = fold_left (flip f) acc (fold f s i).
Lemma fold_spec (s:tree) {A} (i : A) (f : elt -> A -> A) : fold f s i = fold_left (flip f) (elements s) i.
Lemma subsetl_spec : forall subset_l1 l1 x1 c1 s2 `{Ok (Node c1 l1 x1 Leaf), Ok s2}, (forall s `{Ok s}, (subset_l1 s = true <-> Subset l1 s)) -> (subsetl subset_l1 x1 s2 = true <-> Subset (Node c1 l1 x1 Leaf) s2 ).
Lemma subsetr_spec : forall subset_r1 r1 x1 c1 s2, bst (Node c1 Leaf x1 r1) -> bst s2 -> (forall s, bst s -> (subset_r1 s = true <-> Subset r1 s)) -> (subsetr subset_r1 x1 s2 = true <-> Subset (Node c1 Leaf x1 r1) s2).
Lemma subset_spec : forall s1 s2 `{Ok s1, Ok s2}, (subset s1 s2 = true <-> Subset s1 s2).
Lemma eq_Leq : forall s s', eq s s' <-> L.eq (elements s) (elements s').
Lemma flatten_e_elements : forall l x r c e, elements l ++ flatten_e (More x r e) = elements (Node c l x r) ++ flatten_e e.
Lemma cons_1 : forall s e, flatten_e (cons s e) = elements s ++ flatten_e e.
Lemma compare_end_Cmp : forall e2, Cmp (compare_end e2) nil (flatten_e e2).
Lemma compare_more_Cmp : forall x1 cont x2 r2 e2 l, Cmp (cont (cons r2 e2)) l (elements r2 ++ flatten_e e2) ->  Cmp (compare_more x1 cont (More x2 r2 e2)) (x1::l)     (flatten_e (More x2 r2 e2)).
Lemma compare_cont_Cmp : forall s1 cont e2 l, (forall e, Cmp (cont e) l (flatten_e e)) -> Cmp (compare_cont s1 cont e2) (elements s1 ++ l) (flatten_e e2).
Lemma compare_Cmp : forall s1 s2, Cmp (compare s1 s2) (elements s1) (elements s2).
Lemma compare_spec : forall s1 s2 `{Ok s1, Ok s2}, CompSpec eq lt s1 s2 (compare s1 s2).
Lemma equal_spec : forall s1 s2 `{Ok s1, Ok s2}, equal s1 s2 = true <-> eq s1 s2.
Lemma mindepth_maxdepth s : mindepth s <= maxdepth s.
Lemma maxdepth_cardinal s : cardinal s < 2^(maxdepth s).
Lemma mindepth_cardinal s : 2^(mindepth s) <= S (cardinal s).
Lemma maxdepth_log_cardinal s : s <> Leaf -> log2 (cardinal s) < maxdepth s.
Lemma mindepth_log_cardinal s : mindepth s <= log2 (S (cardinal s)).
Lemma mem_eq: E.eq x y -> mem x s=mem y s.
Lemma equal_mem_1: (forall a, mem a s=mem a s') -> equal s s'=true.
Lemma equal_mem_2: equal s s'=true -> forall a, mem a s=mem a s'.
Lemma subset_mem_1: (forall a, mem a s=true->mem a s'=true) -> subset s s'=true.
Lemma subset_mem_2: subset s s'=true -> forall a, mem a s=true -> mem a s'=true.
Lemma empty_mem: mem x empty=false.
Lemma is_empty_equal_empty: is_empty s = equal s empty.
Lemma choose_mem_1: choose s=Some x -> mem x s=true.
Lemma choose_mem_2: choose s=None -> is_empty s=true.
Lemma add_mem_1: mem x (add x s)=true.
Lemma add_mem_2: ~E.eq x y -> mem y (add x s)=mem y s.
Lemma remove_mem_1: mem x (remove x s)=false.
Lemma remove_mem_2: ~E.eq x y -> mem y (remove x s)=mem y s.
Lemma singleton_equal_add: equal (singleton x) (add x empty)=true.
Lemma union_mem: mem x (union s s')=mem x s || mem x s'.
Lemma inter_mem: mem x (inter s s')=mem x s && mem x s'.
Lemma diff_mem: mem x (diff s s')=mem x s && negb (mem x s').
Lemma mem_3 : ~In x s -> mem x s=false.
Lemma mem_4 : mem x s=false -> ~In x s.
Lemma equal_refl: equal s s=true.
Lemma equal_sym: equal s s'=equal s' s.
Lemma equal_trans: equal s s'=true -> equal s' s''=true -> equal s s''=true.
Lemma equal_equal: equal s s'=true -> equal s s''=equal s' s''.
Lemma equal_cardinal: equal s s'=true -> cardinal s=cardinal s'.
Lemma subset_refl: subset s s=true.
Lemma subset_antisym: subset s s'=true -> subset s' s=true -> equal s s'=true.
Lemma subset_trans: subset s s'=true -> subset s' s''=true -> subset s s''=true.
Lemma subset_equal: equal s s'=true -> subset s s'=true.
Lemma choose_mem_3: is_empty s=false -> {x:elt|choose s=Some x /\ mem x s=true}.
Lemma choose_mem_4: choose empty=None.
Lemma add_mem_3: mem y s=true -> mem y (add x s)=true.
Lemma add_equal: mem x s=true -> equal (add x s) s=true.
Lemma remove_mem_3: mem y (remove x s)=true -> mem y s=true.
Lemma remove_equal: mem x s=false -> equal (remove x s) s=true.
Lemma add_remove: mem x s=true -> equal (add x (remove x s)) s=true.
Lemma remove_add: mem x s=false -> equal (remove x (add x s)) s=true.
Lemma is_empty_cardinal: is_empty s = zerob (cardinal s).
Lemma singleton_mem_1: mem x (singleton x)=true.
Lemma singleton_mem_2: ~E.eq x y -> mem y (singleton x)=false.
Lemma singleton_mem_3: mem y (singleton x)=true -> E.eq x y.
Lemma union_sym: equal (union s s') (union s' s)=true.
Lemma union_subset_equal: subset s s'=true -> equal (union s s') s'=true.
Lemma union_equal_1: equal s s'=true-> equal (union s s'') (union s' s'')=true.
Lemma union_equal_2: equal s' s''=true-> equal (union s s') (union s s'')=true.
Lemma union_assoc: equal (union (union s s') s'') (union s (union s' s''))=true.
Lemma add_union_singleton: equal (add x s) (union (singleton x) s)=true.
Lemma union_add: equal (union (add x s) s') (add x (union s s'))=true.
Lemma union_subset_1: subset s (union s s')=true.
Lemma union_subset_2: subset s' (union s s')=true.
Lemma union_subset_3: subset s s''=true -> subset s' s''=true -> subset (union s s') s''=true.
Lemma inter_sym: equal (inter s s') (inter s' s)=true.
Lemma inter_subset_equal: subset s s'=true -> equal (inter s s') s=true.
Lemma inter_equal_1: equal s s'=true -> equal (inter s s'') (inter s' s'')=true.
Lemma inter_equal_2: equal s' s''=true -> equal (inter s s') (inter s s'')=true.
Lemma inter_assoc: equal (inter (inter s s') s'') (inter s (inter s' s''))=true.
Lemma union_inter_1: equal (inter (union s s') s'') (union (inter s s'') (inter s' s''))=true.
Lemma union_inter_2: equal (union (inter s s') s'') (inter (union s s'') (union s' s''))=true.
Lemma inter_add_1: mem x s'=true -> equal (inter (add x s) s') (add x (inter s s'))=true.
Lemma inter_add_2: mem x s'=false -> equal (inter (add x s) s') (inter s s')=true.
Lemma inter_subset_1: subset (inter s s') s=true.
Lemma inter_subset_2: subset (inter s s') s'=true.
Lemma inter_subset_3: subset s'' s=true -> subset s'' s'=true -> subset s'' (inter s s')=true.
Lemma diff_subset: subset (diff s s') s=true.
Lemma diff_subset_equal: subset s s'=true -> equal (diff s s') empty=true.
Lemma remove_inter_singleton: equal (remove x s) (diff s (singleton x))=true.
Lemma diff_inter_empty: equal (inter (diff s s') (inter s s')) empty=true.
Lemma diff_inter_all: equal (union (diff s s') (inter s s')) s=true.
Lemma set_rec:  forall (P:t->Type), (forall s s', equal s s'=true -> P s -> P s') -> (forall s x, mem x s=false -> P s -> P (add x s)) -> P empty -> forall s, P s.
Lemma exclusive_set : forall s s' x, ~(In x s/\In x s') <-> mem x s && mem x s'=false.
Lemma fold_empty: (fold f empty i) = i.
Lemma fold_equal: equal s s'=true -> eqA (fold f s i) (fold f s' i).
Lemma fold_add: mem x s=false -> eqA (fold f (add x s) i) (f x (fold f s i)).
Lemma add_fold: mem x s=true -> eqA (fold f (add x s) i) (fold f s i).
Lemma remove_fold_1: mem x s=true -> eqA (f x (fold f (remove x s) i)) (fold f s i).
Lemma remove_fold_2: mem x s=false -> eqA (fold f (remove x s) i) (fold f s i).
Lemma fold_union: (forall x, mem x s && mem x s'=false) -> eqA (fold f (union s s') i) (fold f s (fold f s' i)).
Lemma add_cardinal_1: forall s x, mem x s=true -> cardinal (add x s)=cardinal s.
Lemma add_cardinal_2: forall s x, mem x s=false -> cardinal (add x s)=S (cardinal s).
Lemma remove_cardinal_1: forall s x, mem x s=true -> S (cardinal (remove x s))=cardinal s.
Lemma remove_cardinal_2: forall s x, mem x s=false -> cardinal (remove x s)=cardinal s.
Lemma union_cardinal: forall s s', (forall x, mem x s && mem x s'=false) -> cardinal (union s s')=cardinal s+cardinal s'.
Lemma subset_cardinal: forall s s', subset s s'=true -> cardinal s<=cardinal s'.
Lemma filter_mem: forall s x, mem x (filter f s)=mem x s && f x.
Lemma for_all_filter: forall s, for_all f s=is_empty (filter (fun x => negb (f x)) s).
Lemma exists_filter : forall s, exists_ f s=negb (is_empty (filter f s)).
Lemma partition_filter_1: forall s, equal (fst (partition f s)) (filter f s)=true.
Lemma partition_filter_2: forall s, equal (snd (partition f s)) (filter (fun x => negb (f x)) s)=true.
Lemma filter_add_1 : forall s x, f x = true -> filter f (add x s) [=] add x (filter f s).
Lemma filter_add_2 : forall s x, f x = false -> filter f (add x s) [=] filter f s.
Lemma add_filter_1 : forall s s' x, f x=true -> (Add x s s') -> (Add x (filter f s) (filter f s')).
Lemma add_filter_2 : forall s s' x, f x=false -> (Add x s s') -> filter f s [=] filter f s'.
Lemma union_filter: forall f g, (compat_bool E.eq f) -> (compat_bool E.eq g) ->
Lemma filter_union: forall s s', filter f (union s s') [=] union (filter f s) (filter f s').
Lemma for_all_mem_1: forall s, (forall x, (mem x s)=true->(f x)=true) -> (for_all f s)=true.
Lemma for_all_mem_2: forall s, (for_all f s)=true -> forall x,(mem x s)=true -> (f x)=true.
Lemma for_all_mem_3: forall s x,(mem x s)=true -> (f x)=false -> (for_all f s)=false.
Lemma for_all_mem_4: forall s, for_all f s=false -> {x:elt | mem x s=true /\ f x=false}.
Lemma for_all_exists: forall s, exists_ f s = negb (for_all (fun x =>negb (f x)) s).
Lemma exists_mem_1: forall s, (forall x, mem x s=true->f x=false) -> exists_ f s=false.
Lemma exists_mem_2: forall s, exists_ f s=false -> forall x, mem x s=true -> f x=false.
Lemma exists_mem_3: forall s x, mem x s=true -> f x=true -> exists_ f s=true.
Lemma exists_mem_4: forall s, exists_ f s=true -> {x:elt | (mem x s)=true /\ (f x)=true}.
Lemma sum_plus : forall f g, Proper (E.eq==>Logic.eq) f -> Proper (E.eq==>Logic.eq) g ->
Lemma sum_filter : forall f, (compat_bool E.eq f) ->
Lemma fold_compat : forall (A:Type)(eqA:A->A->Prop)(st:Equivalence eqA) (f g:elt->A->A), (compat_op E.eq eqA f) -> (transpose eqA f) ->
Lemma sum_compat : forall f g, Proper (E.eq==>Logic.eq) f -> Proper (E.eq==>Logic.eq) g ->
Lemma bet_eq : forall k l, l = k -> between k l.
Lemma between_le : forall k l, between k l -> k <= l.
Lemma between_Sk_l : forall k l, between k l -> S k <= l -> between (S k) l.
Lemma between_restr :   forall k l (m:nat), k <= l -> l <= m -> between k m -> between l m.
Lemma exists_le_S : forall k l, exists_between k l -> S k <= l.
Lemma exists_lt : forall k l, exists_between k l -> k < l.
Lemma exists_S_le : forall k l, exists_between k (S l) -> k <= l.
Lemma in_int_intro : forall p q r, p <= r -> r < q -> in_int p q r.
Lemma in_int_lt : forall p q r, in_int p q r -> p < q.
Lemma in_int_p_Sq :   forall p q r, in_int p (S q) r -> in_int p q r \/ r = q :>nat.
Lemma in_int_S : forall p q r, in_int p q r -> in_int p (S q) r.
Lemma in_int_Sp_q : forall p q r, in_int (S p) q r -> in_int p q r.
Lemma between_in_int :   forall k l, between k l -> forall r, in_int k l r -> P r.
Lemma in_int_between :   forall k l, k <= l -> (forall r, in_int k l r -> P r) -> between k l.
Lemma exists_in_int :   forall k l, exists_between k l ->  exists2 m : nat, in_int k l m & Q m.
Lemma in_int_exists : forall k l r, in_int k l r -> Q r -> exists_between k l.
Lemma between_or_exists :   forall k l,     k <= l ->     (forall n:nat, in_int k l n -> P n \/ Q n) ->     between k l \/ exists_between k l.
Lemma between_not_exists :   forall k l,     between k l ->     (forall n:nat, in_int k l n -> P n -> ~ Q n) -> ~ exists_between k l.
Lemma nth_le : forall (init:nat) l (n:nat), P_nth init l n -> init <= l.
Lemma event_O : eventually 0 -> Q 0.
Lemma JMeq_eq_refl {A} (x : A) : JMeq_eq (@JMeq_refl _ x) = eq_refl.
Lemma UIP_refl_refl A (x : A) : Eqdep.EqdepTheory.UIP_refl A x eq_refl = eq_refl.
Lemma inj_pairT2_refl A (x : A) (P : A -> Type) (p : P x) : Eqdep.EqdepTheory.inj_pairT2 A P x p p eq_refl = eq_refl.
Lemma solution_left A (B : A -> Type) (t : A) : B t -> (forall x, x = t -> B x).
Lemma solution_right A (B : A -> Type) (t : A) : B t -> (forall x, t = x -> B x).
Lemma deletion A B (t : A) : B -> (t = t -> B).
Lemma simplification_heq A B (x y : A) : (x = y -> B) -> (JMeq x y -> B).
Lemma simplification_existT2 A (P : A -> Type) B (p : A) (x y : P p) : (x = y -> B) -> (conditional_eq (existT P p x) (existT P p y) -> B).
Lemma simplification_existT1 A (P : A -> Type) B (p q : A) (x : P p) (y : P q) : (p = q -> conditional_eq (existT P p x) (existT P q y) -> B) -> (existT P p x = existT P q y -> B).
Lemma simplification_K A (x : A) (B : x = x -> Type) : B eq_refl -> (forall p : x = x, B p).
Lemma pow_succ_r' : forall a b, a^(S b) == a * a^b.
Lemma pow_0_l : forall a, a~=0 -> 0^a == 0.
Lemma pow_1_l : forall a, 1^a == 1.
Lemma pow_add_r : forall a b c, a^(b+c) == a^b * a^c.
Lemma pow_mul_l : forall a b c, (a*b)^c == a^c * b^c.
Lemma pow_mul_r : forall a b c, a^(b*c) == (a^b)^c.
Lemma pow_eq_0 : forall a b, b~=0 -> a^b == 0 -> a == 0.
Lemma pow_nonzero : forall a b, a~=0 -> a^b ~= 0.
Lemma pow_eq_0_iff : forall a b, a^b == 0 <-> b~=0 /\ a==0.
Lemma pow_lt_mono_l : forall a b c, c~=0 -> a<b -> a^c < b^c.
Lemma pow_le_mono_l : forall a b c, a<=b -> a^c <= b^c.
Lemma pow_gt_1 : forall a b, 1<a -> b~=0 -> 1<a^b.
Lemma pow_lt_mono_r : forall a b c, 1<a -> b<c -> a^b < a^c.
Lemma pow_le_mono_r : forall a b c, a~=0 -> b<=c -> a^b <= a^c.
Lemma pow_le_mono : forall a b c d, a~=0 -> a<=c -> b<=d -> a^b <= c^d.
Lemma pow_inj_l : forall a b c, c~=0 -> a^c == b^c -> a == b.
Lemma pow_inj_r : forall a b c, 1<a -> a^b == a^c -> b == c.
Lemma pow_lt_mono_l_iff : forall a b c, c~=0 -> (a<b <-> a^c < b^c).
Lemma pow_le_mono_l_iff : forall a b c, c~=0 -> (a<=b <-> a^c <= b^c).
Lemma pow_lt_mono_r_iff : forall a b c, 1<a -> (b<c <-> a^b < a^c).
Lemma pow_le_mono_r_iff : forall a b c, 1<a -> (b<=c <-> a^b <= a^c).
Lemma pow_gt_lin_r : forall a b, 1<a -> b < a^b.
Lemma pow_add_lower : forall a b c, c~=0 -> a^c + b^c <= (a+b)^c.
Lemma pow_add_upper : forall a b c, c~=0 -> (a+b)^c <= 2^(pred c) * (a^c + b^c).
Lemma even_pow : forall a b, b~=0 -> even (a^b) = even a.
Lemma odd_pow : forall a b, b~=0 -> odd (a^b) = odd a.
Lemma Im_def :   forall (X:Ensemble U) (f:U -> V) (x:U), In _ X x -> In _ (Im X f) (f x).
Lemma Im_add :   forall (X:Ensemble U) (x:U) (f:U -> V),     Im (Add _ X x) f = Add _ (Im X f) (f x).
Lemma image_empty : forall f:U -> V, Im (Empty_set U) f = Empty_set V.
Lemma finite_image :   forall (X:Ensemble U) (f:U -> V), Finite _ X -> Finite _ (Im X f).
Lemma Im_inv :   forall (X:Ensemble U) (f:U -> V) (y:V),     In _ (Im X f) y ->  exists x : U, In _ X x /\ f x = y.
Lemma not_injective_elim :   forall f:U -> V,     ~ injective f ->  exists x : _, (exists y : _, f x = f y /\ x <> y).
Lemma cardinal_Im_intro :   forall (A:Ensemble U) (f:U -> V) (n:nat),     cardinal _ A n ->  exists p : nat, cardinal _ (Im A f) p.
Lemma In_Image_elim :   forall (A:Ensemble U) (f:U -> V),     injective f -> forall x:U, In _ (Im A f) (f x) -> In _ A x.
Lemma injective_preserves_cardinal :   forall (A:Ensemble U) (f:U -> V) (n:nat),     injective f ->     cardinal _ A n -> forall n':nat, cardinal _ (Im A f) n' -> n' = n.
Lemma cardinal_decreases :   forall (A:Ensemble U) (f:U -> V) (n:nat),     cardinal U A n -> forall n':nat, cardinal V (Im A f) n' -> n' <= n.
Lemma Pigeonhole_principle :   forall (A:Ensemble U) (f:U -> V) (n:nat),     cardinal _ A n ->     forall n':nat, cardinal _ (Im A f) n' -> n' < n ->  exists x : _, (exists y : _, f x = f y /\ x <> y).
Lemma Zmin_spec x y : x <= y /\ Z.min x y = x  \/  x > y /\ Z.min x y = y.
Lemma Zmin_irreducible n m : Z.min n m = n \/ Z.min n m = m.
Lemma Zmin_le_prime_inf n m p : Z.min n m <= p -> {n <= p} + {m <= p}.
Lemma Zpos_min_1 p : Z.min 1 (Zpos p) = 1.
Lemma spec_quot : forall x y, to_Z (quot x y) = (to_Z x) ÷ (to_Z y).
Lemma spec_rem : forall x y,  to_Z (rem x y) = Z.rem (to_Z x) (to_Z y).
Lemma spec_sgn : forall x, to_Z (sgn x) = Z.sgn (to_Z x).
Lemma spec_even : forall z, even z = Z.even (to_Z z).
Lemma spec_odd : forall z, odd z = Z.odd (to_Z z).
Lemma Zlnot_alt1 : forall x, -(x+1) = Z.lnot x.
Lemma Zlnot_alt2 : forall x, Z.lnot (x-1) = -x.
Lemma Zlnot_alt3 : forall x, Z.lnot (-x) = x-1.
Lemma spec_norm_pos : forall x, to_Z (norm_pos x) = to_Z x.
Lemma spec_norm_pos_pos : forall x y, norm_pos x = Neg y -> 0 < NN.to_Z y.
Lemma spec_testbit: forall x p, testbit x p = Z.testbit (to_Z x) (to_Z p).
Lemma spec_shiftl: forall x p, to_Z (shiftl x p) = Z.shiftl (to_Z x) (to_Z p).
Lemma spec_shiftr: forall x p, to_Z (shiftr x p) = Z.shiftr (to_Z x) (to_Z p).
Lemma spec_land: forall x y, to_Z (land x y) = Z.land (to_Z x) (to_Z y).
Lemma spec_lor: forall x y, to_Z (lor x y) = Z.lor (to_Z x) (to_Z y).
Lemma spec_ldiff: forall x y, to_Z (ldiff x y) = Z.ldiff (to_Z x) (to_Z y).
Lemma spec_lxor: forall x y, to_Z (lxor x y) = Z.lxor (to_Z x) (to_Z y).
Lemma spec_div2: forall x, to_Z (div2 x) = Z.div2 (to_Z x).
Lemma set_In_dec : forall (a:A) (x:set), {set_In a x} + {~ set_In a x}.
Lemma set_mem_ind :  forall (B:Type) (P:B -> Prop) (y z:B) (a:A) (x:set),    (set_In a x -> P y) -> P z -> P (if set_mem a x then y else z).
Lemma set_mem_ind2 :  forall (B:Type) (P:B -> Prop) (y z:B) (a:A) (x:set),    (set_In a x -> P y) ->    (~ set_In a x -> P z) -> P (if set_mem a x then y else z).
Lemma set_mem_correct1 :  forall (a:A) (x:set), set_mem a x = true -> set_In a x.
Lemma set_mem_correct2 :  forall (a:A) (x:set), set_In a x -> set_mem a x = true.
Lemma set_mem_complete1 :  forall (a:A) (x:set), set_mem a x = false -> ~ set_In a x.
Lemma set_mem_complete2 :  forall (a:A) (x:set), ~ set_In a x -> set_mem a x = false.
Lemma set_add_intro1 :  forall (a b:A) (x:set), set_In a x -> set_In a (set_add b x).
Lemma set_add_intro2 :  forall (a b:A) (x:set), a = b -> set_In a (set_add b x).
Lemma set_add_intro :  forall (a b:A) (x:set), a = b \/ set_In a x -> set_In a (set_add b x).
Lemma set_add_elim :  forall (a b:A) (x:set), set_In a (set_add b x) -> a = b \/ set_In a x.
Lemma set_add_elim2 :  forall (a b:A) (x:set), set_In a (set_add b x) -> a <> b -> set_In a x.
Lemma set_add_not_empty : forall (a:A) (x:set), set_add a x <> empty_set.
Lemma set_union_intro1 :  forall (a:A) (x y:set), set_In a x -> set_In a (set_union x y).
Lemma set_union_intro2 :  forall (a:A) (x y:set), set_In a y -> set_In a (set_union x y).
Lemma set_union_intro :  forall (a:A) (x y:set),    set_In a x \/ set_In a y -> set_In a (set_union x y).
Lemma set_union_elim :  forall (a:A) (x y:set),    set_In a (set_union x y) -> set_In a x \/ set_In a y.
Lemma set_union_emptyL :  forall (a:A) (x:set), set_In a (set_union empty_set x) -> set_In a x.
Lemma set_union_emptyR :  forall (a:A) (x:set), set_In a (set_union x empty_set) -> set_In a x.
Lemma set_inter_intro :  forall (a:A) (x y:set),    set_In a x -> set_In a y -> set_In a (set_inter x y).
Lemma set_inter_elim1 :  forall (a:A) (x y:set), set_In a (set_inter x y) -> set_In a x.
Lemma set_inter_elim2 :  forall (a:A) (x y:set), set_In a (set_inter x y) -> set_In a y.
Lemma set_inter_elim :  forall (a:A) (x y:set),    set_In a (set_inter x y) -> set_In a x /\ set_In a y.
Lemma set_diff_intro :  forall (a:A) (x y:set),    set_In a x -> ~ set_In a y -> set_In a (set_diff x y).
Lemma set_diff_elim1 :  forall (a:A) (x y:set), set_In a (set_diff x y) -> set_In a x.
Lemma set_diff_elim2 :  forall (a:A) (x y:set), set_In a (set_diff x y) -> ~ set_In a y.
Lemma set_diff_trivial : forall (a:A) (x:set), ~ set_In a (set_diff x x).
Lemma complement_inverse : forall A (R : relation A), complement (inverse R) = inverse (complement R).
Lemma flip_Reflexive `{Reflexive A R} : Reflexive (flip R).
Lemma StrictOrder_inverse `(StrictOrder A R) : StrictOrder (inverse R).
Lemma PreOrder_inverse `(PreOrder A R) : PreOrder (inverse R).
Lemma PartialOrder_inverse `(PartialOrder A eqA R) : PartialOrder eqA (inverse R).
Lemma cardinal_invert :   forall (X:Ensemble U) (p:nat),     cardinal U X p ->     match p with | O => X = Empty_set U | S n =>         exists A : _,           (exists x : _, X = Add U A x /\ ~ In U A x /\ cardinal U A n)     end.
Lemma cardinal_elim :   forall (X:Ensemble U) (p:nat),     cardinal U X p ->     match p with	| O => X = Empty_set U	| S n => Inhabited U X     end.
Lemma prop_degen_ext : prop_degeneracy -> prop_extensionality.
Lemma prop_degen_em : prop_degeneracy -> excluded_middle.
Lemma prop_ext_em_degen : prop_extensionality -> excluded_middle -> prop_degeneracy.
Lemma provable_prop_ext : prop_extensionality -> provable_prop_extensionality.
Lemma prop_ext_A_eq_A_imp_A : prop_extensionality -> forall A:Prop, inhabited A -> (A -> A) = A.
Lemma prop_ext_retract_A_A_imp_A : prop_extensionality -> forall A:Prop, inhabited A -> retract A (A -> A).
Lemma ext_prop_fixpoint : prop_extensionality -> forall A:Prop, inhabited A -> has_fixpoint A.
Lemma aux : prop_extensionality -> bool_dep_induction -> true = false.
Lemma ext_prop_dep_proof_irrel_gen :   prop_extensionality -> bool_dep_induction -> proof_irrelevance.
Lemma ext_prop_dep_proof_irrel_cc :   prop_extensionality -> BoolP_dep_induction -> proof_irrelevance.
Lemma ext_prop_dep_proof_irrel_cic : prop_extensionality -> proof_irrelevance.
Lemma p2p1 : forall A:Prop, A -> b2p (p2b A).
Lemma p2p2 : b1 <> b2 -> forall A:Prop, b2p (p2b A) -> A.
Lemma excluded_middle_Godel_Dummett : excluded_middle -> GodelDummett.
Lemma Godel_Dummett_iff_right_distr_implication_over_disjunction : GodelDummett <-> RightDistributivityImplicationOverDisjunction.
Lemma Godel_Dummett_weak_excluded_middle : GodelDummett -> weak_excluded_middle.
Lemma independence_general_premises_Godel_Dummett : IndependenceOfGeneralPremises -> GodelDummett.
Lemma independence_general_premises_drinker : IndependenceOfGeneralPremises <-> DrinkerParadox.
Lemma excluded_middle_independence_general_premises : generalized_excluded_middle -> DrinkerParadox.
Lemma odd_pred : forall n, odd (P n) = even n.
Lemma even_pred : forall n, even (P n) = odd n.
Lemma even_opp : forall n, even (-n) = even n.
Lemma odd_opp : forall n, odd (-n) = odd n.
Lemma even_sub : forall n m, even (n-m) = Bool.eqb (even n) (even m).
Lemma odd_sub : forall n m, odd (n-m) = xorb (odd n) (odd m).
Lemma mod_upper_bound : forall a b, b ~= 0 -> a mod b < b.
Lemma mod_eq : forall a b, b~=0 -> a mod b == a - b*(a/b).
Lemma div_same : forall a, a~=0 -> a/a == 1.
Lemma mod_same : forall a, a~=0 -> a mod a == 0.
Lemma div_0_l: forall a, a~=0 -> 0/a == 0.
Lemma mod_0_l: forall a, a~=0 -> 0 mod a == 0.
Lemma div_1_r: forall a, a/1 == a.
Lemma mod_1_r: forall a, a mod 1 == 0.
Lemma div_1_l: forall a, 1<a -> 1/a == 0.
Lemma mod_1_l: forall a, 1<a -> 1 mod a == 1.
Lemma div_mul : forall a b, b~=0 -> (a*b)/b == a.
Lemma mod_mul : forall a b, b~=0 -> (a*b) mod b == 0.
Lemma div_str_pos : forall a b, 0<b<=a -> 0 < a/b.
Lemma div_small_iff : forall a b, b~=0 -> (a/b==0 <-> a<b).
Lemma mod_small_iff : forall a b, b~=0 -> (a mod b == a <-> a<b).
Lemma div_str_pos_iff : forall a b, b~=0 -> (0<a/b <-> b<=a).
Lemma div_lt : forall a b, 0<a -> 1<b -> a/b < a.
Lemma div_le_mono : forall a b c, c~=0 -> a<=b -> a/c <= b/c.
Lemma mul_div_le : forall a b, b~=0 -> b*(a/b) <= a.
Lemma mul_succ_div_gt: forall a b, b~=0 -> a < b*(S (a/b)).
Lemma div_exact : forall a b, b~=0 -> (a == b*(a/b) <-> a mod b == 0).
Lemma div_le_compat_l: forall p q r, 0<q<=r -> p/r <= p/q.
Lemma mod_add : forall a b c, c~=0 -> (a + b * c) mod c == a mod c.
Lemma div_add : forall a b c, c~=0 -> (a + b * c) / c == a / c + b.
Lemma div_add_l: forall a b c, b~=0 -> (a * b + c) / b == a + c / b.
Lemma div_mul_cancel_r : forall a b c, b~=0 -> c~=0 -> (a*c)/(b*c) == a/b.
Lemma div_mul_cancel_l : forall a b c, b~=0 -> c~=0 -> (c*a)/(c*b) == a/b.
Lemma mul_mod_distr_r: forall a b c, b~=0 -> c~=0 -> (a*c) mod (b*c) == (a mod b) * c.
Lemma mul_mod_distr_l: forall a b c, b~=0 -> c~=0 -> (c*a) mod (c*b) == c * (a mod b).
Lemma mul_mod_idemp_l : forall a b n, n~=0 -> ((a mod n)*b) mod n == (a*b) mod n.
Lemma mul_mod_idemp_r : forall a b n, n~=0 -> (a*(b mod n)) mod n == (a*b) mod n.
Lemma add_mod_idemp_l : forall a b n, n~=0 -> ((a mod n)+b) mod n == (a+b) mod n.
Lemma add_mod_idemp_r : forall a b n, n~=0 -> (a+(b mod n)) mod n == (a+b) mod n.
Lemma div_div : forall a b c, b~=0 -> c~=0 -> (a/b)/c == a/(b*c).
Lemma mod_mul_r : forall a b c, b~=0 -> c~=0 -> a mod (b*c) == a mod b + b*((a/b) mod c).
Lemma mod_divides : forall a b, b~=0 -> (a mod b == 0 <-> exists c, a == b*c).
Lemma not_all_not_ex : forall P:U -> Prop, ~ (forall n:U, ~ P n) ->  exists n : U, P n.
Lemma not_all_ex_not : forall P:U -> Prop, ~ (forall n:U, P n) ->  exists n : U, ~ P n.
Lemma not_ex_all_not : forall P:U -> Prop, ~ (exists n : U, P n) -> forall n:U, ~ P n.
Lemma not_ex_not_all : forall P:U -> Prop, ~ (exists n : U, ~ P n) -> forall n:U, P n.
Lemma ex_not_not_all : forall P:U -> Prop, (exists n : U, ~ P n) -> ~ (forall n:U, P n).
Lemma all_not_not_ex : forall P:U -> Prop, (forall n:U, ~ P n) -> ~ (exists n : U, P n).
Lemma InA_altdef : forall x l, InA x l <-> Exists (eqA x) l.
Lemma InA_cons : forall x y l, InA x (y::l) <-> eqA x y \/ InA x l.
Lemma InA_nil : forall x, InA x nil <-> False.
Lemma InA_alt : forall x l, InA x l <-> exists y, eqA x y /\ In y l.
Lemma NoDupA_altdef : forall l, NoDupA l <-> ForallOrdPairs (complement eqA) l.
Lemma incl_nil l : inclA nil l.
Lemma eqlistA_altdef : forall l l', eqlistA l l' <-> Forall2 eqA l l'.
Lemma InA_eqA : forall l x y, eqA x y -> InA x l -> InA y l.
Lemma In_InA : forall l x, In x l -> InA x l.
Lemma InA_split : forall l x, InA x l -> exists l1 y l2, eqA x y /\ l = l1++y::l2.
Lemma InA_app : forall l1 l2 x, InA x (l1 ++ l2) -> InA x l1 \/ InA x l2.
Lemma InA_app_iff : forall l1 l2 x, InA x (l1 ++ l2) <-> InA x l1 \/ InA x l2.
Lemma InA_rev : forall p m, InA p (rev m) <-> InA p m.
Lemma InA_singleton x y : InA x (y::nil) <-> eqA x y.
Lemma InA_double_head x y l : InA x (y :: y :: l) <-> InA x (y :: l).
Lemma InA_permute_heads x y z l : InA x (y :: z :: l) <-> InA x (z :: y :: l).
Lemma InA_app_idem x l : InA x (l ++ l) <-> InA x l.
Lemma NoDupA_app : forall l l', NoDupA l -> NoDupA l' -> (forall x, InA x l -> InA x l' -> False) -> NoDupA (l++l').
Lemma NoDupA_rev : forall l, NoDupA l -> NoDupA (rev l).
Lemma NoDupA_split : forall l l' x, NoDupA (l++x::l') -> NoDupA (l++l').
Lemma NoDupA_swap : forall l l' x, NoDupA (l++x::l') -> NoDupA (x::l++l').
Lemma NoDupA_singleton x : NoDupA (x::nil).
Lemma equivlistA_cons_nil x l : ~ equivlistA (x :: l) nil.
Lemma equivlistA_nil_eq l : equivlistA l nil -> l = nil.
Lemma equivlistA_double_head x l : equivlistA (x :: x :: l) (x :: l).
Lemma equivlistA_permute_heads x y l : equivlistA (x :: y :: l) (y :: x :: l).
Lemma equivlistA_app_idem l : equivlistA (l ++ l) l.
Lemma equivlistA_NoDupA_split l l1 l2 x y : eqA x y -> NoDupA (x::l) -> NoDupA (l1++y::l2) -> equivlistA (x::l) (l1++y::l2) -> equivlistA l (l1++l2).
Lemma fold_right_eqlistA :  forall s s', eqlistA s s' ->  eqB (fold_right f i s) (fold_right f i s').
Lemma ForallNeqPairs_ForallOrdPairs : forall l, NoDupA l -> ForallNeqPairs l -> ForallOrdPairs R l.
Lemma ForallOrdPairs_ForallNeqPairs : forall l, ForallOrdPairs R l -> ForallNeqPairs l.
Lemma ForallOrdPairs_inclA : forall l l', NoDupA l' -> inclA l' l -> ForallOrdPairs R l -> ForallOrdPairs R l'.
Lemma fold_right_commutes_restr : forall s1 s2 x, ForallOrdPairs R (s1++x::s2) -> eqB (fold_right f i (s1++x::s2)) (f x (fold_right f i (s1++s2))).
Lemma fold_right_equivlistA_restr : forall s s', NoDupA s -> NoDupA s' -> ForallOrdPairs R s -> equivlistA s s' -> eqB (fold_right f i s) (fold_right f i s').
Lemma fold_right_add_restr : forall s' s x, NoDupA s -> NoDupA s' -> ForallOrdPairs R s' -> ~ InA x s -> equivlistA s' (x::s) -> eqB (fold_right f i s') (f x (fold_right f i s)).
Lemma fold_right_commutes : forall s1 s2 x, eqB (fold_right f i (s1++x::s2)) (f x (fold_right f i (s1++s2))).
Lemma fold_right_equivlistA : forall s s', NoDupA s -> NoDupA s' -> equivlistA s s' -> eqB (fold_right f i s) (fold_right f i s').
Lemma fold_right_add : forall s' s x, NoDupA s -> NoDupA s' -> ~ InA x s -> equivlistA s' (x::s) -> eqB (fold_right f i s') (f x (fold_right f i s)).
Lemma InA_dec : forall x l, { InA x l } + { ~ InA x l }.
Lemma removeA_filter : forall x l, removeA x l = filter (fun y => if eqA_dec x y then false else true) l.
Lemma removeA_InA : forall l x y, InA y (removeA x l) <-> InA y l /\ ~eqA x y.
Lemma removeA_NoDupA : forall s x, NoDupA s ->  NoDupA (removeA x s).
Lemma removeA_equivlistA : forall l l' x, ~InA x l -> equivlistA (x :: l) l' -> equivlistA l (removeA x l').
Lemma InfA_ltA : forall l x y, ltA x y -> InfA y l -> InfA x l.
Lemma InfA_eqA l x y : eqA x y -> InfA y l -> InfA x l.
Lemma SortA_InfA_InA : forall l x a, SortA l -> InfA a l -> InA x l -> ltA a x.
Lemma In_InfA : forall l x, (forall y, In y l -> ltA x y) -> InfA x l.
Lemma InA_InfA : forall l x, (forall y, InA y l -> ltA x y) -> InfA x l.
Lemma InfA_alt : forall l x, SortA l -> (InfA x l <-> (forall y, InA y l -> ltA x y)).
Lemma InfA_app : forall l1 l2 a, InfA a l1 -> InfA a l2 -> InfA a (l1++l2).
Lemma SortA_app : forall l1 l2, SortA l1 -> SortA l2 -> (forall x y, InA x l1 -> InA y l2 -> ltA x y) -> SortA (l1 ++ l2).
Lemma SortA_NoDupA : forall l, SortA l -> NoDupA l.
Lemma eqlistA_length : forall l l', eqlistA l l' -> length l = length l'.
Lemma eqlistA_app : forall l1 l1' l2 l2',  eqlistA l1 l1' -> eqlistA l2 l2' -> eqlistA (l1++l2) (l1'++l2').
Lemma eqlistA_rev_app : forall l1 l1',  eqlistA l1 l1' -> forall l2 l2', eqlistA l2 l2' ->  eqlistA ((rev l1)++l2) ((rev l1')++l2').
Lemma eqlistA_rev : forall l1 l1',  eqlistA l1 l1' -> eqlistA (rev l1) (rev l1').
Lemma SortA_equivlistA_eqlistA : forall l l',  SortA l -> SortA l' -> equivlistA l l' -> eqlistA l l'.
Lemma filter_sort : forall f l, SortA l -> SortA (List.filter f l).
Lemma filter_InA : forall f, Proper (eqA==>eq) f -> forall l x, InA x (List.filter f l) <-> InA x l /\ f x = true.
Lemma filter_split : forall f, (forall x y, f x = true -> f y = false -> ltA x y) -> forall l, SortA l -> l = filter f l ++ filter (fun x=>negb (f x)) l.
Lemma findA_NoDupA : forall l a b, NoDupA (fun p p' => eqA (fst p) (fst p')) l -> (InA (fun p p' => eqA (fst p) (fst p') /\ snd p = snd p') (a,b) l <-> findA (fun a' => if eqA_dec a a' then true else false) l = Some b).
Lemma In_In : forall s x, M.In x s <-> In _ (!!s) x.
Lemma Subset_Included : forall s s',  s[<=]s'  <-> Included _ (!!s) (!!s').
Lemma Equal_Same_set : forall s s', s[=]s' <-> !!s === !!s'.
Lemma empty_Empty_Set : !!M.empty === Empty_set _.
Lemma Empty_Empty_set : forall s, Empty s -> !!s === Empty_set _.
Lemma singleton_Singleton : forall x, !!(M.singleton x) === Singleton _ x .
Lemma union_Union : forall s s', !!(union s s') === Union _ (!!s) (!!s').
Lemma inter_Intersection : forall s s', !!(inter s s') === Intersection _ (!!s) (!!s').
Lemma add_Add : forall x s, !!(add x s) === Add _ (!!s) x.
Lemma Add_Add : forall x s s', MP.Add x s s' -> !!s' === Add _ (!!s) x.
Lemma remove_Subtract : forall x s, !!(remove x s) === Subtract _ (!!s) x.
Lemma mkEns_Finite : forall s, Finite _ (!!s).
Lemma mkEns_cardinal : forall s, cardinal _ (!!s) (M.cardinal s).
Lemma Ens_to_MSet : forall e : Ensemble M.elt, Finite _ e ->
Lemma andb_prop : forall a b:bool, andb a b = true -> a = true /\ b = true.
Lemma andb_true_intro : forall b1 b2:bool, b1 = true /\ b2 = true -> andb b1 b2 = true.
Lemma eq_true_ind_r : forall (P : bool -> Prop) (b : bool), P b -> eq_true b -> P true.
Lemma eq_true_rec_r : forall (P : bool -> Set) (b : bool), P b -> eq_true b -> P true.
Lemma eq_true_rect_r : forall (P : bool -> Type) (b : bool), P b -> eq_true b -> P true.
Lemma surjective_pairing : forall (A B:Type) (p:A * B), p = pair (fst p) (snd p).
Lemma injective_projections : forall (A B:Type) (p1 p2:A * B),   fst p1 = fst p2 -> snd p1 = snd p2 -> p1 = p2.
Lemma CompOpp_involutive : forall c, CompOpp (CompOpp c) = c.
Lemma CompOpp_inj : forall c c', CompOpp c = CompOpp c' -> c = c'.
Lemma CompOpp_iff : forall c c', CompOpp c = c' <-> c = CompOpp c'.
Lemma CompareSpec2Type : forall Peq Plt Pgt c, CompareSpec Peq Plt Pgt c -> CompareSpecT Peq Plt Pgt c.
Lemma CompSpec2Type : forall A (eq lt:A->A->Prop) x y c, CompSpec eq lt x y c -> CompSpecT eq lt x y c.
Lemma inverse_image_of_equivalence : forall (A B:Type) (f:A -> B) (r:relation B),   equivalence B r -> equivalence A (fun x y:A => r (f x) (f y)).
Lemma inverse_image_of_eq : forall (A B:Type) (f:A -> B), equivalence A (fun x y:A => f x = f y).
Lemma Majxy_cv_R0 : forall x y:R, Un_cv (Majxy x y) 0.
Lemma reste1_maj : forall (x y:R) (N:nat),   (0 < N)%nat -> Rabs (Reste1 x y N) <= Majxy x y (pred N).
Lemma reste2_maj : forall (x y:R) (N:nat), (0 < N)%nat -> Rabs (Reste2 x y N) <= Majxy x y N.
Lemma reste1_cv_R0 : forall x y:R, Un_cv (Reste1 x y) 0.
Lemma reste2_cv_R0 : forall x y:R, Un_cv (Reste2 x y) 0.
Lemma reste_cv_R0 : forall x y:R, Un_cv (Reste x y) 0.
Lemma INR_fact_neq_0 : forall n:nat, INR (fact n) <> 0.
Lemma fact_simpl : forall n:nat, fact (S n) = (S n * fact n)%nat.
Lemma simpl_fact : forall n:nat, / INR (fact (S n)) * / / INR (fact n) = / INR (S n).
Lemma pow_O : forall x:R, x ^ 0 = 1.
Lemma pow_1 : forall x:R, x ^ 1 = x.
Lemma pow_add : forall (x:R) (n m:nat), x ^ (n + m) = x ^ n * x ^ m.
Lemma Rpow_mult_distr : forall (x y:R) (n:nat), (x * y) ^ n = x^n * y^n.
Lemma pow_nonzero : forall (x:R) (n:nat), x <> 0 -> x ^ n <> 0.
Lemma pow_RN_plus : forall (x:R) (n m:nat), x <> 0 -> x ^ n = x ^ (n + m) * / x ^ m.
Lemma pow_lt : forall (x:R) (n:nat), 0 < x -> 0 < x ^ n.
Lemma Rlt_pow_R1 : forall (x:R) (n:nat), 1 < x -> (0 < n)%nat -> 1 < x ^ n.
Lemma Rlt_pow : forall (x:R) (n m:nat), 1 < x -> (n < m)%nat -> x ^ n < x ^ m.
Lemma tech_pow_Rmult : forall (x:R) (n:nat), x * x ^ n = x ^ S n.
Lemma tech_pow_Rplus : forall (x:R) (a n:nat), x ^ a + INR n * x ^ a = INR (S n) * x ^ a.
Lemma poly : forall (n:nat) (x:R), 0 < x -> 1 + INR n * x <= (1 + x) ^ n.
Lemma Power_monotonic : forall (x:R) (m n:nat),   Rabs x > 1 -> (m <= n)%nat -> Rabs (x ^ m) <= Rabs (x ^ n).
Lemma RPow_abs : forall (x:R) (n:nat), Rabs x ^ n = Rabs (x ^ n).
Lemma Pow_x_infinity : forall x:R,   Rabs x > 1 ->   forall b:R,     exists N : nat, (forall n:nat, (n >= N)%nat -> Rabs (x ^ n) >= b).
Lemma pow_ne_zero : forall n:nat, n <> 0%nat -> 0 ^ n = 0.
Lemma Rinv_pow : forall (x:R) (n:nat), x <> 0 -> / x ^ n = (/ x) ^ n.
Lemma pow_lt_1_zero : forall x:R,   Rabs x < 1 ->   forall y:R,     0 < y ->     exists N : nat, (forall n:nat, (n >= N)%nat -> Rabs (x ^ n) < y).
Lemma pow_R1 : forall (r:R) (n:nat), r ^ n = 1 -> Rabs r = 1 \/ n = 0%nat.
Lemma pow_Rsqr : forall (x:R) (n:nat), x ^ (2 * n) = Rsqr x ^ n.
Lemma pow_le : forall (a:R) (n:nat), 0 <= a -> 0 <= a ^ n.
Lemma pow_1_even : forall n:nat, (-1) ^ (2 * n) = 1.
Lemma pow_1_odd : forall n:nat, (-1) ^ S (2 * n) = -1.
Lemma pow_1_abs : forall n:nat, Rabs ((-1) ^ n) = 1.
Lemma pow_mult : forall (x:R) (n1 n2:nat), x ^ (n1 * n2) = (x ^ n1) ^ n2.
Lemma pow_incr : forall (x y:R) (n:nat), 0 <= x <= y -> x ^ n <= y ^ n.
Lemma pow_R1_Rle : forall (x:R) (k:nat), 1 <= x -> 1 <= x ^ k.
Lemma Rle_pow : forall (x:R) (m n:nat), 1 <= x -> (m <= n)%nat -> x ^ m <= x ^ n.
Lemma pow1 : forall n:nat, 1 ^ n = 1.
Lemma pow_Rabs : forall (x:R) (n:nat), x ^ n <= Rabs x ^ n.
Lemma pow_maj_Rabs : forall (x y:R) (n:nat), Rabs y <= x -> y ^ n <= x ^ n.
Lemma Zpower_NR0 : forall (x:Z) (n:nat), (0 <= x)%Z -> (0 <= Zpower_nat x n)%Z.
Lemma powerRZ_O : forall x:R, x ^Z 0 = 1.
Lemma powerRZ_1 : forall x:R, x ^Z Z.succ 0 = x.
Lemma powerRZ_NOR : forall (x:R) (z:Z), x <> 0 -> x ^Z z <> 0.
Lemma powerRZ_pos_sub (x:R) (n m:positive) : x <> 0 ->  x ^Z (Z.pos_sub n m) = x ^ Pos.to_nat n * / x ^ Pos.to_nat m.
Lemma powerRZ_add : forall (x:R) (n m:Z), x <> 0 -> x ^Z (n + m) = x ^Z n * x ^Z m.
Lemma Zpower_nat_powerRZ : forall n m:nat, IZR (Zpower_nat (Z.of_nat n) m) = INR n ^Z Z.of_nat m.
Lemma Zpower_pos_powerRZ : forall n m, IZR (Z.pow_pos n m) = IZR n ^Z Zpos m.
Lemma powerRZ_lt : forall (x:R) (z:Z), 0 < x -> 0 < x ^Z z.
Lemma powerRZ_le : forall (x:R) (z:Z), 0 < x -> 0 <= x ^Z z.
Lemma Zpower_nat_powerRZ_absolu : forall n m:Z, (0 <= m)%Z -> IZR (Zpower_nat n (Z.abs_nat m)) = IZR n ^Z m.
Lemma powerRZ_R1 : forall n:Z, 1 ^Z n = 1.
Lemma GP_finite : forall (x:R) (n:nat),   sum_f_R0 (fun n:nat => x ^ n) n * (x - 1) = x ^ (n + 1) - 1.
Lemma sum_f_R0_triangle : forall (x:nat -> R) (n:nat),   Rabs (sum_f_R0 x n) <= sum_f_R0 (fun i:nat => Rabs (x i)) n.
Lemma R_dist_pos : forall x y:R, R_dist x y >= 0.
Lemma R_dist_sym : forall x y:R, R_dist x y = R_dist y x.
Lemma R_dist_refl : forall x y:R, R_dist x y = 0 <-> x = y.
Lemma R_dist_eq : forall x:R, R_dist x x = 0.
Lemma R_dist_tri : forall x y z:R, R_dist x y <= R_dist x z + R_dist z y.
Lemma R_dist_plus : forall a b c d:R, R_dist (a + c) (b + d) <= R_dist a b + R_dist c d.
Lemma spec_ww_succ_c : forall x, [+[ww_succ_c x]] = [[x]] + 1.
Lemma spec_ww_add_c  : forall x y, [+[ww_add_c x y]] = [[x]] + [[y]].
Lemma spec_ww_add_c_cont  : P x y (ww_add_c_cont x y).
Lemma spec_ww_add_carry_c :        forall x y, [+[ww_add_carry_c x y]] = [[x]] + [[y]] + 1.
Lemma spec_ww_succ : forall x, [[ww_succ x]] = ([[x]] + 1) mod wwB.
Lemma spec_ww_add : forall x y, [[ww_add x y]] = ([[x]] + [[y]]) mod wwB.
Lemma spec_ww_add_carry :  forall x y, [[ww_add_carry x y]] = ([[x]] + [[y]] + 1) mod wwB.
Lemma AC_IF : forall (P B:Prop) (e1 e2:P) (Q:P -> Prop),  (B -> Q e1) -> (~ B -> Q e2) -> Q (IFProp B e1 e2).
Lemma AC : forall r:retract_cond, retract -> forall a:A, j2 r (i2 r a) = a.
Lemma L1 : forall A B:Prop, retract_cond (pow A) (pow B).
Lemma retract_pow_U_U : retract (pow U) U.
Lemma not_has_fixpoint : R R = Not_b (R R).
Lemma le_dec : forall n m, {n <= m} + {m <= n}.
Lemma le_decide : forall n m, n <= m -> lt_or_eq n m.
Lemma le_le_S_eq : forall n m, n <= m -> S n <= m \/ n = m.
Lemma discrete_nat : forall n m, n < m -> S n = m \/ (exists r : nat, m = S (S (n + r))).
Lemma cong_congr :   forall x y z t:U, cong x y -> cong z t -> cong (op x z) (op y t).
Lemma comm_right : forall x y z:U, cong (op x (op y z)) (op x (op z y)).
Lemma comm_left : forall x y z:U, cong (op (op x y) z) (op (op y x) z).
Lemma perm_right : forall x y z:U, cong (op (op x y) z) (op (op x z) y).
Lemma perm_left : forall x y z:U, cong (op x (op y z)) (op y (op x z)).
Lemma op_rotate : forall x y z t:U, cong (op x (op y z)) (op z (op x y)).
Lemma twist :   forall x y z t:U, cong (op x (op (op y z) t)) (op (op y (op x t)) z).
Lemma Acc_inv : forall x:A, Acc x -> forall y:A, R y x -> Acc y.
Lemma Fix_F_eq :  forall (x:A) (r:Acc x),    F (fun (y:A) (p:R y x) => Fix_F (x:=y) (Acc_inv r p)) = Fix_F (x:=x) r.
Lemma Fix_F_inv : forall (x:A) (r s:Acc x), Fix_F r = Fix_F s.
Lemma Fix_eq : forall x:A, Fix x = F (fun (y:A) (p:R y x) => Fix y).
Lemma abs_eq : forall n, 0<=n -> abs n == n.
Lemma abs_neq : forall n, n<=0 -> abs n == -n.
Lemma sgn_null : forall n, n==0 -> sgn n == 0.
Lemma sgn_pos : forall n, 0<n -> sgn n == 1.
Lemma sgn_neg : forall n, n<0 -> sgn n == -1.
Lemma abs_max : forall n, abs n == max n (-n).
Lemma abs_neq' : forall n, 0<=-n -> abs n == -n.
Lemma abs_nonneg : forall n, 0 <= abs n.
Lemma abs_eq_iff : forall n, abs n == n <-> 0<=n.
Lemma abs_neq_iff : forall n, abs n == -n <-> n<=0.
Lemma abs_opp : forall n, abs (-n) == abs n.
Lemma abs_0 : abs 0 == 0.
Lemma abs_0_iff : forall n, abs n == 0 <-> n==0.
Lemma abs_pos : forall n, 0 < abs n <-> n~=0.
Lemma abs_eq_or_opp : forall n, abs n == n \/ abs n == -n.
Lemma abs_or_opp_abs : forall n, n == abs n \/ n == - abs n.
Lemma abs_involutive : forall n, abs (abs n) == abs n.
Lemma abs_spec : forall n, (0 <= n /\ abs n == n) \/ (n < 0 /\ abs n == -n).
Lemma abs_case_strong : forall (P:t->Prop) n, Proper (eq==>iff) P ->   (0<=n -> P n) -> (n<=0 -> P (-n)) -> P (abs n).
Lemma abs_case : forall (P:t->Prop) n, Proper (eq==>iff) P -> P n -> P (-n) -> P (abs n).
Lemma abs_eq_cases : forall n m, abs n == abs m -> n == m \/ n == - m.
Lemma abs_lt : forall a b, abs a < b <-> -b < a < b.
Lemma abs_le : forall a b, abs a <= b <-> -b <= a <= b.
Lemma abs_triangle : forall n m, abs (n + m) <= abs n + abs m.
Lemma abs_sub_triangle : forall n m, abs n - abs m <= abs (n-m).
Lemma abs_mul : forall n m, abs (n * m) == abs n * abs m.
Lemma abs_square : forall n, abs n * abs n == n * n.
Lemma sgn_spec : forall n, 0 < n /\ sgn n == 1 \/ 0 == n /\ sgn n == 0 \/ 0 > n /\ sgn n == -1.
Lemma sgn_0 : sgn 0 == 0.
Lemma sgn_pos_iff : forall n, sgn n == 1 <-> 0<n.
Lemma sgn_null_iff : forall n, sgn n == 0 <-> n==0.
Lemma sgn_neg_iff : forall n, sgn n == -1 <-> n<0.
Lemma sgn_opp : forall n, sgn (-n) == - sgn n.
Lemma sgn_nonneg : forall n, 0 <= sgn n <-> 0 <= n.
Lemma sgn_nonpos : forall n, sgn n <= 0 <-> n <= 0.
Lemma sgn_mul : forall n m, sgn (n*m) == sgn n * sgn m.
Lemma sgn_abs : forall n, n * sgn n == abs n.
Lemma abs_sgn : forall n, abs n * sgn n == n.
Lemma sgn_sgn : forall x, sgn (sgn x) == sgn x.
Lemma spec_ww_head00  : forall x, [[x]] = 0 -> [[ww_head0 x]] = Zpos ww_Digits.
Lemma spec_ww_head0  : forall x,  0 < [[x]] ->  wwB/ 2 <= 2 ^ [[ww_head0 x]] * [[x]] < wwB.
Lemma spec_ww_tail00  : forall x, [[x]] = 0 -> [[ww_tail0 x]] = Zpos ww_Digits.
Lemma spec_ww_tail0  : forall x,  0 < [[x]] ->  exists y, 0 <= y /\ [[x]] = (2 * y + 1) * 2 ^ [[ww_tail0 x]].
Lemma spec_ww_add_mul_div_aux : forall xh xl yh yl p,  let zdigits := w_0W w_zdigits in   [[p]] <= Zpos (xO w_digits) ->     [[match ww_compare p zdigits with       | Eq => w_WW xl yh       | Lt => w_WW (w_add_mul_div (low p) xh xl)                    (w_add_mul_div (low p) xl yh)       | Gt =>             let n := low (ww_sub p zdigits) in           w_WW (w_add_mul_div n xl yh) (w_add_mul_div n yh yl)       end]] =     ([[WW xh xl]] * (2^[[p]]) +      [[WW yh yl]] / (2^(Zpos (xO w_digits) - [[p]]))) mod wwB.
Lemma spec_ww_add_mul_div : forall x y p,      [[p]] <= Zpos (xO w_digits) ->      [[ ww_add_mul_div p x y ]] =        ([[x]] * (2^[[p]]) +         [[y]] / (2^(Zpos (xO w_digits) - [[p]]))) mod wwB.
Lemma Zpower_theory : power_theory 1 Z.mul (@eq Z) Z.of_N Z.pow.
Lemma constructive_definite_description : forall (A : Type) (P : A->Prop),   (exists! x, P x) -> { x : A | P x }.
Lemma functional_choice : forall (A B : Type) (R:A->B->Prop),   (forall x : A, exists y : B, R x y) ->   (exists f : A->B, forall x : A, R x (f x)).
Lemma le_reflexive : Reflexive nat le.
Lemma le_antisym : Antisymmetric nat le.
Lemma le_trans : Transitive nat le.
Lemma le_Order : Order nat le.
Lemma triv_nat : forall n:nat, In nat Integers n.
Lemma le_total_order : Totally_ordered nat nat_po Integers.
Lemma Finite_subset_has_lub :   forall X:Ensemble nat,     Finite nat X ->  exists m : nat, Upper_Bound nat nat_po X m.
Lemma Integers_has_no_ub :   ~ (exists m : nat, Upper_Bound nat nat_po Integers m).
Lemma Integers_infinite : ~ Finite nat Integers.
Lemma Zeven_equiv z : Zeven z <-> Z.Even z.
Lemma Zodd_equiv z : Zodd z <-> Z.Odd z.
Lemma Zeven_bool_iff n : Z.even n = true <-> Zeven n.
Lemma Zodd_bool_iff n : Z.odd n = true <-> Zodd n.
Lemma Zodd_even_bool n : Z.odd n = negb (Z.even n).
Lemma Zeven_odd_bool n : Z.even n = negb (Z.odd n).
Lemma Zeven_not_Zodd n : Zeven n -> ~ Zodd n.
Lemma Zodd_not_Zeven n : Zodd n -> ~ Zeven n.
Lemma Zeven_Sn n : Zodd n -> Zeven (Z.succ n).
Lemma Zodd_Sn n : Zeven n -> Zodd (Z.succ n).
Lemma Zeven_pred n : Zodd n -> Zeven (Z.pred n).
Lemma Zodd_pred n : Zeven n -> Zodd (Z.pred n).
Lemma Zdiv2_odd_eqn n : n = 2*(Z.div2 n) + if Z.odd n then 1 else 0.
Lemma Zeven_div2 n : Zeven n -> n = 2 * Z.div2 n.
Lemma Zodd_div2 n : Zodd n -> n = 2 * Z.div2 n + 1.
Lemma Zquot2_odd_eqn n : n = 2*(Z.quot2 n) + if Z.odd n then Z.sgn n else 0.
Lemma Zeven_quot2 n : Zeven n -> n = 2 * Z.quot2 n.
Lemma Zodd_quot2 n : n >= 0 -> Zodd n -> n = 2 * Z.quot2 n + 1.
Lemma Zodd_quot2_neg n : n <= 0 -> Zodd n -> n = 2 * Z.quot2 n - 1.
Lemma Zquot2_opp n : Z.quot2 (-n) = - Z.quot2 n.
Lemma Zquot2_quot n : Z.quot2 n = n ÷ 2.
Lemma Z_modulo_2 n : {y | n = 2 * y} + {y | n = 2 * y + 1}.
Lemma Zsplit2 n : {p : Z * Z | let (x1, x2) := p in n = x1 + x2 /\ (x1 = x2 \/ x2 = x1 + 1)}.
Lemma pow_0_l : forall a, 0<a -> 0^a == 0.
Lemma pow_0_l' : forall a, a~=0 -> 0^a == 0.
Lemma pow_1_r : forall a, a^1 == a.
Lemma pow_1_l : forall a, 0<=a -> 1^a == 1.
Lemma pow_2_r : forall a, a^2 == a*a.
Lemma pow_eq_0 : forall a b, 0<=b -> a^b == 0 -> a == 0.
Lemma pow_nonzero : forall a b, a~=0 -> 0<=b -> a^b ~= 0.
Lemma pow_eq_0_iff : forall a b, a^b == 0 <-> b<0 \/ (0<b /\ a==0).
Lemma pow_add_r : forall a b c, 0<=b -> 0<=c -> a^(b+c) == a^b * a^c.
Lemma pow_mul_l : forall a b c, (a*b)^c == a^c * b^c.
Lemma pow_mul_r : forall a b c, 0<=b -> 0<=c -> a^(b*c) == (a^b)^c.
Lemma pow_nonneg : forall a b, 0<=a -> 0<=a^b.
Lemma pow_pos_nonneg : forall a b, 0<a -> 0<=b -> 0<a^b.
Lemma pow_lt_mono_l : forall a b c, 0<c -> 0<=a<b -> a^c < b^c.
Lemma pow_le_mono_l : forall a b c, 0<=a<=b -> a^c <= b^c.
Lemma pow_gt_1 : forall a b, 1<a -> (0<b <-> 1<a^b).
Lemma pow_lt_mono_r : forall a b c, 1<a -> 0<=c -> b<c -> a^b < a^c.
Lemma pow_le_mono_r : forall a b c, 0<a -> b<=c -> a^b <= a^c.
Lemma pow_le_mono : forall a b c d, 0<a<=c -> b<=d -> a^b <= c^d.
Lemma pow_lt_mono : forall a b c d, 0<a<c -> 0<b<d -> a^b < c^d.
Lemma pow_inj_l : forall a b c, 0<=a -> 0<=b -> 0<c -> a^c == b^c -> a == b.
Lemma pow_inj_r : forall a b c, 1<a -> 0<=b -> 0<=c -> a^b == a^c -> b == c.
Lemma pow_lt_mono_l_iff : forall a b c, 0<=a -> 0<=b -> 0<c -> (a<b <-> a^c < b^c).
Lemma pow_le_mono_l_iff : forall a b c, 0<=a -> 0<=b -> 0<c -> (a<=b <-> a^c <= b^c).
Lemma pow_lt_mono_r_iff : forall a b c, 1<a -> 0<=c -> (b<c <-> a^b < a^c).
Lemma pow_le_mono_r_iff : forall a b c, 1<a -> 0<=c -> (b<=c <-> a^b <= a^c).
Lemma pow_gt_lin_r : forall a b, 1<a -> 0<=b -> b < a^b.
Lemma pow_add_lower : forall a b c, 0<=a -> 0<=b -> 0<c -> a^c + b^c <= (a+b)^c.
Lemma pow_add_upper : forall a b c, 0<=a -> 0<=b -> 0<c -> (a+b)^c <= 2^(pred c) * (a^c + b^c).
Lemma spec_ww_opp_c : forall x, [-[ww_opp_c x]] = -[[x]].
Lemma spec_ww_opp : forall x, [[ww_opp x]] = (-[[x]]) mod wwB.
Lemma spec_ww_opp_carry : forall x, [[ww_opp_carry x]] = wwB - [[x]] - 1.
Lemma spec_ww_pred_c : forall x, [-[ww_pred_c x]] = [[x]] - 1.
Lemma spec_ww_sub_c : forall x y, [-[ww_sub_c x y]] = [[x]] - [[y]].
Lemma spec_ww_sub_carry_c :    forall x y, [-[ww_sub_carry_c x y]] = [[x]] - [[y]] - 1.
Lemma spec_ww_pred : forall x, [[ww_pred x]] = ([[x]] - 1) mod wwB.
Lemma spec_ww_sub : forall x y, [[ww_sub x y]] = ([[x]] - [[y]]) mod wwB.
Lemma spec_ww_sub_carry :  forall x y, [[ww_sub_carry x y]] = ([[x]] - [[y]] - 1) mod wwB.
Lemma rem_eq : forall a b, b~=0 -> a rem b == a - b*(a÷b).
Lemma rem_opp_opp : forall a b, b ~= 0 -> (-a) rem (-b) == - (a rem b).
Lemma quot_opp_l : forall a b, b ~= 0 -> (-a)÷b == -(a÷b).
Lemma quot_opp_r : forall a b, b ~= 0 -> a÷(-b) == -(a÷b).
Lemma quot_opp_opp : forall a b, b ~= 0 -> (-a)÷(-b) == a÷b.
Lemma quot_same : forall a, a~=0 -> a÷a == 1.
Lemma rem_same : forall a, a~=0 -> a rem a == 0.
Lemma quot_0_l: forall a, a~=0 -> 0÷a == 0.
Lemma rem_0_l: forall a, a~=0 -> 0 rem a == 0.
Lemma quot_1_r: forall a, a÷1 == a.
Lemma rem_1_r: forall a, a rem 1 == 0.
Lemma quot_1_l: forall a, 1<a -> 1÷a == 0.
Lemma rem_1_l: forall a, 1<a -> 1 rem a == 1.
Lemma quot_mul : forall a b, b~=0 -> (a*b)÷b == a.
Lemma rem_mul : forall a b, b~=0 -> (a*b) rem b == 0.
Lemma rem_nonneg : forall a b, b~=0 -> 0 <= a -> 0 <= a rem b.
Lemma rem_nonpos : forall a b, b~=0 -> a <= 0 -> a rem b <= 0.
Lemma rem_sign_mul : forall a b, b~=0 -> 0 <= (a rem b) * a.
Lemma rem_sign_nz : forall a b, b~=0 -> a rem b ~= 0 -> sgn (a rem b) == sgn a.
Lemma rem_sign : forall a b, a~=0 -> b~=0 -> sgn (a rem b) ~= -sgn a.
Lemma rem_abs_l : forall a b, b ~= 0 -> (abs a) rem b == abs (a rem b).
Lemma rem_abs_r : forall a b, b ~= 0 -> a rem (abs b) == a rem b.
Lemma rem_abs : forall a b,  b ~= 0 -> (abs a) rem (abs b) == abs (a rem b).
Lemma quot_abs_l : forall a b, b ~= 0 -> (abs a)÷b == (sgn a)*(a÷b).
Lemma quot_abs_r : forall a b, b ~= 0 -> a÷(abs b) == (sgn b)*(a÷b).
Lemma quot_abs : forall a b, b ~= 0 -> (abs a)÷(abs b) == abs (a÷b).
Lemma rem_bound_abs : forall a b, b~=0 -> abs (a rem b) < abs b.
Lemma quot_str_pos : forall a b, 0<b<=a -> 0 < a÷b.
Lemma quot_small_iff : forall a b, b~=0 -> (a÷b==0 <-> abs a < abs b).
Lemma rem_small_iff : forall a b, b~=0 -> (a rem b == a <-> abs a < abs b).
Lemma quot_lt : forall a b, 0<a -> 1<b -> a÷b < a.
Lemma quot_le_mono : forall a b c, 0<c -> a<=b -> a÷c <= b÷c.
Lemma mul_quot_le : forall a b, 0<=a -> b~=0 -> 0 <= b*(a÷b) <= a.
Lemma mul_quot_ge : forall a b, a<=0 -> b~=0 -> a <= b*(a÷b) <= 0.
Lemma mul_succ_quot_gt: forall a b, 0<=a -> 0<b -> a < b*(S (a÷b)).
Lemma mul_pred_quot_lt: forall a b, a<=0 -> 0<b -> b*(P (a÷b)) < a.
Lemma mul_pred_quot_gt: forall a b, 0<=a -> b<0 -> a < b*(P (a÷b)).
Lemma mul_succ_quot_lt: forall a b, a<=0 -> b<0 -> b*(S (a÷b)) < a.
Lemma quot_exact : forall a b, b~=0 -> (a == b*(a÷b) <-> a rem b == 0).
Lemma quot_le_compat_l: forall p q r, 0<=p -> 0<q<=r -> p÷r <= p÷q.
Lemma rem_add : forall a b c, c~=0 -> 0 <= (a+b*c)*a -> (a + b * c) rem c == a rem c.
Lemma quot_add : forall a b c, c~=0 -> 0 <= (a+b*c)*a -> (a + b * c) ÷ c == a ÷ c + b.
Lemma quot_add_l: forall a b c, b~=0 -> 0 <= (a*b+c)*c -> (a * b + c) ÷ b == a + c ÷ b.
Lemma quot_mul_cancel_r : forall a b c, b~=0 -> c~=0 -> (a*c)÷(b*c) == a÷b.
Lemma quot_mul_cancel_l : forall a b c, b~=0 -> c~=0 -> (c*a)÷(c*b) == a÷b.
Lemma mul_rem_distr_r: forall a b c, b~=0 -> c~=0 -> (a*c) rem (b*c) == (a rem b) * c.
Lemma mul_rem_distr_l: forall a b c, b~=0 -> c~=0 -> (c*a) rem (c*b) == c * (a rem b).
Lemma mul_rem_idemp_l : forall a b n, n~=0 -> ((a rem n)*b) rem n == (a*b) rem n.
Lemma mul_rem_idemp_r : forall a b n, n~=0 -> (a*(b rem n)) rem n == (a*b) rem n.
Lemma add_rem_idemp_l : forall a b n, n~=0 -> 0 <= a*b -> ((a rem n)+b) rem n == (a+b) rem n.
Lemma add_rem_idemp_r : forall a b n, n~=0 -> 0 <= a*b -> (a+(b rem n)) rem n == (a+b) rem n.
Lemma quot_quot : forall a b c, b~=0 -> c~=0 -> (a÷b)÷c == a÷(b*c).
Lemma mod_mul_r : forall a b c, b~=0 -> c~=0 -> a rem (b*c) == a rem b + b*((a÷b) rem c).
Lemma inverse_nat_iso : forall n : N1.t, h21 (h12 n) == n.
Lemma test_push : forall P Q R : Prop,     decidable P ->     decidable Q ->     (~ True) ->     (~ False) ->     (~ ~ P) ->     (~ (P /\ Q) -> ~ R) ->     ((P /\ Q) \/ ~ R) ->     (~ (P /\ Q) \/ R) ->     (R \/ ~ (P /\ Q)) ->     (~ R \/ (P /\ Q)) ->     (~ P -> R) ->     (~ ((R -> P) \/ (Q -> R))) ->     (~ (P /\ R)) ->     (~ (P -> R)) ->     True.
Lemma test_pull : forall P Q R : Prop,     decidable P ->     decidable Q ->     (~ True) ->     (~ False) ->     (~ ~ P) ->     (~ (P /\ Q) -> ~ R) ->     ((P /\ Q) \/ ~ R) ->     (~ (P /\ Q) \/ R) ->     (R \/ ~ (P /\ Q)) ->     (~ R \/ (P /\ Q)) ->     (~ P -> R) ->     (~ (R -> P) /\ ~ (Q -> R)) ->     (~ P \/ ~ R) ->     (P /\ ~ R) ->     (~ R /\ P) ->     True.
Lemma eq_refl_iff (x : E.t) : E.eq x x <-> True.
Lemma dec_In : forall x s,     decidable (In x s).
Lemma dec_eq : forall (x y : E.t),
Lemma test_eq_trans_1 : forall x y z s,     E.eq x y ->
Lemma test_eq_trans_2 : forall x y z r s,     In x (singleton y) ->     ~ In z r ->     ~ ~ In z (add y r) ->     In x s ->     In z s.
Lemma test_eq_neq_trans_1 : forall w x y z s,     E.eq x w ->
Lemma test_eq_neq_trans_2 : forall w x y z r1 r2 s,     In x (singleton w) ->     ~ In x r1 ->     In x (add y r1) ->     In y r2 ->     In y (remove z r2) ->     In w s ->     In w (remove z s).
Lemma test_In_singleton : forall x,     In x (singleton x).
Lemma test_add_In : forall x y s,     In x (add y s) ->     ~ E.eq x y ->
Lemma test_Subset_add_remove : forall x s,     s [<=] (add x (remove x s)).
Lemma test_eq_disjunction : forall w x y z,     In w (add x (add y (singleton z))) ->     E.eq w x \/ E.eq w y \/ E.eq w z.
Lemma test_not_In_disj : forall x y s1 s2 s3 s4,     ~ In x (union s1 (union s2 (union s3 (add y s4)))) ->     ~ (In x s1 \/ In x s4 \/ E.eq y x).
Lemma test_not_In_conj : forall x y s1 s2 s3 s4,     ~ In x (union s1 (union s2 (union s3 (add y s4)))) ->     ~ In x s1 /\ ~ In x s4 /\ ~ E.eq y x.
Lemma test_iff_conj : forall a x s s',   (In a s' <-> E.eq x a \/ In a s) ->
Lemma test_set_ops_1 : forall x q r s,     (singleton x) [<=] s ->     Empty (union q r) ->     Empty (inter (diff s q) (diff s r)) ->     ~ In x s.
Lemma eq_chain_test : forall x1 x2 x3 x4 s1 s2 s3 s4,     Empty s1 ->     In x2 (add x1 s1) ->     In x3 s2 ->     ~ In x3 (remove x2 s2) ->     ~ In x4 s3 ->     In x4 (add x3 s3) ->     In x1 s4 ->     Subset (add x4 s4) s4.
Lemma test_too_complex : forall x y z r s,     E.eq x y ->
Lemma function_test_1 :     forall (f : t -> t),     forall (g : elt -> elt),     forall (s1 s2 : t),     forall (x1 x2 : elt),     Equal s1 (f s2) ->     E.eq x1 (g (g x2)) ->
Lemma function_test_2 :     forall (f : t -> t),     forall (g : elt -> elt),     forall (s1 s2 : t),     forall (x1 x2 : elt),     Equal s1 (f s2) ->     E.eq x1 (g x2) ->
Lemma test_baydemir :     forall (f : t -> t),     forall (s : t),     forall (x y : elt),     In x (add y (f s)) ->     ~ E.eq x y ->
Lemma clos_rt_is_preorder : preorder R*.
Lemma clos_rt_idempotent : inclusion (R*)* R*.
Lemma clos_rt_clos_rst :     inclusion (clos_refl_trans R) (clos_refl_sym_trans R).
Lemma clos_rst_is_equiv : equivalence A (clos_refl_sym_trans R).
Lemma clos_rst_idempotent :     inclusion (clos_refl_sym_trans (clos_refl_sym_trans R))     (clos_refl_sym_trans R).
Lemma clos_t1n_trans : forall x y, clos_trans_1n R x y -> clos_trans R x y.
Lemma clos_trans_t1n : forall x y, clos_trans R x y -> clos_trans_1n R x y.
Lemma clos_trans_t1n_iff : forall x y,       clos_trans R x y <-> clos_trans_1n R x y.
Lemma clos_tn1_trans : forall x y, clos_trans_n1 R x y -> clos_trans R x y.
Lemma clos_trans_tn1 :  forall x y, clos_trans R x y -> clos_trans_n1 R x y.
Lemma clos_trans_tn1_iff : forall x y,       clos_trans R x y <-> clos_trans_n1 R x y.
Lemma clos_rt1n_step : forall x y, R x y -> clos_refl_trans_1n R x y.
Lemma clos_rtn1_step : forall x y, R x y -> clos_refl_trans_n1 R x y.
Lemma clos_rt1n_rt : forall x y,       clos_refl_trans_1n R x y -> clos_refl_trans R x y.
Lemma clos_rt_rt1n : forall x y,       clos_refl_trans R x y -> clos_refl_trans_1n R x y.
Lemma clos_rt_rt1n_iff : forall x y,     clos_refl_trans R x y <-> clos_refl_trans_1n R x y.
Lemma clos_rtn1_rt : forall x y,       clos_refl_trans_n1 R x y -> clos_refl_trans R x y.
Lemma clos_rt_rtn1 :  forall x y,       clos_refl_trans R x y -> clos_refl_trans_n1 R x y.
Lemma clos_rt_rtn1_iff : forall x y,       clos_refl_trans R x y <-> clos_refl_trans_n1 R x y.
Lemma clos_refl_trans_ind_left :     forall (x:A) (P:A -> Prop), P x -> (forall y z:A, clos_refl_trans R x y -> P y -> R y z -> P z) -> forall z:A, clos_refl_trans R x z -> P z.
Lemma rt1n_ind_right : forall (P : A -> Prop) (z:A),     P z ->     (forall x y, R x y -> clos_refl_trans_1n R y z -> P y -> P x) ->     forall x, clos_refl_trans_1n R x z -> P x.
Lemma clos_refl_trans_ind_right : forall (P : A -> Prop) (z:A),     P z ->     (forall x y, R x y -> P y -> clos_refl_trans R y z -> P x) ->     forall x, clos_refl_trans R x z -> P x.
Lemma clos_rst1n_rst  : forall x y,     clos_refl_sym_trans_1n R x y -> clos_refl_sym_trans R x y.
Lemma clos_rst1n_trans : forall x y z, clos_refl_sym_trans_1n R x y ->       clos_refl_sym_trans_1n R y z -> clos_refl_sym_trans_1n R x z.
Lemma clos_rst1n_sym : forall x y, clos_refl_sym_trans_1n R x y ->     clos_refl_sym_trans_1n R y x.
Lemma clos_rst_rst1n  : forall x y,     clos_refl_sym_trans R x y -> clos_refl_sym_trans_1n R x y.
Lemma clos_rst_rst1n_iff : forall x y,     clos_refl_sym_trans R x y <-> clos_refl_sym_trans_1n R x y.
Lemma clos_rstn1_rst : forall x y,     clos_refl_sym_trans_n1 R x y -> clos_refl_sym_trans R x y.
Lemma clos_rstn1_trans : forall x y z, clos_refl_sym_trans_n1 R x y ->     clos_refl_sym_trans_n1 R y z -> clos_refl_sym_trans_n1 R x z.
Lemma clos_rstn1_sym : forall x y, clos_refl_sym_trans_n1 R x y ->     clos_refl_sym_trans_n1 R y x.
Lemma clos_rst_rstn1 : forall x y,     clos_refl_sym_trans R x y -> clos_refl_sym_trans_n1 R x y.
Lemma clos_rst_rstn1_iff : forall x y,     clos_refl_sym_trans R x y <-> clos_refl_sym_trans_n1 R x y.
Lemma In_dec : forall x s, {In x s} + {~ In x s}.
Lemma Add_Equal : forall x s s', Add x s s' <-> s' [=] add x s.
Lemma equal_refl : s[=]s.
Lemma equal_sym : s[=]s' -> s'[=]s.
Lemma equal_trans : s1[=]s2 -> s2[=]s3 -> s1[=]s3.
Lemma subset_refl : s[<=]s.
Lemma subset_trans : s1[<=]s2 -> s2[<=]s3 -> s1[<=]s3.
Lemma subset_antisym : s[<=]s' -> s'[<=]s -> s[=]s'.
Lemma subset_equal : s[=]s' -> s[<=]s'.
Lemma subset_empty : empty[<=]s.
Lemma subset_remove_3 : s1[<=]s2 -> remove x s1 [<=] s2.
Lemma subset_diff : s1[<=]s3 -> diff s1 s2 [<=] s3.
Lemma subset_add_3 : In x s2 -> s1[<=]s2 -> add x s1 [<=] s2.
Lemma subset_add_2 : s1[<=]s2 -> s1[<=] add x s2.
Lemma in_subset : In x s1 -> s1[<=]s2 -> In x s2.
Lemma double_inclusion : s1[=]s2 <-> s1[<=]s2 /\ s2[<=]s1.
Lemma empty_is_empty_1 : Empty s -> s[=]empty.
Lemma empty_is_empty_2 : s[=]empty -> Empty s.
Lemma add_equal : In x s -> add x s [=] s.
Lemma add_add : add x (add x' s) [=] add x' (add x s).
Lemma remove_equal : ~ In x s -> remove x s [=] s.
Lemma Equal_remove : s[=]s' -> remove x s [=] remove x s'.
Lemma add_remove : In x s -> add x (remove x s) [=] s.
Lemma remove_add : ~In x s -> remove x (add x s) [=] s.
Lemma singleton_equal_add : singleton x [=] add x empty.
Lemma remove_singleton_empty :  In x s -> remove x s [=] empty -> singleton x [=] s.
Lemma union_sym : union s s' [=] union s' s.
Lemma union_subset_equal : s[<=]s' -> union s s' [=] s'.
Lemma union_equal_1 : s[=]s' -> union s s'' [=] union s' s''.
Lemma union_equal_2 : s'[=]s'' -> union s s' [=] union s s''.
Lemma union_assoc : union (union s s') s'' [=] union s (union s' s'').
Lemma add_union_singleton : add x s [=] union (singleton x) s.
Lemma union_add : union (add x s) s' [=] add x (union s s').
Lemma union_remove_add_1 :  union (remove x s) (add x s') [=] union (add x s) (remove x s').
Lemma union_remove_add_2 : In x s ->  union (remove x s) (add x s') [=] union s s'.
Lemma union_subset_1 : s [<=] union s s'.
Lemma union_subset_2 : s' [<=] union s s'.
Lemma union_subset_3 : s[<=]s'' -> s'[<=]s'' -> union s s' [<=] s''.
Lemma union_subset_4 : s[<=]s' -> union s s'' [<=] union s' s''.
Lemma union_subset_5 : s[<=]s' -> union s'' s [<=] union s'' s'.
Lemma empty_union_1 : Empty s -> union s s' [=] s'.
Lemma empty_union_2 : Empty s -> union s' s [=] s'.
Lemma not_in_union : ~In x s -> ~In x s' -> ~In x (union s s').
Lemma inter_sym : inter s s' [=] inter s' s.
Lemma inter_subset_equal : s[<=]s' -> inter s s' [=] s.
Lemma inter_equal_1 : s[=]s' -> inter s s'' [=] inter s' s''.
Lemma inter_equal_2 : s'[=]s'' -> inter s s' [=] inter s s''.
Lemma inter_assoc : inter (inter s s') s'' [=] inter s (inter s' s'').
Lemma union_inter_1 : inter (union s s') s'' [=] union (inter s s'') (inter s' s'').
Lemma union_inter_2 : union (inter s s') s'' [=] inter (union s s'') (union s' s'').
Lemma inter_add_1 : In x s' -> inter (add x s) s' [=] add x (inter s s').
Lemma inter_add_2 : ~ In x s' -> inter (add x s) s' [=] inter s s'.
Lemma empty_inter_1 : Empty s -> Empty (inter s s').
Lemma empty_inter_2 : Empty s' -> Empty (inter s s').
Lemma inter_subset_1 : inter s s' [<=] s.
Lemma inter_subset_2 : inter s s' [<=] s'.
Lemma inter_subset_3 :  s''[<=]s -> s''[<=]s' -> s''[<=] inter s s'.
Lemma empty_diff_1 : Empty s -> Empty (diff s s').
Lemma empty_diff_2 : Empty s -> diff s' s [=] s'.
Lemma diff_subset : diff s s' [<=] s.
Lemma diff_subset_equal : s[<=]s' -> diff s s' [=] empty.
Lemma remove_diff_singleton :  remove x s [=] diff s (singleton x).
Lemma diff_inter_empty : inter (diff s s') (inter s s') [=] empty.
Lemma diff_inter_all : union (diff s s') (inter s s') [=] s.
Lemma Add_add : Add x s (add x s).
Lemma Add_remove : In x s -> Add x (remove x s) s.
Lemma union_Add : Add x s s' -> Add x (union s s'') (union s' s'').
Lemma inter_Add :  In x s'' -> Add x s s' -> Add x (inter s s'') (inter s' s'').
Lemma union_Equal :  In x s'' -> Add x s s' -> union s s'' [=] union s' s''.
Lemma inter_Add_2 :  ~In x s'' -> Add x s s' -> inter s s'' [=] inter s' s''.
Lemma elements_Empty : forall s, Empty s <-> elements s = nil.
Lemma elements_empty : elements empty = nil.
Lemma of_list_1 : forall l x, In x (of_list l) <-> InA E.eq x l.
Lemma of_list_2 : forall l, equivlistA E.eq (to_list (of_list l)) l.
Lemma of_list_3 : forall s, of_list (to_list s) [=] s.
Lemma fold_spec_right (s:t)(A:Type)(i:A)(f : elt -> A -> A) :   fold f s i = List.fold_right f i (rev (elements s)).
Lemma fold_rec_nodep :   forall (A:Type)(P : A -> Type)(f : elt -> A -> A)(i:A)(s:t),    P i -> (forall x a, In x s -> P a -> P (f x a)) ->    P (fold f s i).
Lemma fold_rec_weak :   forall (A:Type)(P : t -> A -> Type)(f : elt -> A -> A)(i:A),   (forall s s' a, s[=]s' -> P s a -> P s' a) ->   P empty i ->   (forall x a s, ~In x s -> P s a -> P (add x s) (f x a)) ->   forall s, P s (fold f s i).
Lemma fold_rel :   forall (A B:Type)(R : A -> B -> Type)    (f : elt -> A -> A)(g : elt -> B -> B)(i : A)(j : B)(s : t),    R i j ->    (forall x a b, In x s -> R a b -> R (f x a) (g x b)) ->    R (fold f s i) (fold g s j).
Lemma set_induction :  forall P : t -> Type,  (forall s, Empty s -> P s) ->  (forall s s', P s -> forall x, ~In x s -> Add x s s' -> P s') ->  forall s, P s.
Lemma set_induction_bis :  forall P : t -> Type,  (forall s s', s [=] s' -> P s -> P s') ->  P empty ->  (forall x s, ~In x s -> P s -> P (add x s)) ->  forall s, P s.
Lemma fold_identity : forall s, fold add s empty [=] s.
Lemma fold_0 :     forall s (A : Type) (i : A) (f : elt -> A -> A),     exists l : list elt,       NoDup l /\       (forall x : elt, In x s <-> InA x l) /\       fold f s i = fold_right f i l.
Lemma fold_1 :  forall s (A : Type) (eqA : A -> A -> Prop)    (st : Equivalence eqA) (i : A) (f : elt -> A -> A),  Empty s -> eqA (fold f s i) i.
Lemma fold_2 :  forall s s' x (A : Type) (eqA : A -> A -> Prop)    (st : Equivalence eqA) (i : A) (f : elt -> A -> A),  compat_op E.eq eqA f ->
Lemma fold_1b :  forall s (A : Type)(i : A) (f : elt -> A -> A),  Empty s -> (fold f s i) = i.
Lemma fold_commutes : forall i s x,  eqA (fold f s (f x i)) (f x (fold f s i)).
Lemma fold_init : forall i i' s, eqA i i' ->  eqA (fold f s i) (fold f s i').
Lemma fold_equal :  forall i s s', s[=]s' -> eqA (fold f s i) (fold f s' i).
Lemma fold_empty : forall i, fold f empty i = i.
Lemma fold_add : forall i s x, ~In x s ->  eqA (fold f (add x s) i) (f x (fold f s i)).
Lemma add_fold : forall i s x, In x s ->  eqA (fold f (add x s) i) (fold f s i).
Lemma remove_fold_1: forall i s x, In x s ->  eqA (f x (fold f (remove x s) i)) (fold f s i).
Lemma remove_fold_2: forall i s x, ~In x s ->  eqA (fold f (remove x s) i) (fold f s i).
Lemma fold_union_inter : forall i s s',  eqA (fold f (union s s') (fold f (inter s s') i))      (fold f s (fold f s' i)).
Lemma fold_diff_inter : forall i s s',  eqA (fold f (diff s s') (fold f (inter s s') i)) (fold f s i).
Lemma fold_union: forall i s s',  (forall x, ~(In x s/\In x s')) ->  eqA (fold f (union s s') i) (fold f s (fold f s' i)).
Lemma fold_plus :  forall s p, fold (fun _ => S) s p = fold (fun _ => S) s 0 + p.
Lemma cardinal_fold : forall s, cardinal s = fold (fun _ => S) s 0.
Lemma cardinal_0 :    forall s, exists l : list elt,       NoDupA E.eq l /\
Lemma cardinal_1 : forall s, Empty s -> cardinal s = 0.
Lemma cardinal_2 :   forall s s' x, ~ In x s -> Add x s s' -> cardinal s' = S (cardinal s).
Lemma cardinal_Empty : forall s, Empty s <-> cardinal s = 0.
Lemma cardinal_inv_1 : forall s, cardinal s = 0 -> Empty s.
Lemma cardinal_inv_2 :  forall s n, cardinal s = S n -> { x : elt | In x s }.
Lemma cardinal_inv_2b :  forall s, cardinal s <> 0 -> { x : elt | In x s }.
Lemma Equal_cardinal : forall s s', s[=]s' -> cardinal s = cardinal s'.
Lemma empty_cardinal : cardinal empty = 0.
Lemma singleton_cardinal : forall x, cardinal (singleton x) = 1.
Lemma diff_inter_cardinal :  forall s s', cardinal (diff s s') + cardinal (inter s s') = cardinal s .
Lemma union_cardinal:  forall s s', (forall x, ~(In x s/\In x s')) ->  cardinal (union s s')=cardinal s+cardinal s'.
Lemma subset_cardinal :  forall s s', s[<=]s' -> cardinal s <= cardinal s' .
Lemma subset_cardinal_lt :  forall s s' x, s[<=]s' -> In x s' -> ~In x s -> cardinal s < cardinal s'.
Lemma union_cardinal_inter :  forall s s', cardinal (union s s') = cardinal s + cardinal s' - cardinal (inter s s').
Lemma union_cardinal_le :  forall s s', cardinal (union s s') <= cardinal s  + cardinal s'.
Lemma add_cardinal_1 :  forall s x, In x s -> cardinal (add x s) = cardinal s.
Lemma add_cardinal_2 :  forall s x, ~In x s -> cardinal (add x s) = S (cardinal s).
Lemma remove_cardinal_1 :  forall s x, In x s -> S (cardinal (remove x s)) = cardinal s.
Lemma remove_cardinal_2 :  forall s x, ~In x s -> cardinal (remove x s) = cardinal s.
Lemma sort_equivlistA_eqlistA : forall l l' : list elt,  sort E.lt l -> sort E.lt l' -> equivlistA E.eq l l' -> eqlistA E.eq l l'.
Lemma gtb_1 : forall x y, gtb x y = true <-> E.lt y x.
Lemma leb_1 : forall x y, leb x y = true <-> ~E.lt y x.
Lemma gtb_compat : forall x, Proper (E.eq==>Logic.eq) (gtb x).
Lemma leb_compat : forall x, Proper (E.eq==>Logic.eq) (leb x).
Lemma elements_split : forall x s,  elements s = elements_lt x s ++ elements_ge x s.
Lemma elements_Add : forall s s' x, ~In x s -> Add x s s' ->   eqlistA E.eq (elements s') (elements_lt x s ++ x :: elements_ge x s).
Lemma elements_Add_Above : forall s s' x,  Above x s -> Add x s s' ->    eqlistA E.eq (elements s') (elements s ++ x::nil).
Lemma elements_Add_Below : forall s s' x,  Below x s -> Add x s s' ->    eqlistA E.eq (elements s') (x::elements s).
Lemma set_induction_max :  forall P : t -> Type,  (forall s : t, Empty s -> P s) ->  (forall s s', P s -> forall x, Above x s -> Add x s s' -> P s') ->  forall s : t, P s.
Lemma set_induction_min :  forall P : t -> Type,  (forall s : t, Empty s -> P s) ->  (forall s s', P s -> forall x, Below x s -> Add x s s' -> P s') ->  forall s : t, P s.
Lemma fold_3 :  forall s s' x (A : Type) (eqA : A -> A -> Prop)    (st : Equivalence eqA) (i : A) (f : elt -> A -> A),  compat_op E.eq eqA f ->
Lemma fold_4 :  forall s s' x (A : Type) (eqA : A -> A -> Prop)    (st : Equivalence eqA) (i : A) (f : elt -> A -> A),  compat_op E.eq eqA f ->
Lemma fold_equal :  forall i s s', s[=]s' -> eqA (fold f s i) (fold f s' i).
Lemma add_fold : forall i s x, In x s ->  eqA (fold f (add x s) i) (fold f s i).
Lemma remove_fold_2: forall i s x, ~In x s ->  eqA (fold f (remove x s) i) (fold f s i).
Lemma choose_equal : forall s s', Equal s s' ->   match choose s, choose s' with     | Some x, Some x' => E.eq x x'
Lemma bits_lt_antirefl : forall x : positive, ~ bits_lt x x.
Lemma bits_lt_trans :   forall x y z : positive, bits_lt x y -> bits_lt y z -> bits_lt x z.
Lemma compare_spec : forall x y, CompSpec eq lt x y (compare x y).
Lemma mem_spec: forall s x, mem x s = true <-> In x s.
Lemma mem_Leaf: forall x, mem x Leaf = false.
Lemma empty_spec : Empty empty.
Lemma mem_node: forall x l o r, mem x (node l o r) = mem x (Node l o r).
Lemma is_empty_spec: forall s, is_empty s = true <-> Empty s.
Lemma subset_Leaf_s: forall s, Leaf [<=] s.
Lemma subset_spec: forall s s', subset s s' = true <-> s [<=] s'.
Lemma equal_subset: forall s s', equal s s' = subset s s' && subset s' s.
Lemma equal_spec: forall s s', equal s s' = true <-> Equal s s'.
Lemma eq_dec : forall s s', { eq s s' } + { ~ eq s s' }.
Lemma lex_Opp: forall u v u' v', u = CompOpp u' -> v = CompOpp v' ->   lex u v = CompOpp (lex u' v').
Lemma compare_bool_inv: forall b b',   compare_bool b b' = CompOpp (compare_bool b' b).
Lemma compare_inv: forall s s', compare s s' = CompOpp (compare s' s).
Lemma lex_Eq: forall u v, lex u v = Eq <-> u=Eq /\ v=Eq.
Lemma compare_bool_Eq: forall b1 b2,   compare_bool b1 b2 = Eq <-> eqb b1 b2 = true.
Lemma compare_equal: forall s s', compare s s' = Eq <-> equal s s' = true.
Lemma compare_gt: forall s s', compare s s' = Gt -> lt s' s.
Lemma compare_eq: forall s s', compare s s' = Eq -> eq s s'.
Lemma compare_spec : forall s s' : t, CompSpec eq lt s s' (compare s s').
Lemma ct_cxe: forall x, ct (CompOpp x) x Eq.
Lemma ct_xce: forall x, ct x (CompOpp x) Eq.
Lemma ct_lxl: forall x, ct Lt x Lt.
Lemma ct_gxg: forall x, ct Gt x Gt.
Lemma ct_xll: forall x, ct x Lt Lt.
Lemma ct_xgg: forall x, ct x Gt Gt.
Lemma ct_lex: forall u v w u' v' w',   ct u v w -> ct u' v' w' -> ct (lex u u') (lex v v') (lex w w').
Lemma ct_compare_bool:   forall a b c, ct (compare_bool a b) (compare_bool b c) (compare_bool a c).
Lemma compare_x_Leaf: forall s,   compare s Leaf = if is_empty s then Eq else Gt.
Lemma compare_empty_x: forall a, is_empty a = true ->   forall b, compare a b = if is_empty b then Eq else Lt.
Lemma compare_x_empty: forall a, is_empty a = true ->   forall b, compare b a = if is_empty b then Eq else Gt.
Lemma ct_compare:   forall a b c, ct (compare a b) (compare b c) (compare a c).
Lemma add_spec: forall s x y, In y (add x s) <-> y=x \/ In y s.
Lemma remove_spec: forall s x y, In y (remove x s) <-> In y s /\ y<>x.
Lemma singleton_spec : forall x y, In y (singleton x) <-> y=x.
Lemma union_spec: forall s s' x, In x (union s s') <-> In x s \/ In x s'.
Lemma inter_spec: forall s s' x, In x (inter s s') <-> In x s /\ In x s'.
Lemma diff_spec: forall s s' x, In x (diff s s') <-> In x s /\ ~ In x s'.
Lemma fold_spec: forall s (A : Type) (i : A) (f : elt -> A -> A),     fold f s i = fold_left (fun a e => f e a) (elements s) i.
Lemma cardinal_spec: forall s, cardinal s = length (elements s).
Lemma xfilter_spec: forall f s x i,   In x (xfilter f s i) <-> In x s /\ f (i@x) = true.
Lemma filter_spec: forall s x f, compat_bool E.eq f ->
Lemma xforall_spec: forall f s i,   xforall f s i = true <-> For_all (fun x => f (i@x) = true) s.
Lemma for_all_spec: forall s f, compat_bool E.eq f ->
Lemma xexists_spec: forall f s i,   xexists f s i = true <-> Exists (fun x => f (i@x) = true) s.
Lemma exists_spec : forall s f, compat_bool E.eq f ->
Lemma partition_filter : forall s f,   partition f s = (filter f s, filter (fun x => negb (f x)) s).
Lemma partition_spec1 : forall s f, compat_bool E.eq f ->
Lemma partition_spec2 : forall s f, compat_bool E.eq f ->
Lemma xelements_spec: forall s j acc y,   InL y (xelements s j acc)   <->   InL y acc \/ exists x, y=(j@x) /\ mem x s = true.
Lemma elements_spec1: forall s x, InL x (elements s) <-> In x s.
Lemma lt_rev_append: forall j x y, E.lt x y -> E.lt (j@x) (j@y).
Lemma elements_spec2: forall s, sort E.lt (elements s).
Lemma elements_spec2w: forall s, NoDupA E.eq (elements s).
Lemma choose_spec1: forall s x, choose s = Some x -> In x s.
Lemma choose_spec2: forall s, choose s = None -> Empty s.
Lemma choose_empty: forall s, is_empty s = true -> choose s = None.
Lemma choose_spec3': forall s s', Equal s s' -> choose s = choose s'.
Lemma choose_spec3: forall s s' x y,   choose s = Some x -> choose s' = Some y -> Equal s s' -> E.eq x y.
Lemma min_elt_spec1: forall s x, min_elt s = Some x -> In x s.
Lemma min_elt_spec3: forall s, min_elt s = None -> Empty s.
Lemma min_elt_spec2: forall s x y, min_elt s = Some x -> In y s -> ~ E.lt y x.
Lemma max_elt_spec1: forall s x, max_elt s = Some x -> In x s.
Lemma max_elt_spec3: forall s, max_elt s = None -> Empty s.
Lemma max_elt_spec2: forall s x y, max_elt s = Some x -> In y s -> ~ E.lt x y.
Lemma eq_rect_eq :     forall (U:Type) (p:U) (Q:U -> Type) (x:Q p) (h:p = p),       x = eq_rect p Q x p h.
Lemma subset_eq_compat :   forall (U:Set) (P:U->Prop) (x y:U) (p:P x) (q:P y),     x = y -> exist P x p = exist P y q.
Lemma subsetT_eq_compat :   forall (U:Type) (P:U->Prop) (x y:U) (p:P x) (q:P y),     x = y -> existT P x p = existT P y q.
Lemma RLegacyTheory : Ring_Theory Rplus Rmult 1 0 Ropp (fun x y:R => false).
Lemma continuity_pt_plus : forall f1 f2 (x0:R),   continuity_pt f1 x0 -> continuity_pt f2 x0 -> continuity_pt (f1 + f2) x0.
Lemma continuity_pt_opp : forall f (x0:R), continuity_pt f x0 -> continuity_pt (- f) x0.
Lemma continuity_pt_minus : forall f1 f2 (x0:R),   continuity_pt f1 x0 -> continuity_pt f2 x0 -> continuity_pt (f1 - f2) x0.
Lemma continuity_pt_mult : forall f1 f2 (x0:R),   continuity_pt f1 x0 -> continuity_pt f2 x0 -> continuity_pt (f1 * f2) x0.
Lemma continuity_pt_const : forall f (x0:R), constant f -> continuity_pt f x0.
Lemma continuity_pt_scal : forall f (a x0:R),   continuity_pt f x0 -> continuity_pt (mult_real_fct a f) x0.
Lemma continuity_pt_inv : forall f (x0:R), continuity_pt f x0 -> f x0 <> 0 -> continuity_pt (/ f) x0.
Lemma div_eq_inv : forall f1 f2, (f1 / f2)%F = (f1 * / f2)%F.
Lemma continuity_pt_div : forall f1 f2 (x0:R),   continuity_pt f1 x0 ->   continuity_pt f2 x0 -> f2 x0 <> 0 -> continuity_pt (f1 / f2) x0.
Lemma continuity_pt_comp : forall f1 f2 (x:R),   continuity_pt f1 x -> continuity_pt f2 (f1 x) -> continuity_pt (f2 o f1) x.
Lemma continuity_plus : forall f1 f2, continuity f1 -> continuity f2 -> continuity (f1 + f2).
Lemma continuity_opp : forall f, continuity f -> continuity (- f).
Lemma continuity_minus : forall f1 f2, continuity f1 -> continuity f2 -> continuity (f1 - f2).
Lemma continuity_mult : forall f1 f2, continuity f1 -> continuity f2 -> continuity (f1 * f2).
Lemma continuity_const : forall f, constant f -> continuity f.
Lemma continuity_scal : forall f (a:R), continuity f -> continuity (mult_real_fct a f).
Lemma continuity_inv : forall f, continuity f -> (forall x:R, f x <> 0) -> continuity (/ f).
Lemma continuity_div : forall f1 f2,   continuity f1 ->   continuity f2 -> (forall x:R, f2 x <> 0) -> continuity (f1 / f2).
Lemma continuity_comp : forall f1 f2, continuity f1 -> continuity f2 -> continuity (f2 o f1).
Lemma uniqueness_step1 : forall f (x l1 l2:R),   limit1_in (fun h:R => (f (x + h) - f x) / h) (fun h:R => h <> 0) l1 0 ->   limit1_in (fun h:R => (f (x + h) - f x) / h) (fun h:R => h <> 0) l2 0 ->   l1 = l2.
Lemma uniqueness_step2 : forall f (x l:R),   derivable_pt_lim f x l ->   limit1_in (fun h:R => (f (x + h) - f x) / h) (fun h:R => h <> 0) l 0.
Lemma uniqueness_step3 : forall f (x l:R),   limit1_in (fun h:R => (f (x + h) - f x) / h) (fun h:R => h <> 0) l 0 ->   derivable_pt_lim f x l.
Lemma uniqueness_limite : forall f (x l1 l2:R),   derivable_pt_lim f x l1 -> derivable_pt_lim f x l2 -> l1 = l2.
Lemma derive_pt_eq : forall f (x l:R) (pr:derivable_pt f x),   derive_pt f x pr = l <-> derivable_pt_lim f x l.
Lemma derive_pt_eq_0 : forall f (x l:R) (pr:derivable_pt f x),   derivable_pt_lim f x l -> derive_pt f x pr = l.
Lemma derive_pt_eq_1 : forall f (x l:R) (pr:derivable_pt f x),   derive_pt f x pr = l -> derivable_pt_lim f x l.
Lemma derive_pt_D_in : forall f (df:R -> R) (x:R) (pr:derivable_pt f x),   D_in f df no_cond x <-> derive_pt f x pr = df x.
Lemma derivable_pt_lim_D_in : forall f (df:R -> R) (x:R),   D_in f df no_cond x <-> derivable_pt_lim f x (df x).
Lemma derivable_derive : forall f (x:R) (pr:derivable_pt f x),  exists l : R, derive_pt f x pr = l.
Lemma derivable_pt_lim_plus : forall f1 f2 (x l1 l2:R),   derivable_pt_lim f1 x l1 ->   derivable_pt_lim f2 x l2 -> derivable_pt_lim (f1 + f2) x (l1 + l2).
Lemma derivable_pt_lim_opp : forall f (x l:R), derivable_pt_lim f x l -> derivable_pt_lim (- f) x (- l).
Lemma derivable_pt_lim_minus : forall f1 f2 (x l1 l2:R),   derivable_pt_lim f1 x l1 ->   derivable_pt_lim f2 x l2 -> derivable_pt_lim (f1 - f2) x (l1 - l2).
Lemma derivable_pt_lim_mult : forall f1 f2 (x l1 l2:R),   derivable_pt_lim f1 x l1 ->   derivable_pt_lim f2 x l2 ->   derivable_pt_lim (f1 * f2) x (l1 * f2 x + f1 x * l2).
Lemma derivable_pt_lim_const : forall a x:R, derivable_pt_lim (fct_cte a) x 0.
Lemma derivable_pt_lim_scal : forall f (a x l:R),   derivable_pt_lim f x l -> derivable_pt_lim (mult_real_fct a f) x (a * l).
Lemma derivable_pt_lim_id : forall x:R, derivable_pt_lim id x 1.
Lemma derivable_pt_lim_Rsqr : forall x:R, derivable_pt_lim Rsqr x (2 * x).
Lemma derivable_pt_lim_comp : forall f1 f2 (x l1 l2:R),   derivable_pt_lim f1 x l1 ->   derivable_pt_lim f2 (f1 x) l2 -> derivable_pt_lim (f2 o f1) x (l2 * l1).
Lemma derivable_pt_plus : forall f1 f2 (x:R),   derivable_pt f1 x -> derivable_pt f2 x -> derivable_pt (f1 + f2) x.
Lemma derivable_pt_opp : forall f (x:R), derivable_pt f x -> derivable_pt (- f) x.
Lemma derivable_pt_minus : forall f1 f2 (x:R),   derivable_pt f1 x -> derivable_pt f2 x -> derivable_pt (f1 - f2) x.
Lemma derivable_pt_mult : forall f1 f2 (x:R),   derivable_pt f1 x -> derivable_pt f2 x -> derivable_pt (f1 * f2) x.
Lemma derivable_pt_const : forall a x:R, derivable_pt (fct_cte a) x.
Lemma derivable_pt_scal : forall f (a x:R), derivable_pt f x -> derivable_pt (mult_real_fct a f) x.
Lemma derivable_pt_id : forall x:R, derivable_pt id x.
Lemma derivable_pt_Rsqr : forall x:R, derivable_pt Rsqr x.
Lemma derivable_pt_comp : forall f1 f2 (x:R),   derivable_pt f1 x -> derivable_pt f2 (f1 x) -> derivable_pt (f2 o f1) x.
Lemma derivable_plus : forall f1 f2, derivable f1 -> derivable f2 -> derivable (f1 + f2).
Lemma derivable_opp : forall f, derivable f -> derivable (- f).
Lemma derivable_minus : forall f1 f2, derivable f1 -> derivable f2 -> derivable (f1 - f2).
Lemma derivable_mult : forall f1 f2, derivable f1 -> derivable f2 -> derivable (f1 * f2).
Lemma derivable_const : forall a:R, derivable (fct_cte a).
Lemma derivable_scal : forall f (a:R), derivable f -> derivable (mult_real_fct a f).
Lemma derivable_id : derivable id.
Lemma derivable_Rsqr : derivable Rsqr.
Lemma derivable_comp : forall f1 f2, derivable f1 -> derivable f2 -> derivable (f2 o f1).
Lemma derive_pt_plus : forall f1 f2 (x:R) (pr1:derivable_pt f1 x) (pr2:derivable_pt f2 x),   derive_pt (f1 + f2) x (derivable_pt_plus _ _ _ pr1 pr2) =   derive_pt f1 x pr1 + derive_pt f2 x pr2.
Lemma derive_pt_opp : forall f (x:R) (pr1:derivable_pt f x),   derive_pt (- f) x (derivable_pt_opp _ _ pr1) = - derive_pt f x pr1.
Lemma derive_pt_minus : forall f1 f2 (x:R) (pr1:derivable_pt f1 x) (pr2:derivable_pt f2 x),   derive_pt (f1 - f2) x (derivable_pt_minus _ _ _ pr1 pr2) =   derive_pt f1 x pr1 - derive_pt f2 x pr2.
Lemma derive_pt_mult : forall f1 f2 (x:R) (pr1:derivable_pt f1 x) (pr2:derivable_pt f2 x),   derive_pt (f1 * f2) x (derivable_pt_mult _ _ _ pr1 pr2) =   derive_pt f1 x pr1 * f2 x + f1 x * derive_pt f2 x pr2.
Lemma derive_pt_const : forall a x:R, derive_pt (fct_cte a) x (derivable_pt_const a x) = 0.
Lemma derive_pt_scal : forall f (a x:R) (pr:derivable_pt f x),   derive_pt (mult_real_fct a f) x (derivable_pt_scal _ _ _ pr) =   a * derive_pt f x pr.
Lemma derive_pt_id : forall x:R, derive_pt id x (derivable_pt_id _) = 1.
Lemma derive_pt_Rsqr : forall x:R, derive_pt Rsqr x (derivable_pt_Rsqr _) = 2 * x.
Lemma derive_pt_comp : forall f1 f2 (x:R) (pr1:derivable_pt f1 x) (pr2:derivable_pt f2 (f1 x)),   derive_pt (f2 o f1) x (derivable_pt_comp _ _ _ pr1 pr2) =   derive_pt f2 (f1 x) pr2 * derive_pt f1 x pr1.
Lemma derivable_pt_lim_pow_pos : forall (x:R) (n:nat),   (0 < n)%nat -> derivable_pt_lim (fun y:R => y ^ n) x (INR n * x ^ pred n).
Lemma derivable_pt_lim_pow : forall (x:R) (n:nat),   derivable_pt_lim (fun y:R => y ^ n) x (INR n * x ^ pred n).
Lemma derivable_pt_pow : forall (n:nat) (x:R), derivable_pt (fun y:R => y ^ n) x.
Lemma derivable_pow : forall n:nat, derivable (fun y:R => y ^ n).
Lemma derive_pt_pow : forall (n:nat) (x:R),   derive_pt (fun y:R => y ^ n) x (derivable_pt_pow n x) = INR n * x ^ pred n.
Lemma pr_nu : forall f (x:R) (pr1 pr2:derivable_pt f x),   derive_pt f x pr1 = derive_pt f x pr2.
Lemma nonneg_derivative_0 : forall f (pr:derivable f),   increasing f -> forall x:R, 0 <= derive_pt f x (pr x).
Lemma derivable_pt_div : forall (f1 f2:R -> R) (x:R),   derivable_pt f1 x ->   derivable_pt f2 x -> f2 x <> 0 -> derivable_pt (f1 / f2) x.
Lemma derivable_div : forall f1 f2:R -> R,   derivable f1 ->   derivable f2 -> (forall x:R, f2 x <> 0) -> derivable (f1 / f2).
Lemma derive_pt_div : forall (f1 f2:R -> R) (x:R) (pr1:derivable_pt f1 x)   (pr2:derivable_pt f2 x) (na:f2 x <> 0),   derive_pt (f1 / f2) x (derivable_pt_div _ _ _ pr1 pr2 na) =   (derive_pt f1 x pr1 * f2 x - derive_pt f2 x pr2 * f1 x) / Rsqr (f2 x).
Lemma sincl_add_x :   forall (A B:Ensemble U) (x:U),     ~ In U A x ->     Strict_Included U (Add U A x) (Add U B x) -> Strict_Included U A B.
Lemma incl_soustr_in :   forall (X:Ensemble U) (x:U), In U X x -> Included U (Subtract U X x) X.
Lemma incl_soustr :   forall (X Y:Ensemble U) (x:U),     Included U X Y -> Included U (Subtract U X x) (Subtract U Y x).
Lemma incl_soustr_add_l :   forall (X:Ensemble U) (x:U), Included U (Subtract U (Add U X x) x) X.
Lemma incl_soustr_add_r :   forall (X:Ensemble U) (x:U),     ~ In U X x -> Included U X (Subtract U (Add U X x) x).
Lemma add_soustr_2 :   forall (X:Ensemble U) (x:U),     In U X x -> Included U X (Add U (Subtract U X x) x).
Lemma add_soustr_1 :   forall (X:Ensemble U) (x:U),     In U X x -> Included U (Add U (Subtract U X x) x) X.
Lemma add_soustr_xy :   forall (X:Ensemble U) (x y:U),     x <> y -> Subtract U (Add U X x) y = Add U (Subtract U X y) x.
Lemma incl_st_add_soustr :   forall (X Y:Ensemble U) (x:U),     ~ In U X x ->     Strict_Included U (Add U X x) Y -> Strict_Included U X (Subtract U Y x).
Lemma Sub_Add_new :   forall (X:Ensemble U) (x:U), ~ In U X x -> X = Subtract U (Add U X x) x.
Lemma Simplify_add :   forall (X X0:Ensemble U) (x:U),     ~ In U X x -> ~ In U X0 x -> Add U X x = Add U X0 x -> X = X0.
Lemma Included_Add :   forall (X A:Ensemble U) (x:U),     Included U X (Add U A x) ->     Included U X A \/ (exists A' : _, X = Add U A' x /\ Included U A' A).
Lemma setcover_inv :   forall A x y:Ensemble U,     covers (Ensemble U) (Power_set_PO U A) y x ->     Strict_Included U x y /\     (forall z:Ensemble U, Included U x z -> Included U z y -> x = z \/ z = y).
Lemma less_than_singleton :   forall (X:Ensemble U) (x:U),     Strict_Included U X (Singleton U x) -> X = Empty_set U.
Lemma sum_N_predN : forall (An:nat -> R) (N:nat),   (0 < N)%nat -> sum_f_R0 An N = sum_f_R0 An (pred N) + An N.
Lemma sum_plus : forall (An Bn:nat -> R) (N:nat),   sum_f_R0 (fun l:nat => An l + Bn l) N = sum_f_R0 An N + sum_f_R0 Bn N.
Lemma In_1 : E.eq x y -> In x s -> In y s.
Lemma mem_1 : In x s -> mem x s = true.
Lemma mem_2 : mem x s = true -> In x s.
Lemma equal_1 : Equal s s' -> equal s s' = true.
Lemma equal_2 : equal s s' = true -> Equal s s'.
Lemma subset_1 : Subset s s' -> subset s s' = true.
Lemma subset_2 : subset s s' = true -> Subset s s'.
Lemma is_empty_1 : Empty s -> is_empty s = true.
Lemma is_empty_2 : is_empty s = true -> Empty s.
Lemma add_1 : E.eq x y -> In y (add x s).
Lemma add_2 : In y s -> In y (add x s).
Lemma add_3 : ~ E.eq x y -> In y (add x s) -> In y s.
Lemma remove_1 : E.eq x y -> ~ In y (remove x s).
Lemma remove_2 : ~ E.eq x y -> In y s -> In y (remove x s).
Lemma remove_3 : In y (remove x s) -> In y s.
Lemma singleton_1 : In y (singleton x) -> E.eq x y.
Lemma singleton_2 : E.eq x y -> In y (singleton x).
Lemma union_1 : In x (union s s') -> In x s \/ In x s'.
Lemma union_2 : In x s -> In x (union s s').
Lemma union_3 : In x s' -> In x (union s s').
Lemma inter_1 : In x (inter s s') -> In x s.
Lemma inter_2 : In x (inter s s') -> In x s'.
Lemma inter_3 : In x s -> In x s' -> In x (inter s s').
Lemma diff_1 : In x (diff s s') -> In x s.
Lemma diff_2 : In x (diff s s') -> ~ In x s'.
Lemma diff_3 : In x s -> ~ In x s' -> In x (diff s s').
Lemma filter_1 : compatb f -> In x (filter f s) -> In x s.
Lemma filter_2 : compatb f -> In x (filter f s) -> f x = true.
Lemma filter_3 : compatb f -> In x s -> f x = true -> In x (filter f s).
Lemma for_all_1 : compatb f ->     For_all (fun x => f x = true) s -> for_all f s = true.
Lemma for_all_2 : compatb f ->     for_all f s = true -> For_all (fun x => f x = true) s.
Lemma exists_1 : compatb f ->     Exists (fun x => f x = true) s -> exists_ f s = true.
Lemma exists_2 : compatb f ->     exists_ f s = true -> Exists (fun x => f x = true) s.
Lemma elements_1 : In x s -> InA E.eq x (elements s).
Lemma elements_2 : InA E.eq x (elements s) -> In x s.
Lemma In_eq_iff : E.eq x y -> (In x s <-> In y s).
Lemma mem_iff : In x s <-> mem x s = true.
Lemma not_mem_iff : ~In x s <-> mem x s = false.
Lemma equal_iff : s[=]s' <-> equal s s' = true.
Lemma subset_iff : s[<=]s' <-> subset s s' = true.
Lemma empty_iff : In x empty <-> False.
Lemma is_empty_iff : Empty s <-> is_empty s = true.
Lemma singleton_iff : In y (singleton x) <-> E.eq x y.
Lemma add_iff : In y (add x s) <-> E.eq x y \/ In y s.
Lemma add_neq_iff : ~ E.eq x y -> (In y (add x s)  <-> In y s).
Lemma remove_iff : In y (remove x s) <-> In y s /\ ~E.eq x y.
Lemma remove_neq_iff : ~ E.eq x y -> (In y (remove x s) <-> In y s).
Lemma for_all_iff : Proper (E.eq==>Logic.eq) f ->
Lemma exists_iff : Proper (E.eq==>Logic.eq) f ->
Lemma elements_iff : In x s <-> InA E.eq x (elements s).
Lemma mem_b : E.eq x y -> mem x s = mem y s.
Lemma empty_b : mem y empty = false.
Lemma add_b : mem y (add x s) = eqb x y || mem y s.
Lemma add_neq_b : ~ E.eq x y -> mem y (add x s) = mem y s.
Lemma remove_b : mem y (remove x s) = mem y s && negb (eqb x y).
Lemma remove_neq_b : ~ E.eq x y -> mem y (remove x s) = mem y s.
Lemma singleton_b : mem y (singleton x) = eqb x y.
Lemma union_b : mem x (union s s') = mem x s || mem x s'.
Lemma inter_b : mem x (inter s s') = mem x s && mem x s'.
Lemma diff_b : mem x (diff s s') = mem x s && negb (mem x s').
Lemma elements_b : mem x s = existsb (eqb x) (elements s).
Lemma filter_b : Proper (E.eq==>Logic.eq) f -> mem x (filter f s) = mem x s && f x.
Lemma for_all_b : Proper (E.eq==>Logic.eq) f ->
Lemma exists_b : Proper (E.eq==>Logic.eq) f ->
Lemma filter_ext : forall f f', Proper (E.eq==>Logic.eq) f -> (forall x, f x = f' x) ->
Lemma mod_eq : forall a b, b~=0 -> a mod b == a - b*(a/b).
Lemma div_opp_r : forall a b, b~=0 -> a/(-b) == -(a/b).
Lemma mod_opp_r : forall a b, b~=0 -> a mod (-b) == a mod b.
Lemma div_opp_l_z : forall a b, b~=0 -> a mod b == 0 -> (-a)/b == -(a/b).
Lemma div_opp_l_nz : forall a b, b~=0 -> a mod b ~= 0 -> (-a)/b == -(a/b)-sgn b.
Lemma mod_opp_l_z : forall a b, b~=0 -> a mod b == 0 -> (-a) mod b == 0.
Lemma mod_opp_l_nz : forall a b, b~=0 -> a mod b ~= 0 -> (-a) mod b == abs b - (a mod b).
Lemma div_opp_opp_z : forall a b, b~=0 -> a mod b == 0 -> (-a)/(-b) == a/b.
Lemma div_opp_opp_nz : forall a b, b~=0 -> a mod b ~= 0 -> (-a)/(-b) == a/b + sgn(b).
Lemma mod_opp_opp_z : forall a b, b~=0 -> a mod b == 0 -> (-a) mod (-b) == 0.
Lemma mod_opp_opp_nz : forall a b, b~=0 -> a mod b ~= 0 -> (-a) mod (-b) == abs b - a mod b.
Lemma div_same : forall a, a~=0 -> a/a == 1.
Lemma mod_same : forall a, a~=0 -> a mod a == 0.
Lemma div_0_l: forall a, a~=0 -> 0/a == 0.
Lemma mod_0_l: forall a, a~=0 -> 0 mod a == 0.
Lemma div_1_r: forall a, a/1 == a.
Lemma mod_1_r: forall a, a mod 1 == 0.
Lemma div_1_l: forall a, 1<a -> 1/a == 0.
Lemma mod_1_l: forall a, 1<a -> 1 mod a == 1.
Lemma div_mul : forall a b, b~=0 -> (a*b)/b == a.
Lemma mod_mul : forall a b, b~=0 -> (a*b) mod b == 0.
Lemma div_str_pos : forall a b, 0<b<=a -> 0 < a/b.
Lemma div_small_iff : forall a b, b~=0 -> (a/b==0 <-> 0<=a<abs b).
Lemma mod_small_iff : forall a b, b~=0 -> (a mod b == a <-> 0<=a<abs b).
Lemma div_lt : forall a b, 0<a -> 1<b -> a/b < a.
Lemma div_le_mono : forall a b c, 0<c -> a<=b -> a/c <= b/c.
Lemma mul_div_le : forall a b, b~=0 -> b*(a/b) <= a.
Lemma mul_succ_div_gt: forall a b, 0<b -> a < b*(S (a/b)).
Lemma mul_pred_div_gt: forall a b, b<0 -> a < b*(P (a/b)).
Lemma div_exact : forall a b, b~=0 -> (a == b*(a/b) <-> a mod b == 0).
Lemma div_le_compat_l: forall p q r, 0<=p -> 0<q<=r -> p/r <= p/q.
Lemma mod_add : forall a b c, c~=0 -> (a + b * c) mod c == a mod c.
Lemma div_add : forall a b c, c~=0 -> (a + b * c) / c == a / c + b.
Lemma div_add_l: forall a b c, b~=0 -> (a * b + c) / b == a + c / b.
Lemma div_mul_cancel_r : forall a b c, b~=0 -> 0<c -> (a*c)/(b*c) == a/b.
Lemma div_mul_cancel_l : forall a b c, b~=0 -> 0<c -> (c*a)/(c*b) == a/b.
Lemma mul_mod_distr_l: forall a b c, b~=0 -> 0<c -> (c*a) mod (c*b) == c * (a mod b).
Lemma mul_mod_distr_r: forall a b c, b~=0 -> 0<c -> (a*c) mod (b*c) == (a mod b) * c.
Lemma mul_mod_idemp_l : forall a b n, n~=0 -> ((a mod n)*b) mod n == (a*b) mod n.
Lemma mul_mod_idemp_r : forall a b n, n~=0 -> (a*(b mod n)) mod n == (a*b) mod n.
Lemma add_mod_idemp_l : forall a b n, n~=0 -> ((a mod n)+b) mod n == (a+b) mod n.
Lemma add_mod_idemp_r : forall a b n, n~=0 -> (a+(b mod n)) mod n == (a+b) mod n.
Lemma div_div : forall a b c, 0<b -> c~=0 -> (a/b)/c == a/(b*c).
Lemma mod_mul_r : forall a b c, 0<b -> c~=0 -> a mod (b*c) == a mod b + b*((a/b) mod c).
Lemma mod_divides : forall a b, b~=0 -> (a mod b == 0 <-> (b|a)).
Lemma leb_le n m : (n <=? m) = true <-> n <= m.
Lemma ltb_lt n m : (n <? m) = true <-> n < m.
Lemma pow_0_r : forall a, a^0 = 1.
Lemma pow_succ_r : forall a b, 0<=b -> a^(S b) = a * a^b.
Lemma square_spec n : square n = n * n.
Lemma even_spec : forall n, even n = true <-> Even n.
Lemma odd_spec : forall n, odd n = true <-> Odd n.
Lemma Even_equiv : forall n, Even n <-> Even.even n.
Lemma Odd_equiv : forall n, Odd n <-> Even.odd n.
Lemma divmod_spec : forall x y q u, u <= y -> let (q',u') := divmod x y q u in x + (S y)*q + (y-u) = (S y)*q' + (y-u') /\ u' <= y.
Lemma div_mod : forall x y, y<>0 -> x = y*(x/y) + x mod y.
Lemma mod_bound_pos : forall x y, 0<=x -> 0<y -> 0 <= x mod y < y.
Lemma sqrt_iter_spec : forall k p q r, q = p+p -> r<=q -> let s := sqrt_iter k p q r in s*s <= k + p*p + (q - r) < (S s)*(S s).
Lemma sqrt_spec : forall n, (sqrt n)*(sqrt n) <= n < S (sqrt n) * S (sqrt n).
Lemma log2_iter_spec : forall k p q r, 2^(S p) = q + S r -> r < 2^p -> let s := log2_iter k p q r in 2^s <= k + q < 2^(S s).
Lemma log2_spec : forall n, 0<n -> 2^(log2 n) <= n < 2^(S (log2 n)).
Lemma log2_nonpos : forall n, n<=0 -> log2 n = 0.
Lemma gcd_divide : forall a b, (gcd a b | a) /\ (gcd a b | b).
Lemma gcd_divide_l : forall a b, (gcd a b | a).
Lemma gcd_divide_r : forall a b, (gcd a b | b).
Lemma gcd_greatest : forall a b c, (c|a) -> (c|b) -> (c|gcd a b).
Lemma double_twice : forall n, double n = 2*n.
Lemma testbit_0_l : forall n, testbit 0 n = false.
Lemma testbit_odd_0 a : testbit (2*a+1) 0 = true.
Lemma testbit_even_0 a : testbit (2*a) 0 = false.
Lemma testbit_odd_succ a n : testbit (2*a+1) (S n) = testbit a n.
Lemma testbit_even_succ a n : testbit (2*a) (S n) = testbit a n.
Lemma shiftr_spec : forall a n m, testbit (shiftr a n) m = testbit a (m+n).
Lemma shiftl_spec_high : forall a n m, n<=m -> testbit (shiftl a n) m = testbit a (m-n).
Lemma shiftl_spec_low : forall a n m, m<n -> testbit (shiftl a n) m = false.
Lemma div2_bitwise : forall op n a b, div2 (bitwise op (S n) a b) = bitwise op n (div2 a) (div2 b).
Lemma odd_bitwise : forall op n a b, odd (bitwise op (S n) a b) = op (odd a) (odd b).
Lemma div2_decr : forall a n, a <= S n -> div2 a <= n.
Lemma testbit_bitwise_1 : forall op, (forall b, op false b = false) -> forall n m a b, a<=n -> testbit (bitwise op n a b) m = op (testbit a m) (testbit b m).
Lemma testbit_bitwise_2 : forall op, op false false = false -> forall n m a b, a<=n -> b<=n -> testbit (bitwise op n a b) m = op (testbit a m) (testbit b m).
Lemma land_spec : forall a b n, testbit (land a b) n = testbit a n && testbit b n.
Lemma ldiff_spec : forall a b n, testbit (ldiff a b) n = testbit a n && negb (testbit b n).
Lemma lor_spec : forall a b n, testbit (lor a b) n = testbit a n || testbit b n.
Lemma lxor_spec : forall a b n, testbit (lxor a b) n = xorb (testbit a n) (testbit b n).
Lemma pow_neg_r : forall a b, b<0 -> a^b = 0. inversion 1. Qed.
Lemma sqrt_neg : forall a, a<0 -> sqrt a = 0. inversion 1. Qed.
Lemma gcd_nonneg : forall a b, 0<=gcd a b.
Lemma testbit_neg_r a n (H:n<0) : testbit a n = false.
Lemma sig_of_sigT : forall (A:Type) (P:A->Prop), sigT P -> sig P.
Lemma sigT_of_sig : forall (A:Type) (P:A->Prop), sig P -> sigT P.
Lemma Choice :  (forall x:S, {y:S' | R x y}) -> {f:S -> S' | forall z:S, R z (f z)}.
Lemma Choice2 :  (forall x:S, {y:S' & R' x y}) -> {f:S -> S' & forall z:S, R' z (f z)}.
Lemma bool_choice :  (forall x:S, {R1 x} + {R2 x}) ->    {f:S -> bool | forall x:S, f x = true /\ R1 x \/ f x = false /\ R2 x}.
Lemma dependent_choice :   (forall x:X, {y | R x y}) ->   forall x0, {f : nat -> X | f O = x0 /\ forall n, R (f n) (f (S n))}.
Lemma singleton_spec x y : InT y (singleton x) <-> X.eq y x.
Lemma makeBlack_spec s x : InT x (makeBlack s) <-> InT x s.
Lemma makeRed_spec s x : InT x (makeRed s) <-> InT x s.
Lemma lbal_spec l x r y :  InT y (lbal l x r) <-> X.eq y x \/ InT y l \/ InT y r.
Lemma rbal_spec l x r y :  InT y (rbal l x r) <-> X.eq y x \/ InT y l \/ InT y r.
Lemma rbal'_spec l x r y :  InT y (rbal' l x r) <-> X.eq y x \/ InT y l \/ InT y r.
Lemma ins_spec : forall s x y, InT y (ins x s) <-> X.eq y x \/ InT y s.
Lemma add_spec' s x y : InT y (add x s) <-> X.eq y x \/ InT y s.
Lemma add_spec s x y `{Ok s} : InT y (add x s) <-> X.eq y x \/ InT y s.
Lemma lbalS_spec l x r y : InT y (lbalS l x r) <-> X.eq y x \/ InT y l \/ InT y r.
Lemma rbalS_spec l x r y : InT y (rbalS l x r) <-> X.eq y x \/ InT y l \/ InT y r.
Lemma append_spec l r x : InT x (append l r) <-> InT x l \/ InT x r.
Lemma append_ok : forall x l r `{Ok l, Ok r}, lt_tree x l -> gt_tree x r -> Ok (append l r).
Lemma del_spec : forall s x y `{Ok s}, InT y (del x s) <-> InT y s /\ ~X.eq y x.
Lemma remove_spec s x y `{Ok s} : InT y (remove x s) <-> InT y s /\ ~X.eq y x.
Lemma delmin_spec l y r c x s' `{O : Ok (Node c l y r)} : delmin l y r = (x,s') -> min_elt (Node c l y r) = Some x /\ del x (Node c l y r) = s'.
Lemma remove_min_spec1 s x s' `{Ok s}: remove_min s = Some (x,s') -> min_elt s = Some x /\ remove x s = s'.
Lemma remove_min_spec2 s : remove_min s = None -> Empty s.
Lemma remove_min_ok (s:t) `{Ok s}: match remove_min s with | Some (_,s') => Ok s' | None => True end.
Lemma treeify_zero_spec : treeify_invariant 0 treeify_zero.
Lemma treeify_one_spec : treeify_invariant 1 treeify_one.
Lemma treeify_cont_spec f g size1 size2 size : treeify_invariant size1 f -> treeify_invariant size2 g -> size = S (size1 + size2) -> treeify_invariant size (treeify_cont f g).
Lemma treeify_aux_spec n (p:bool) : treeify_invariant (ifpred p (Pos.to_nat n)) (treeify_aux p n).
Lemma plength_aux_spec l p : Pos.to_nat (plength_aux l p) = length l + Pos.to_nat p.
Lemma plength_spec l : Pos.to_nat (plength l) = S (length l).
Lemma treeify_elements l : elements (treeify l) = l.
Lemma treeify_spec x l : InT x (treeify l) <-> InA X.eq x l.
Lemma treeify_ok l : sort X.lt l -> Ok (treeify l).
Lemma filter_app A f (l l':list A) : List.filter f (l ++ l') = List.filter f l ++ List.filter f l'.
Lemma filter_aux_elements s f acc : filter_aux f s acc = List.filter f (elements s) ++ acc.
Lemma filter_elements s f : elements (filter f s) = List.filter f (elements s).
Lemma filter_spec s x f : Proper (X.eq==>Logic.eq) f ->
Lemma partition_aux_spec s f acc1 acc2 : partition_aux f s acc1 acc2 = (filter_aux f s acc1, filter_aux (fun x => negb (f x)) s acc2).
Lemma partition_spec s f : partition f s = (filter f s, filter (fun x => negb (f x)) s).
Lemma partition_spec1 s f : Proper (X.eq==>Logic.eq) f ->
Lemma partition_spec2 s f : Proper (X.eq==>Logic.eq) f ->
Lemma INV_init s1 s2 `(Ok s1, Ok s2) : INV (rev_elements s1) (rev_elements s2) nil.
Lemma INV_sym l1 l2 acc : INV l1 l2 acc -> INV l2 l1 acc.
Lemma INV_drop x1 l1 l2 acc : INV (x1 :: l1) l2 acc -> INV l1 l2 acc.
Lemma INV_eq x1 x2 l1 l2 acc : INV (x1 :: l1) (x2 :: l2) acc -> X.eq x1 x2 ->
Lemma INV_lt x1 x2 l1 l2 acc : INV (x1 :: l1) (x2 :: l2) acc -> X.lt x1 x2 ->
Lemma INV_rev l1 l2 acc : INV l1 l2 acc -> Sorted X.lt (rev_append l1 acc).
Lemma union_list_ok l1 l2 acc : INV l1 l2 acc -> sort X.lt (union_list l1 l2 acc).
Lemma union_list_spec x l1 l2 acc : InA X.eq x (union_list l1 l2 acc) <->
Lemma linear_union_spec s1 s2 x : InT x (linear_union s1 s2) <-> InT x s1 \/ InT x s2.
Lemma fold_add_spec s1 s2 x : InT x (fold add s1 s2) <-> InT x s1 \/ InT x s2.
Lemma union_spec' s1 s2 x : InT x (union s1 s2) <-> InT x s1 \/ InT x s2.
Lemma union_spec : forall s1 s2 y `{Ok s1, Ok s2}, (InT y (union s1 s2) <-> InT y s1 \/ InT y s2).
Lemma inter_list_ok l1 l2 acc : INV l1 l2 acc -> sort X.lt (inter_list l1 l2 acc).
Lemma inter_list_spec x l1 l2 acc : sort X.lt (rev l1) ->
Lemma linear_inter_spec s1 s2 x `(Ok s1, Ok s2) : InT x (linear_inter s1 s2) <-> InT x s1 /\ InT x s2.
Lemma inter_spec s1 s2 y `{Ok s1, Ok s2} : InT y (inter s1 s2) <-> InT y s1 /\ InT y s2.
Lemma diff_list_ok l1 l2 acc : INV l1 l2 acc -> sort X.lt (diff_list l1 l2 acc).
Lemma diff_list_spec x l1 l2 acc : sort X.lt (rev l1) ->
Lemma linear_diff_spec s1 s2 x `(Ok s1, Ok s2) : InT x (linear_diff s1 s2) <-> InT x s1 /\ ~InT x s2.
Lemma fold_remove_spec s1 s2 x `(Ok s2) : InT x (fold remove s1 s2) <-> InT x s2 /\ ~InT x s1.
Lemma diff_spec s1 s2 y `{Ok s1, Ok s2} : InT y (diff s1 s2) <-> InT y s1 /\ ~InT y s2.
Lemma rr_nrr_rb n t : rrt n t -> notredred t -> rbt n t.
Lemma arb_nrr_rb n t : arbt n t -> notredred t -> rbt n t.
Lemma arb_nr_rb n t : arbt n t -> notred t -> rbt n t.
Lemma rb_maxdepth s n : rbt n s -> maxdepth s <= 2*n + redcarac s.
Lemma rb_mindepth s n : rbt n s -> n + redcarac s <= mindepth s.
Lemma maxdepth_upperbound s : Rbt s -> maxdepth s <= 2 * log2 (S (cardinal s)).
Lemma maxdepth_lowerbound s : s<>Leaf -> log2 (cardinal s) < maxdepth s.
Lemma singleton_rb x : Rbt (singleton x).
Lemma makeBlack_rb n t : arbt n t -> Rbt (makeBlack t).
Lemma makeRed_rr t n : rbt (S n) t -> notred t -> rrt n (makeRed t).
Lemma lbal_rb n l k r : arbt n l -> rbt n r -> rbt (S n) (lbal l k r).
Lemma rbal_rb n l k r : rbt n l -> arbt n r -> rbt (S n) (rbal l k r).
Lemma rbal'_rb n l k r : rbt n l -> arbt n r -> rbt (S n) (rbal' l k r).
Lemma lbalS_rb n l x r : arbt n l -> rbt (S n) r -> notred r -> rbt (S n) (lbalS l x r).
Lemma lbalS_arb n l x r : arbt n l -> rbt (S n) r -> arbt (S n) (lbalS l x r).
Lemma rbalS_rb n l x r : rbt (S n) l -> notred l -> arbt n r -> rbt (S n) (rbalS l x r).
Lemma rbalS_arb n l x r : rbt (S n) l -> arbt n r -> arbt (S n) (rbalS l x r).
Lemma ifred_notred s A B : notred s -> (ifred s A B <-> B).
Lemma ifred_or s A B : ifred s A B -> A\/B.
Lemma ins_rr_rb x s n : rbt n s -> ifred s (rrt n (ins x s)) (rbt n (ins x s)).
Lemma ins_arb x s n : rbt n s -> arbt n (ins x s).
Lemma append_arb_rb n l r : rbt n l -> rbt n r -> (arbt n (append l r)) /\ (notred l -> notred r -> rbt n (append l r)).
Lemma del_arb s x n : rbt (S n) s -> isblack s -> arbt n (del x s) with del_rb s x n : rbt n s -> notblack s -> rbt n (del x s).
Lemma treeify_zero_rb : treeify_rb_invariant 0 0 treeify_zero.
Lemma treeify_one_rb : treeify_rb_invariant 1 0 treeify_one.
Lemma treeify_cont_rb f g size1 size2 size d : treeify_rb_invariant size1 d f -> treeify_rb_invariant size2 d g -> size = S (size1 + size2) -> treeify_rb_invariant size (S d) (treeify_cont f g).
Lemma treeify_aux_rb n : exists d, forall (b:bool), treeify_rb_invariant (ifpred b (Pos.to_nat n)) d (treeify_aux b n).
Lemma union_rb s1 s2 : Rbt s1 -> Rbt s2 -> Rbt (union s1 s2).
Lemma inter_rb s1 s2 : Rbt s1 -> Rbt s2 -> Rbt (inter s1 s2).
Lemma diff_rb s1 s2 : Rbt s1 -> Rbt s2 -> Rbt (diff s1 s2).
Lemma remove_min_spec1 s x s' : remove_min s = Some (x,s') ->  min_elt s = Some x /\ Equal (remove x s) s'.
Lemma remove_min_spec2 s : remove_min s = None -> Empty s.
Lemma dicho_comp : forall (x y:R) (P:R -> bool) (n:nat),   x <= y -> dicho_lb x y P n <= dicho_up x y P n.
Lemma dicho_lb_growing : forall (x y:R) (P:R -> bool), x <= y -> Un_growing (dicho_lb x y P).
Lemma dicho_up_decreasing : forall (x y:R) (P:R -> bool), x <= y -> Un_decreasing (dicho_up x y P).
Lemma dicho_lb_maj_y : forall (x y:R) (P:R -> bool), x <= y -> forall n:nat, dicho_lb x y P n <= y.
Lemma dicho_lb_maj : forall (x y:R) (P:R -> bool), x <= y -> has_ub (dicho_lb x y P).
Lemma dicho_up_min_x : forall (x y:R) (P:R -> bool), x <= y -> forall n:nat, x <= dicho_up x y P n.
Lemma dicho_up_min : forall (x y:R) (P:R -> bool), x <= y -> has_lb (dicho_up x y P).
Lemma dicho_lb_cv : forall (x y:R) (P:R -> bool),   x <= y -> { l:R | Un_cv (dicho_lb x y P) l }.
Lemma dicho_up_cv : forall (x y:R) (P:R -> bool),   x <= y -> { l:R | Un_cv (dicho_up x y P) l }.
Lemma dicho_lb_dicho_up : forall (x y:R) (P:R -> bool) (n:nat),   x <= y -> dicho_up x y P n - dicho_lb x y P n = (y - x) / 2 ^ n.
Lemma pow_2_n_neq_R0 : forall n:nat, pow_2_n n <> 0.
Lemma pow_2_n_growing : Un_growing pow_2_n.
Lemma pow_2_n_infty : cv_infty pow_2_n.
Lemma cv_dicho : forall (x y l1 l2:R) (P:R -> bool),   x <= y ->   Un_cv (dicho_lb x y P) l1 -> Un_cv (dicho_up x y P) l2 -> l1 = l2.
Lemma continuity_seq : forall (f:R -> R) (Un:nat -> R) (l:R),   continuity_pt f l -> Un_cv Un l -> Un_cv (fun i:nat => f (Un i)) (f l).
Lemma dicho_lb_car : forall (x y:R) (P:R -> bool) (n:nat),   P x = false -> P (dicho_lb x y P n) = false.
Lemma dicho_up_car : forall (x y:R) (P:R -> bool) (n:nat),   P y = true -> P (dicho_up x y P n) = true.
Lemma IVT : forall (f:R -> R) (x y:R),   continuity f ->   x < y -> f x < 0 -> 0 < f y -> { z:R | x <= z <= y /\ f z = 0 }.
Lemma IVT_cor : forall (f:R -> R) (x y:R),   continuity f ->   x <= y -> f x * f y <= 0 -> { z:R | x <= z <= y /\ f z = 0 }.
Lemma Rsqrt_exists : forall y:R, 0 <= y -> { z:R | 0 <= z /\ y = Rsqr z }.
Lemma Rsqrt_positivity : forall x:nonnegreal, 0 <= Rsqrt x.
Lemma Rsqrt_Rsqrt : forall x:nonnegreal, Rsqrt x * Rsqrt x = x.
Lemma spec_ww_is_even : forall x,     if ww_is_even x then [[x]] mod 2 = 0 else [[x]] mod 2 = 1.
Lemma C1_plus_wB: forall x, [+|C1 x|] = wB + [|x|].
Lemma spec_split: forall x, [|fst (split x)|] * wB + [|snd (split x)|] = [[x]].
Lemma spec_ww_sqrt2 : forall x y,      wwB/ 4 <= [[x]] ->      let (s,r) := ww_sqrt2 x y in         [||WW x y||] = [[s]] ^ 2 + [+[r]] /\         [+[r]] <= 2 * [[s]].
Lemma spec_ww_is_zero: forall x,  if ww_is_zero x then [[x]] = 0 else 0 < [[x]].
Lemma wwB_4_2: 2 * (wwB / 4) = wwB/ 2.
Lemma spec_ww_head1      : forall x : zn2z w,        (ww_is_even (ww_head1 x) = true) /\        (0 < [[x]] -> wwB / 4 <= 2 ^ [[ww_head1 x]] * [[x]] < wwB).
Lemma spec_ww_sqrt : forall x,      [[ww_sqrt x]] ^ 2 <= [[x]] < ([[ww_sqrt x]] + 1) ^ 2.
Lemma nat_compare_S : forall n m, nat_compare (S n) (S m) = nat_compare n m.
Lemma nat_compare_eq_iff : forall n m, nat_compare n m = Eq <-> n = m.
Lemma nat_compare_eq : forall n m, nat_compare n m = Eq -> n = m.
Lemma nat_compare_lt : forall n m, n<m <-> nat_compare n m = Lt.
Lemma nat_compare_gt : forall n m, n>m <-> nat_compare n m = Gt.
Lemma nat_compare_le : forall n m, n<=m <-> nat_compare n m <> Gt.
Lemma nat_compare_ge : forall n m, n>=m <-> nat_compare n m <> Lt.
Lemma nat_compare_spec : forall x y, CompareSpec (x=y) (x<y) (y<x) (nat_compare x y).
Lemma nat_compare_Lt_lt : forall n m, nat_compare n m = Lt -> n<m.
Lemma nat_compare_Gt_gt : forall n m, nat_compare n m = Gt -> n>m.
Lemma nat_compare_equiv: forall n m, nat_compare n m = nat_compare_alt n m.
Lemma leb_correct : forall m n, m <= n -> leb m n = true.
Lemma leb_complete : forall m n, leb m n = true -> m <= n.
Lemma leb_iff : forall m n, leb m n = true <-> m <= n.
Lemma leb_correct_conv : forall m n, m < n -> leb n m = false.
Lemma leb_complete_conv : forall m n, leb n m = false -> m < n.
Lemma leb_iff_conv : forall m n, leb n m = false <-> m < n.
Lemma leb_compare : forall n m, leb n m = true <-> nat_compare n m <> Gt.
Lemma Ptestbit_Pbit : forall p n, Pos.testbit p (N.of_nat n) = Pos.testbit_nat p n.
Lemma Ntestbit_Nbit : forall a n, N.testbit a (N.of_nat n) = N.testbit_nat a n.
Lemma Pbit_Ptestbit : forall p n, Pos.testbit_nat p (N.to_nat n) = Pos.testbit p n.
Lemma Nbit_Ntestbit : forall a n, N.testbit_nat a (N.to_nat n) = N.testbit a n.
Lemma Nshiftr_nat_S : forall a n, N.shiftr_nat a (S n) = N.div2 (N.shiftr_nat a n).
Lemma Nshiftl_nat_S : forall a n, N.shiftl_nat a (S n) = N.double (N.shiftl_nat a n).
Lemma Nshiftr_nat_equiv : forall a n, N.shiftr_nat a (N.to_nat n) = N.shiftr a n.
Lemma Nshiftr_equiv_nat : forall a n, N.shiftr a (N.of_nat n) = N.shiftr_nat a n.
Lemma Nshiftl_nat_equiv : forall a n, N.shiftl_nat a (N.to_nat n) = N.shiftl a n.
Lemma Nshiftl_equiv_nat : forall a n, N.shiftl a (N.of_nat n) = N.shiftl_nat a n.
Lemma Nshiftr_nat_spec : forall a n m, N.testbit_nat (N.shiftr_nat a n) m = N.testbit_nat a (m+n).
Lemma Nshiftl_nat_spec_high : forall a n m, (n<=m)%nat -> N.testbit_nat (N.shiftl_nat a n) m = N.testbit_nat a (m-n).
Lemma Nshiftl_nat_spec_low : forall a n m, (m<n)%nat -> N.testbit_nat (N.shiftl_nat a n) m = false.
Lemma Pshiftl_nat_0 : forall p, Pos.shiftl_nat p 0 = p.
Lemma Pshiftl_nat_S : forall p n, Pos.shiftl_nat p (S n) = xO (Pos.shiftl_nat p n).
Lemma Pshiftl_nat_N : forall p n, Npos (Pos.shiftl_nat p n) = N.shiftl_nat (Npos p) n.
Lemma Pshiftl_nat_plus : forall n m p, Pos.shiftl_nat p (m + n) = Pos.shiftl_nat (Pos.shiftl_nat p n) m.
Lemma Pxor_semantics p p' n : N.testbit_nat (Pos.lxor p p') n = xorb (Pos.testbit_nat p n) (Pos.testbit_nat p' n).
Lemma Nxor_semantics a a' n : N.testbit_nat (N.lxor a a') n = xorb (N.testbit_nat a n) (N.testbit_nat a' n).
Lemma Por_semantics p p' n : Pos.testbit_nat (Pos.lor p p') n = (Pos.testbit_nat p n) || (Pos.testbit_nat p' n).
Lemma Nor_semantics a a' n : N.testbit_nat (N.lor a a') n = (N.testbit_nat a n) || (N.testbit_nat a' n).
Lemma Pand_semantics p p' n : N.testbit_nat (Pos.land p p') n = (Pos.testbit_nat p n) && (Pos.testbit_nat p' n).
Lemma Nand_semantics a a' n : N.testbit_nat (N.land a a') n = (N.testbit_nat a n) && (N.testbit_nat a' n).
Lemma Pdiff_semantics p p' n : N.testbit_nat (Pos.ldiff p p') n = (Pos.testbit_nat p n) && negb (Pos.testbit_nat p' n).
Lemma Ndiff_semantics a a' n : N.testbit_nat (N.ldiff a a') n = (N.testbit_nat a n) && negb (N.testbit_nat a' n).
Lemma Pbit_faithful_0 : forall p, ~(Pos.testbit_nat p == (fun _ => false)).
Lemma Pbit_faithful : forall p p', Pos.testbit_nat p == Pos.testbit_nat p' -> p = p'.
Lemma Nbit_faithful : forall n n', N.testbit_nat n == N.testbit_nat n' -> n = n'.
Lemma Nbit_faithful_iff : forall n n', N.testbit_nat n == N.testbit_nat n' <-> n = n'.
Lemma Nbit0_correct : forall n:N, N.testbit_nat n 0 = N.odd n.
Lemma Ndouble_bit0 : forall n:N, N.odd (N.double n) = false.
Lemma Ndouble_plus_one_bit0 : forall n:N, N.odd (N.succ_double n) = true.
Lemma Ndiv2_double : forall n:N, Neven n -> N.double (N.div2 n) = n.
Lemma Ndiv2_double_plus_one : forall n:N, Nodd n -> N.succ_double (N.div2 n) = n.
Lemma Ndiv2_correct : forall (a:N) (n:nat), N.testbit_nat (N.div2 a) n = N.testbit_nat a (S n).
Lemma Nxor_bit0 : forall a a':N, N.odd (N.lxor a a') = xorb (N.odd a) (N.odd a').
Lemma Nxor_div2 : forall a a':N, N.div2 (N.lxor a a') = N.lxor (N.div2 a) (N.div2 a').
Lemma Nneg_bit0 : forall a a':N,  N.odd (N.lxor a a') = true -> N.odd a = negb (N.odd a').
Lemma Nneg_bit0_1 : forall a a':N, N.lxor a a' = Npos 1 -> N.odd a = negb (N.odd a').
Lemma Nneg_bit0_2 : forall (a a':N) (p:positive),  N.lxor a a' = Npos (xI p) -> N.odd a = negb (N.odd a').
Lemma Nsame_bit0 : forall (a a':N) (p:positive),  N.lxor a a' = Npos (xO p) -> N.odd a = N.odd a'.
Lemma Nbit0_less : forall a a',  N.odd a = false -> N.odd a' = true -> Nless a a' = true.
Lemma Nbit0_gt : forall a a',  N.odd a = true -> N.odd a' = false -> Nless a a' = false.
Lemma Nless_not_refl : forall a, Nless a a = false.
Lemma Nless_def_1 : forall a a', Nless (N.double a) (N.double a') = Nless a a'.
Lemma Nless_def_2 : forall a a',  Nless (N.succ_double a) (N.succ_double a') = Nless a a'.
Lemma Nless_def_3 : forall a a', Nless (N.double a) (N.succ_double a') = true.
Lemma Nless_def_4 : forall a a', Nless (N.succ_double a) (N.double a') = false.
Lemma Nless_z : forall a, Nless a N0 = false.
Lemma N0_less_1 : forall a, Nless N0 a = true -> {p : positive | a = Npos p}.
Lemma N0_less_2 : forall a, Nless N0 a = false -> a = N0.
Lemma Nless_trans : forall a a' a'',  Nless a a' = true -> Nless a' a'' = true -> Nless a a'' = true.
Lemma Nless_total : forall a a', {Nless a a' = true} + {Nless a' a = true} + {a = a'}.
Lemma Bv2N_N2Bv : forall n, Bv2N _ (N2Bv n) = n.
Lemma Bv2N_Nsize : forall n (bv:Bvector n), N.size_nat (Bv2N n bv) <= n.
Lemma Bv2N_Nsize_1 : forall n (bv:Bvector (S n)), Bsign _ bv = true <-> N.size_nat (Bv2N _ bv) = (S n).
Lemma N2Bv_N2Bv_gen : forall (a:N), N2Bv a = N2Bv_gen (N.size_nat a) a.
Lemma N2Bv_N2Bv_gen_above : forall (a:N)(k:nat), N2Bv_gen (N.size_nat a + k) a = Vector.append (N2Bv a) (Bvect_false k).
Lemma N2Bv_Bv2N : forall n (bv:Bvector n),  N2Bv_gen n (Bv2N n bv) = bv.
Lemma Nbit0_Blow : forall n, forall (bv:Bvector (S n)), N.odd (Bv2N _ bv) = Blow _ bv.
Lemma Bnth_Nbit : forall n (bv:Bvector n) p (H:p<n), Bnth bv H = N.testbit_nat (Bv2N _ bv) p.
Lemma Nbit_Nsize : forall n p, N.size_nat n <= p -> N.testbit_nat n p = false.
Lemma Nbit_Bth: forall n p (H:p < N.size_nat n),
Lemma Nxor_BVxor : forall n (bv bv' : Bvector n), Bv2N _ (BVxor _ bv bv') = N.lxor (Bv2N _ bv) (Bv2N _ bv').
Lemma Nand_BVand : forall n (bv bv' : Bvector n), Bv2N _ (BVand _ bv bv') = N.land (Bv2N _ bv) (Bv2N _ bv').
Lemma Zpower_pos_1_r x : Z.pow_pos x 1 = x.
Lemma Zpower_pos_1_l p : Z.pow_pos 1 p = 1.
Lemma Zpower_pos_0_l p : Z.pow_pos 0 p = 0.
Lemma Zpower_pos_pos x p : 0 < x -> 0 < Z.pow_pos x p.
Lemma Zpower_le_monotone_inv a b c : 1 < a -> 0 < b -> a^b <= a^c -> b <= c.
Lemma Zpower2_Psize n p : Zpos p < 2^(Z.of_nat n) <-> (Pos.size_nat p <= n)%nat.
Lemma Zpower_divide p q : 0 < q -> (p | p ^ q).
Lemma Int31_canonic : forall x y, phi x = phi y -> x = y.
Lemma ring_theory_switch_eq : forall A (R R':A->A->Prop) zero one add mul sub opp, (forall x y : A, R x y -> R' x y) -> ring_theory zero one add mul sub opp R -> ring_theory zero one add mul sub opp R'.
Lemma Int31Ring : ring_theory 0 1 add31 mul31 sub31 opp31 Logic.eq.
Lemma eqb31_eq : forall x y, eqb31 x y = true <-> x=y.
Lemma eqb31_correct : forall x y, eqb31 x y = true -> x=y.
Lemma eqb_eq : forall x y, eqb x y = true <-> E.eq x y.
Lemma eq_dec : forall x y, {E.eq x y}+{~E.eq x y}.
Lemma eqb_spec x y : reflect (x==y) (x =? y).
Lemma eqb_neq x y : (x =? y) = false <-> x ~= y.
Lemma eqb_refl x : (x =? x) = true.
Lemma eqb_sym x y : (x =? y) = (y =? x).
Lemma Fix_F_eq :   forall (x:A) (r:Acc R x),     F_sub x (fun (y:A|R y x) => Fix_F_sub (`y) (Acc_inv r (proj2_sig y))) = Fix_F_sub x r.
Lemma Fix_F_inv : forall (x:A) (r s:Acc R x), Fix_F_sub x r = Fix_F_sub x s.
Lemma Fix_eq : forall x:A, Fix_sub x = F_sub x (fun (y:A|R y x) => Fix_sub (proj1_sig y)).
Lemma fix_sub_eq :   forall x : A,     Fix_sub x =     let f_sub := F_sub in       f_sub x (fun (y : A | R y x) => Fix_sub (`y)).
Lemma measure_wf: well_founded MR.
Lemma F_unfold x r:   Fix_F_sub A R P f x r =   f (fun y => Fix_F_sub A R P f (proj1_sig y) (Acc_inv r (proj2_sig y))).
Lemma Fix_F_sub_rect   (Q: forall x, P x -> Type)   (inv: forall x: A,    (forall (y: A) (H: R y x) (a: Acc R y),       Q y (Fix_F_sub A R P f y a)) ->       forall (a: Acc R x),         Q x (f (fun y: {y: A | R y x} =>           Fix_F_sub A R P f (proj1_sig y) (Acc_inv a (proj2_sig y)))))   : forall x a, Q _ (Fix_F_sub A R P f x a).
Lemma eq_Fix_F_sub x (a a': Acc R x):   Fix_F_sub A R P f x a =   Fix_F_sub A R P f x a'.
Lemma Fix_sub_rect   (Q: forall x, P x -> Type)   (inv: forall     (x: A)     (H: forall (y: A), R y x -> Q y (Fix_sub A R Rwf P f y))     (a: Acc R x),       Q x (f (fun y: {y: A | R y x} => Fix_sub A R Rwf P f (proj1_sig y))))   : forall x, Q _ (Fix_sub A R Rwf P f x).
Program Lemma fix_sub_eq_ext :   forall (A : Type) (R : A -> A -> Prop) (Rwf : well_founded R)     (P : A -> Type)     (F_sub : forall x : A, (forall (y : A | R y x), P y) -> P x),     forall x : A,       Fix_sub A R Rwf P F_sub x =         F_sub x (fun (y : A | R y x) => Fix_sub A R Rwf P F_sub y).
Lemma half_aux_0 : half_aux 0 = (0,0).
Lemma half_aux_succ : forall x, half_aux (S x) = (S (snd (half_aux x)), fst (half_aux x)).
Lemma pow_0 : forall n, n^^0 == 1.
Lemma pow_succ : forall n m, n^^(S m) == n*(n^^m).
Lemma log_good_step : forall n h1 h2, (forall m, m < n -> h1 m == h2 m) -> (if n << 2 then 0 else S (h1 (half n))) == (if n << 2 then 0 else S (h2 (half n))).
Lemma not_included_empty_Inhabited :   forall A:Ensemble U, ~ Included U A (Empty_set U) -> Inhabited U A.
Lemma not_empty_Inhabited :   forall A:Ensemble U, A <> Empty_set U -> Inhabited U A.
Lemma Inhabited_Setminus :   forall X Y:Ensemble U,     Included U X Y -> ~ Included U Y X -> Inhabited U (Setminus U Y X).
Lemma Strict_super_set_contains_new_element :   forall X Y:Ensemble U,     Included U X Y -> X <> Y -> Inhabited U (Setminus U Y X).
Lemma Subtract_intro :   forall (A:Ensemble U) (x y:U), In U A y -> x <> y -> In U (Subtract U A x) y.
Lemma Subtract_inv :   forall (A:Ensemble U) (x y:U), In U (Subtract U A x) y -> In U A y /\ x <> y.
Lemma Included_Strict_Included :   forall X Y:Ensemble U, Included U X Y -> Strict_Included U X Y \/ X = Y.
Lemma Strict_Included_inv :   forall X Y:Ensemble U,     Strict_Included U X Y -> Included U X Y /\ Inhabited U (Setminus U Y X).
Lemma not_SIncl_empty :   forall X:Ensemble U, ~ Strict_Included U X (Empty_set U).
Lemma Complement_Complement :   forall A:Ensemble U, Complement U (Complement U A) = A.
Lemma Z_div_mod_POS : forall b:Z,   b > 0 ->   forall a:positive,     let (q, r) := Z.pos_div_eucl a b in Zpos a = b * q + r /\ 0 <= r < b.
Lemma Remainder_equiv : forall r b, Remainder r b <-> Remainder_alt r b.
Lemma Z_mod_remainder a b : b<>0 -> Remainder (a mod b) b.
Lemma Z_mod_lt a b : b > 0 -> 0 <= a mod b < b.
Lemma Z_mod_neg a b : b < 0 -> b < a mod b <= 0.
Lemma Z_div_mod_eq a b : b > 0 -> a = b*(a/b) + (a mod b).
Lemma Zmod_eq_full a b : b<>0 -> a mod b = a - (a/b)*b.
Lemma Zmod_eq a b : b>0 -> a mod b = a - (a/b)*b.
Lemma Zmod_0_l: forall a, 0 mod a = 0.
Lemma Zmod_0_r: forall a, a mod 0 = 0.
Lemma Zdiv_0_l: forall a, 0/a = 0.
Lemma Zdiv_0_r: forall a, a/0 = 0.
Lemma Zmod_1_r: forall a, a mod 1 = 0.
Lemma Zdiv_1_r: forall a, a/1 = a.
Lemma Zdiv_1_l: forall a, 1 < a -> 1/a = 0.
Lemma Zmod_1_l: forall a, 1 < a ->  1 mod a = 1.
Lemma Z_div_same_full : forall a:Z, a<>0 -> a/a = 1.
Lemma Z_mod_same_full : forall a, a mod a = 0.
Lemma Z_mod_mult : forall a b, (a*b) mod b = 0.
Lemma Z_div_mult_full : forall a b:Z, b <> 0 -> (a*b)/b = a.
Lemma Z_div_pos: forall a b, b > 0 -> 0 <= a -> 0 <= a/b.
Lemma Z_div_ge0: forall a b, b > 0 -> a >= 0 -> a/b >=0.
Lemma Z_div_lt : forall a b:Z, b >= 2 -> a > 0 -> a/b < a.
Lemma Z_div_ge : forall a b c:Z, c > 0 -> a >= b -> a/c >= b/c.
Lemma Z_div_le : forall a b c:Z, c > 0 -> a <= b -> a/c <= b/c.
Lemma Z_mult_div_ge : forall a b:Z, b > 0 -> b*(a/b) <= a.
Lemma Z_mult_div_ge_neg : forall a b:Z, b < 0 -> b*(a/b) >= a.
Lemma Z_div_exact_full_1 : forall a b:Z, a = b*(a/b) -> a mod b = 0.
Lemma Z_div_exact_full_2 : forall a b:Z, b <> 0 -> a mod b = 0 -> a = b*(a/b).
Lemma Zdiv_le_compat_l: forall p q r, 0 <= p -> 0 < q < r ->   p / r <= p / q.
Lemma Z_mod_plus_full : forall a b c:Z, (a + b * c) mod c = a mod c.
Lemma Z_div_plus_full : forall a b c:Z, c <> 0 -> (a + b * c) / c = a / c + b.
Lemma Zdiv_opp_opp : forall a b:Z, (-a)/(-b) = a/b.
Lemma Zmod_opp_opp : forall a b:Z, (-a) mod (-b) = - (a mod b).
Lemma Z_mod_zero_opp_full : forall a b:Z, a mod b = 0 -> (-a) mod b = 0.
Lemma Z_mod_nz_opp_full : forall a b:Z, a mod b <> 0 -> (-a) mod b = b - (a mod b).
Lemma Z_mod_zero_opp_r : forall a b:Z, a mod b = 0 -> a mod (-b) = 0.
Lemma Z_mod_nz_opp_r : forall a b:Z, a mod b <> 0 -> a mod (-b) = (a mod b) - b.
Lemma Z_div_zero_opp_full : forall a b:Z, a mod b = 0 -> (-a)/b = -(a/b).
Lemma Z_div_nz_opp_full : forall a b:Z, a mod b <> 0 -> (-a)/b = -(a/b)-1.
Lemma Z_div_zero_opp_r : forall a b:Z, a mod b = 0 -> a/(-b) = -(a/b).
Lemma Z_div_nz_opp_r : forall a b:Z, a mod b <> 0 -> a/(-b) = -(a/b)-1.
Lemma  Zdiv_mult_cancel_r : forall a b c:Z, c <> 0 -> (a*c)/(b*c) = a/b.
Lemma Zdiv_mult_cancel_l : forall a b c:Z, c<>0 -> (c*a)/(c*b) = a/b.
Lemma Zmult_mod_distr_l: forall a b c, (c*a) mod (c*b) = c * (a mod b).
Lemma Zmult_mod_distr_r: forall a b c, (a*c) mod (b*c) = (a mod b) * c.
Lemma Zplus_mod_idemp_l: forall a b n, (a mod n + b) mod n = (a + b) mod n.
Lemma Zplus_mod_idemp_r: forall a b n, (b + a mod n) mod n = (b + a) mod n.
Lemma Zminus_mod_idemp_l: forall a b n, (a mod n - b) mod n = (a - b) mod n.
Lemma Zminus_mod_idemp_r: forall a b n, (a - b mod n) mod n = (a - b) mod n.
Lemma Zmult_mod_idemp_l: forall a b n, (a mod n * b) mod n = (a * b) mod n.
Lemma Zmult_mod_idemp_r: forall a b n, (b * (a mod n)) mod n = (b * a) mod n.
Lemma eqm_refl : forall a, a == a.
Lemma eqm_sym : forall a b, a == b -> b == a.
Lemma eqm_trans : forall a b c, a == b -> b == c -> a == c.
Lemma Zmod_eqm : forall a, (a mod N) == a.
Lemma Zdiv_Zdiv : forall a b c, 0<=b -> 0<=c -> (a/b)/c = a/(b*c).
Lemma Zmod_divides : forall a b, b<>0 -> (a mod b = 0 <-> exists c, a = b*c).
Lemma Zdiv2_div : forall a, Z.div2 a = a/2.
Lemma Zmod_odd : forall a, a mod 2 = if Z.odd a then 1 else 0.
Lemma Zmod_even : forall a, a mod 2 = if Z.even a then 0 else 1.
Lemma Zodd_mod : forall a, Z.odd a = Zeq_bool (a mod 2) 1.
Lemma Zeven_mod : forall a, Z.even a = Zeq_bool (a mod 2) 0.
Lemma Z_mod_same : forall a, a > 0 -> a mod a = 0.
Lemma Z_div_same : forall a, a > 0 -> a/a = 1.
Lemma Z_div_plus : forall a b c:Z, c > 0 -> (a + b * c) / c = a / c + b.
Lemma Z_div_mult : forall a b:Z, b > 0 -> (a*b)/b = a.
Lemma Z_mod_plus : forall a b c:Z, c > 0 -> (a + b * c) mod c = a mod c.
Lemma Z_div_exact_1 : forall a b:Z, b > 0 -> a = b*(a/b) -> a mod b = 0.
Lemma Z_div_exact_2 : forall a b:Z, b > 0 -> a mod b = 0 -> a = b*(a/b).
Lemma Z_mod_zero_opp : forall a b:Z, b > 0 -> a mod b = 0 -> (-a) mod b = 0.
Lemma div_Zdiv (n m: nat): m <> O -> Z.of_nat (n / m) = Z.of_nat n / Z.of_nat m.
Lemma mod_Zmod (n m: nat): m <> O -> Z.of_nat (n mod m) = (Z.of_nat n) mod (Z.of_nat m).
Lemma FTCN_step1 : forall (f:Differential) (a b:R),   Newton_integrable (fun x:R => derive_pt f x (cond_diff f x)) a b.
Lemma FTC_Newton : forall (f:Differential) (a b:R),   NewtonInt (fun x:R => derive_pt f x (cond_diff f x)) a b   (FTCN_step1 f a b) = f b - f a.
Lemma NewtonInt_P1 : forall (f:R -> R) (a:R), Newton_integrable f a a.
Lemma NewtonInt_P2 : forall (f:R -> R) (a:R), NewtonInt f a a (NewtonInt_P1 f a) = 0.
Lemma NewtonInt_P3 : forall (f:R -> R) (a b:R) (X:Newton_integrable f a b),   Newton_integrable f b a.
Lemma NewtonInt_P4 : forall (f:R -> R) (a b:R) (pr:Newton_integrable f a b),   NewtonInt f a b pr = - NewtonInt f b a (NewtonInt_P3 f a b pr).
Lemma NewtonInt_P5 : forall (f g:R -> R) (l a b:R),   Newton_integrable f a b ->   Newton_integrable g a b ->   Newton_integrable (fun x:R => l * f x + g x) a b.
Lemma antiderivative_P1 : forall (f g F G:R -> R) (l a b:R),   antiderivative f F a b ->   antiderivative g G a b ->   antiderivative (fun x:R => l * f x + g x) (fun x:R => l * F x + G x) a b.
Lemma NewtonInt_P6 : forall (f g:R -> R) (l a b:R) (pr1:Newton_integrable f a b)   (pr2:Newton_integrable g a b),   NewtonInt (fun x:R => l * f x + g x) a b (NewtonInt_P5 f g l a b pr1 pr2) =   l * NewtonInt f a b pr1 + NewtonInt g a b pr2.
Lemma antiderivative_P2 : forall (f F0 F1:R -> R) (a b c:R),   antiderivative f F0 a b ->   antiderivative f F1 b c ->   antiderivative f   (fun x:R =>     match Rle_dec x b with       | left _ => F0 x       | right _ => F1 x + (F0 b - F1 b)     end) a c.
Lemma antiderivative_P3 : forall (f F0 F1:R -> R) (a b c:R),   antiderivative f F0 a b ->   antiderivative f F1 c b ->   antiderivative f F1 c a \/ antiderivative f F0 a c.
Lemma antiderivative_P4 : forall (f F0 F1:R -> R) (a b c:R),   antiderivative f F0 a b ->   antiderivative f F1 a c ->   antiderivative f F1 b c \/ antiderivative f F0 c b.
Lemma NewtonInt_P7 : forall (f:R -> R) (a b c:R),   a < b ->   b < c ->   Newton_integrable f a b ->   Newton_integrable f b c -> Newton_integrable f a c.
Lemma NewtonInt_P8 : forall (f:R -> R) (a b c:R),   Newton_integrable f a b ->   Newton_integrable f b c -> Newton_integrable f a c.
Lemma NewtonInt_P9 : forall (f:R -> R) (a b c:R) (pr1:Newton_integrable f a b)   (pr2:Newton_integrable f b c),   NewtonInt f a c (NewtonInt_P8 f a b c pr1 pr2) =   NewtonInt f a b pr1 + NewtonInt f b c pr2.
Lemma In_eq : forall l x y, eq x y -> In x l -> In y l.
Lemma ListIn_In : forall l x, List.In x l -> In x l.
Lemma Inf_lt : forall l x y, lt x y -> Inf y l -> Inf x l.
Lemma Inf_eq : forall l x y, eq x y -> Inf y l -> Inf x l.
Lemma Sort_Inf_In : forall l x a, Sort l -> Inf a l -> In x l -> lt a x.
Lemma ListIn_Inf : forall l x, (forall y, List.In y l -> lt x y) -> Inf x l.
Lemma In_Inf : forall l x, (forall y, In y l -> lt x y) -> Inf x l.
Lemma Inf_alt : forall l x, Sort l -> (Inf x l <-> (forall y, In y l -> lt x y)).
Lemma Sort_NoDup : forall l, Sort l -> NoDup l.
Lemma ltk_not_eqk : forall e e', ltk e e' -> ~ eqk e e'.
Lemma ltk_not_eqke : forall e e', ltk e e' -> ~eqke e e'.
Lemma InA_eqke_eqk :    forall x m, InA eqke x m -> InA eqk x m.
Lemma In_alt : forall k l, In k l <-> exists e, InA eqk (k,e) l.
Lemma In_alt2 : forall k l, In k l <-> Exists (fun p => eq k (fst p)) l.
Lemma In_nil : forall k, In k nil <-> False.
Lemma In_cons : forall k p l,  In k (p::l) <-> eq k (fst p) \/ In k l.
Lemma MapsTo_eq : forall l x y e, eq x y -> MapsTo x e l -> MapsTo y e l.
Lemma In_eq : forall l x y, eq x y -> In x l -> In y l.
Lemma Inf_eq : forall l x x', eqk x x' -> Inf x' l -> Inf x l.
Lemma Inf_lt : forall l x x', ltk x x' -> Inf x' l -> Inf x l.
Lemma Sort_Inf_In :     forall l p q, Sort l -> Inf q l -> InA eqk p l -> ltk q p.
Lemma Sort_Inf_NotIn :     forall l k e, Sort l -> Inf (k,e) l ->  ~In k l.
Lemma Sort_NoDupA: forall l, Sort l -> NoDupA eqk l.
Lemma Sort_In_cons_1 : forall e l e', Sort (e::l) -> InA eqk e' l -> ltk e e'.
Lemma Sort_In_cons_2 : forall l e e', Sort (e::l) -> InA eqk e' (e::l) ->     ltk e e' \/ eqk e e'.
Lemma Sort_In_cons_3 :   forall x l k e, Sort ((k,e)::l) -> In x l -> ~eq x k.
Lemma In_inv : forall k k' e l, In k ((k',e) :: l) -> eq k k' \/ In k l.
Lemma In_inv_2 : forall k k' e e' l,     InA eqk (k, e) ((k', e') :: l) -> ~ eq k k' -> InA eqk (k, e) l.
Lemma In_inv_3 : forall x x' l,     InA eqke x (x' :: l) -> ~ eqk x x' -> InA eqke x l.
Lemma plus_n_O : forall n:nat, n = n + 0.
Lemma plus_O_n : forall n:nat, 0 + n = n.
Lemma plus_n_Sm : forall n m:nat, S (n + m) = n + S m.
Lemma plus_Sn_m : forall n m:nat, S n + m = S (n + m).
Lemma mult_n_O : forall n:nat, 0 = n * 0.
Lemma mult_n_Sm : forall n m:nat, n * m + n = n * S m.
Lemma nat_iter_succ_r n {A} (f:A->A) (x:A) : nat_iter (S n) f x = nat_iter n f (f x).
Lemma floor_gt0 : forall p:positive, floor p > 0.
Lemma floor_ok : forall p:positive, floor p <= Zpos p < 2 * floor p.
Lemma Zcase_sign : forall (n:Z) (P:Prop), (n = 0 -> P) -> (n > 0 -> P) -> (n < 0 -> P) -> P.
Lemma sqr_pos n : n * n >= 0.
Lemma Zlength_correct l : Zlength l = Z.of_nat (length l).
Lemma Zlength_nil : Zlength (A:=A) nil = 0.
Lemma Zlength_cons (x:A) l : Zlength (x :: l) = Z.succ (Zlength l).
Lemma Zlength_nil_inv l : Zlength l = 0 -> l = nil.
Lemma list_contents_app : forall l m:list A,   meq (list_contents (l ++ m)) (munion (list_contents l) (list_contents m)).
Lemma permut_refl : forall l:list A, permutation l l.
Lemma permut_sym : forall l1 l2 : list A, permutation l1 l2 -> permutation l2 l1.
Lemma permut_trans : forall l m n:list A, permutation l m -> permutation m n -> permutation l n.
Lemma permut_cons_eq : forall l m:list A,   permutation l m -> forall a a', eqA a a' -> permutation (a :: l) (a' :: m).
Lemma permut_cons : forall l m:list A,   permutation l m -> forall a:A, permutation (a :: l) (a :: m).
Lemma permut_app : forall l l' m m':list A,   permutation l l' -> permutation m m' -> permutation (l ++ m) (l' ++ m').
Lemma permut_add_inside_eq : forall a a' l1 l2 l3 l4, eqA a a' ->   permutation (l1 ++ l2) (l3 ++ l4) ->   permutation (l1 ++ a :: l2) (l3 ++ a' :: l4).
Lemma permut_add_inside : forall a l1 l2 l3 l4,   permutation (l1 ++ l2) (l3 ++ l4) ->   permutation (l1 ++ a :: l2) (l3 ++ a :: l4).
Lemma permut_add_cons_inside_eq : forall a a' l l1 l2, eqA a a' ->   permutation l (l1 ++ l2) ->   permutation (a :: l) (l1 ++ a' :: l2).
Lemma permut_add_cons_inside : forall a l l1 l2,   permutation l (l1 ++ l2) ->   permutation (a :: l) (l1 ++ a :: l2).
Lemma permut_middle : forall (l m:list A) (a:A), permutation (a :: l ++ m) (l ++ a :: m).
Lemma permut_sym_app : forall l1 l2, permutation (l1 ++ l2) (l2 ++ l1).
Lemma permut_rev : forall l, permutation l (rev l).
Lemma permut_conv_inv : forall e l1 l2, permutation (e :: l1) (e :: l2) -> permutation l1 l2.
Lemma permut_app_inv1 : forall l l1 l2, permutation (l1 ++ l) (l2 ++ l) -> permutation l1 l2.
Lemma permut_app_inv2 : forall l l1 l2, permutation (l ++ l1) (l ++ l2) -> permutation l1 l2.
Lemma permut_remove_hd_eq : forall l l1 l2 a b, eqA a b ->   permutation (a :: l) (l1 ++ b :: l2) -> permutation l (l1 ++ l2).
Lemma permut_remove_hd : forall l l1 l2 a,   permutation (a :: l) (l1 ++ a :: l2) -> permutation l (l1 ++ l2).
Lemma multiplicity_InA : forall l a, InA eqA a l <-> 0 < multiplicity (list_contents l) a.
Lemma multiplicity_InA_O : forall l a, ~ InA eqA a l -> multiplicity (list_contents l) a = 0.
Lemma multiplicity_InA_S : forall l a, InA eqA a l -> multiplicity (list_contents l) a >= 1.
Lemma multiplicity_NoDupA : forall l, NoDupA eqA l <-> (forall a, multiplicity (list_contents l) a <= 1).
Lemma permut_InA_InA : forall l1 l2 e, permutation l1 l2 -> InA eqA e l1 -> InA eqA e l2.
Lemma permut_cons_InA : forall l1 l2 e, permutation (e :: l1) l2 -> InA eqA e l2.
Lemma permut_nil : forall l, permutation l [] -> l = [].
Lemma permut_length_1: forall a b, permutation [a] [b] -> eqA a b.
Lemma permut_length_2 : forall a1 b1 a2 b2, permutation [a1; b1] [a2; b2] ->   (eqA a1 a2) /\ (eqA b1 b2) \/ (eqA a1 b2) /\ (eqA a2 b1).
Lemma permut_length : forall l1 l2, permutation l1 l2 -> length l1 = length l2.
Lemma NoDupA_equivlistA_permut : forall l l', NoDupA eqA l -> NoDupA eqA l' ->   equivlistA eqA l l' -> permutation l l'.
Lemma permut_map : forall f,   (Proper (eqA==>eqB) f) ->   forall l1 l2, permutation _ eqA_dec l1 l2 ->     permutation _ eqB_dec (map f l1) (map f l2).
Lemma Permutation_impl_permutation : forall l l', Permutation l l' -> permutation _ eqA_dec l l'.
Lemma permut_eqA : forall l l', Forall2 eqA l l' -> permutation _ eqA_dec l l'.
Lemma permutation_Permutation : forall l l', permutation _ eqA_dec l l' <-> exists l'', Permutation l l'' /\ Forall2 eqA l'' l'.

\section{Recurrent Term Clustering}\label{sec:lemmaclustering}

The previous section contained a method of defining significant features to be used in Coq term clustering.
It remains to define the functions
%Machine-learning algorithms usually work with vectors of numerical features~\cite{Bishop}; 
%therefore, it is necessary to define a function to assign numerical values to non-numerical 
%features -- as in our case with functions 
 $[.]_{term}$ and $[.]_{type}$ that will determine feature values.
These functions must be sensitive to the structure of terms, assigning close values 
to similar terms and more distant values to unrelated terms. %This is the reason to have $\mathbb{Q}^-$
%as the codomain of the function $[.]_{constr}$, and $\mathbb{Q}^+$ as the codomain of the function $[.]_{term}$.
%similarly with the value $-1$ of the second component of the triples associated with constructors nodes and the codomain of $[.]_{type}$ --
%this will unambiguously distinguish the values assigned to constructors nodes and term-type nodes. 

%On the contrary to constructors, we do not know in advance all the terms that can occur in a development -- new terms can be defined by the user. Then, 
%a predefined function is not suitable, and we need functions adaptive to the introduction of new terms or types.
%The term component of a term-type node is a variable, a sort or a global name; 
Given a term $t$ which we need to represent by $300$ feature values,
the values of $[.]_{term}$
for  variables  and pre-defined sorts in $t$ are fixed, but the values of other --- user-defined --- terms $t_1, \ldots t_n$ contained in $t$ are obtained based
on the structures of their definitions, and %. Since global names must be defined 
%in the library to use them, we can group their definitions (that are terms) 
using \emph{clustering}~\cite{Bishop} to assign representative numbers. 
It is the nature of the functional language to have terms depending on other terms, and the clustering process is 
repeated recursively to include all the necessary definitions.
Declarations and definitions of $t_1, \ldots \ t_n$ can themselves contain other user-defined terms, for which we need to run clustering to determine their feature values, and so on.
 We call this method \emph{recurrent clustering}: the action of $[.]_{term}$ has to be adapted to the current libraries and the current stage of the proof. % process 
%will be used to assign values to global names -- 
It works similarly for the function $[.]_{type}$.

% 
% will assign values to the term components of the term-type nodes of ML4PG term trees;
% and these terms components are necessarily defined in Coq -- remember that the term components of term-type nodes
% are variables, sorts and global names. These term definitions can themselves be grouped against other term definitions appearing in the library using 
% \emph{clustering}~\cite{Bishop}; and the process can be repeated recursively to include all the necessary terms of the library. 
% These groups of terms will be used to define our function $[.]_{term}$; and this is how the feature extraction
% becomes part of a \emph{recurrent clustering} process.

Thus, clustering and its statistical parameters play a role in the numerical conversion of Coq terms into feature vectors.
The details are as follows.
Clustering algorithms % is a set of machine-learning techniques that 
divide data into $n$ groups of similar objects (called \emph{clusters}), where the value of $n$
is a learning parameter provided by the user. In ML4PG, the value of $n$ is automatically computed depending on the number 
of objects to cluster using the formula provided in~\cite{lpar13}. In addition to groups of similar objects, clustering provides 
a \emph{proximity value} (ranging from $0$ to $1$) to every object in a cluster to indicate the certainty of the given example belonging 
to the cluster. The clusters and the proximity values are used in the definitions of $[.]_{term}$ and $[.]_{type}$ below.


\begin{definition}\label{def:funterm}
Given a term  \lstinline?t? of a Coq library, the functions $[.]_{term}$ and $[.]_{type}$ are defined respectively for the term component \lstinline?t1?
and the type component \lstinline?t2? of every term-type node in the ML4PG term tree of \lstinline?t? as follows:

$-$ $[\texttt{t1}]_{term/type}=i$, if \lstinline?t1? is the $i$th distinct variable in \lstinline?t?. 

$-$ $[\texttt{t1}]_{term/type}=100+\sum_{j=1}^i\frac{1}{10\times 2^{j-1}}$, if \lstinline?t1? is the $i$th element of the set\\ $\{\texttt{Set},\texttt{Prop},\texttt{Type(0)},
\texttt{Type(1)}, \texttt{Type(2)},\ldots\}$.
 
$-$ $[\texttt{t1}]_{term}=200+2\times j + p$, where $C_j$ is a cluster obtained as a result of clustering the term definition of the global names introduced before \lstinline?t?,
$\texttt{t1}\in C_j$ and $p$ is the proximity value of $\texttt{t1}$ in $C_j$. 

%$-$ $[\texttt{t2}]_{type}=i$, if \lstinline?t2? is the $i$th distinct variable in \lstinline?t?. 

%$-$ $[\texttt{t2}]_{type}=100+\sum_{j=1}^i\frac{1}{10\times 2^{j-1}}$, if \lstinline?t2? is the $i$th element of the set\\ $\{\texttt{Set},\texttt{Prop},\texttt{Type(0)},
%\texttt{Type(1)}, \texttt{Type(2)},\ldots\}$.
 
$-$ $[\texttt{t2}]_{type}=200+2\times j + p$, where $C_j$ is a cluster obtained as a result of clustering the term \lstinline?t2? with the rest of the type components of 
the terms of the library, $\texttt{t2}\in C_j$ and $p$ is the proximity value of $\texttt{t2}$ in $C_j$. 
\end{definition}


Note the recurrent nature of the functions $[.]_{term}$ and $[.]_{type}$ with numbering the components of \lstinline?t? depending on the term definitions
and types included in the library. In addition, the function $[.]_{term}$ internally uses the function $[.]_{type}$ in the recurrent clustering 
process and \emph{vice versa}; however, terms and types are not mixed during the clustering process. The motivation behind the various parameters
of Definition~\ref{def:funterm} is as follows:

$-$ Variables. The variable encoding reflects the number and order of unique variables appearing in the term, note its correspondence to the De Bruijn indexes.

$-$ Sorts. In the formula for sorts, $\sum_{j=1}^i\frac{1}{10\times 2^{j-1}}$ reflects the close relation among sorts, and 
$100$ is used to  distinguish sorts from variables and names. 
 %(it is unusual to have a term with $100$ or more variables) 

$-$ Finally, the formula $200+2\times j + p$ assigns $[\texttt{t1}]$ (or $[\texttt{t2}]$) a value within $[200+2\times j,200+2\times j+1]$ depending on the
statistical proximity of \lstinline?t1? (or \lstinline?t2?) in cluster $j$. Thus, elements of the same cluster have closer values comparing to the values 
assigned to elements of other clusters, sorts, and variables. The formula is the same for the functions $[.]_{term}$ and $[.]_{type}$ (but it is computed with different 
clusters); then, a term and a type component can 
have the same value. However, they will never occur in the same cell of the term tree matrices (cf. Definition~\ref{df:matrix}); thus, clustering algorithms will 
distinguish them since they will always compare terms with terms and types with types.

Once the numerical values of the components of ML4PG term tree matrices have been computed, we can cluster these matrices and 
obtain groups of similar terms. In particular, ML4PG can be used to cluster definitions, types and lemma 
statements. These clusters in turn are used to define a new function $[.]_{stat}$. The function $[.]_{stat}$ assigns numbers using the 
formula $[l]_{stat}=2\times j + p$ where $C_j$ is a cluster such that $l\in C_j$ and $p$ is the proximity value of $l$ in $C_j$. This process assigns 
closer values to statements in the same cluster, and more distant numbers across groups. This function will be used in the following section.





We finish this section with some clusters discovered in the basic infrastructure of SSReflect 
library;
% From version 1.5, the SSReflect library can be downloaded independently from the MathComp library containing the proof of the Feit-Thompson theorem~\cite{FTT}. 
% Using the method presented throughout this section,
we analyse the similarities among the 457 definitions  %and theorem statements (1403 theorems)
of this library. 

\begin{example}
These are some of the clusters obtained in the basic infrastructure of the SSReflect library (the total number of clusters is 91).
Note that this example of cluster search is not goal-oriented, -- ML4PG offers the user to consider term similarities, of which the user may 
not be aware.

\noindent - Cluster 1:

{\scriptsize \begin{lstlisting}
  - Fixpoint eqn (m n : nat) {struct m} :=
       match m, n with | 0, 0 => true | m'.+1, n'.+1 => eqn m' n' | _, _ => false end.
  - Fixpoint eqseq (s1 s2 : seq T) {struct s2} :=
       match s1, s2 with 
       | [::], [::] => true | x1 :: s1', x2 :: s2' => (x1 == x2) && eqseq s1' s2' 
       | _, _ => false end.     
       
\end{lstlisting}}
    
\noindent - Cluster 2:

{\scriptsize 
\begin{lstlisting}
  - Fixpoint drop n s {struct s} := 
       match s, n with | _ :: s', n'.+1 => drop n' s' | _, _ => s end.
  - Fixpoint take n s {struct s} :=
       match s, n with | x :: s', n'.+1 => x :: take n' s' | _, _ => [::] end.
\end{lstlisting}}

\noindent - Cluster 3:

{\scriptsize 
\begin{lstlisting}
  - Definition flatten := foldr cat (Nil T).
  - Definition sumn := foldr addn 0.
\end{lstlisting}}
 
\end{example}

The first cluster contains the definitions of equality for natural numbers and lists -- showing that 
ML4PG can spot similarities across libraries. The second cluster discovers the relation between \lstinline?take? (takes the first $n$ elements of 
a list) and \lstinline?drop? (drops the first $n$ elements of a list) -- several clusters are related to these ``trivial'' relation among functions.
At first sight, the last pattern seems to belong to the category of ``trivial'' patterns, but this cluster does not include other definitions that use 
\lstinline?foldr? (like \lstinline?Definition allpairs s t := foldr (fun x => cat (map (f x) t)) [::] s.?); 
the reason is the recurrent term clustering that assigns close values to the functions \lstinline?cat? (concatenation of lists) and \lstinline?addn? (sum
of natural numbers) since they belong to the same cluster. It is worth remarking that all these clusters are discovered automatically based on the
statistical features captured from terms.


ML4PG can also cluster the SSReflect definitions relative to a concrete definition. Those clusters can speed-up the proof development in two different
ways. Clustering can discover that a user-defined function was already available in SSReflect; in that case, the user can use the SSReflect definition and all its background
theory instead of defining it from scratch. If user's function was not previously defined (or ML4PG fails to find it), clustering provides definitions with similar terms, types
and structure; hence, the proofs of the theorems about those functions are likely to follow a similar pattern to the theorems about the user-defined functions. 






 






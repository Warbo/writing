Our approach to scaling up \qspec{} takes inspiration from two sources. The
first is relevance filtering, which makes expensive algorithms used in theorem
proving more practical by limiting the size of their inputs. We describe this
approach in more details in \S \ref{sec:relevance}. Relevance filtering is a
practical tool which has existing applications in software, such as the
\emph{Sledgehammer} component of the Isabelle/HOL theorem prover.

Despite the idea's promise, we cannot simply invoke existing relevance filter
algorithms in our theory exploration setting. The reason is that relevance
filtering is a supervised learning method, i.e. it would require a distinguished
expression to compare everything against. Theory exploration does not have such
a distinguished expression; instead, we are interested in relationships between
\emph{any} terms generated from a signature, and hence we must consider the
relevance of \emph{all terms} to \emph{all other terms}.

A natural fit for this task is \emph{clustering}, which attempts to group
similar inputs together in an unsupervised way. Based on their success in
discovering relationships and patterns between expressions in Coq and ACL2 (in
the ML4PG and ACL2(ml) tools respectively), we hypothesise that clustering
methods can fulfil the role of relevance filters for theory exploration:
intelligently breaking up large signatures into smaller ones more amenable to
brute force enumeration, such that related expressions are explored together.

\subsection{K-Means}

We use the Weka tool to perform k-means clustering
\cite{Holmes.Donkin.Witten:1994}, since we are more concerned with the
application of feature extraction to Haskell and its use in theory exploration,
rather than precise tuning of learning algorithms. Since k-means is a standard
method, there are many other implementations available. More interestingly,
there are many other clustering algorithms we could use, such as
\emph{expectation maximisation} \footnote{In fact, k-means is very similar to
  expectation-maximisation, as it alternates between an \emph{expectation step}
  (finding the mean value of each cluster) and a \emph{maximisation step}
  (assigning points to the cluster they're most similar to; or alternatively,
  \emph{minimising} the distance of each point to the centre of its cluster, as
  per equation \ref{eq:kmeansobjective}).}, but experiments with ML4PG have
shown little difference in their results; in effect, the quality of our features
is the bottleneck to learning, so there is no reason to avoid a fast algorithm
like k-means.

In any case there are many conservative improvements to the standard k-means
algorithm, which could be applied to our setup. For example, a more efficient
approach like \emph{yinyang k-means} \cite{conf/icml/DingZSMM15} could make
larger input sizes more practical to cluster, especially since recurrent
clustering invokes k-means many times. The \emph{k-means++} approach
\cite{arthur2007k, bahmani2012scalable} can be used to more carefully select
the ``seed'' values for the first timestep, and the \emph{x-means} algorithm
\cite{pelleg2000x} is able to estimate how many clusters to use (our
\emph{final} clusters should be tuned to maximise the performance of the
subsequent theory exploration step, but x-means could still be useful in the
recurrent clustering steps).

\subsubsection{K-Means}
\label{sec:kmeans}

Clustering is an unsupervised machine learning task for grouping $n$ data points
using a similarity metric. There are many variations on this theme, but in our
case we make the following choices:

\begin{itemize}
\item For simplicity, we use the ``rule of thumb'' given in
  \cite[pp. 365]{mardia1979multivariate} to fix the number of clusters at
  $k = \lceil \sqrt{\frac{n}{2}} \rceil$.
\item Data points will be $d$-dimensional feature vectors, as defined above.
\item We will use euclidean distance (denoted $e$) as our similarity metric.
\item We will use \emph{k-means} clustering, implemented by Lloyd's algorithm
  \cite{lloyd1982least}.
\end{itemize}

This is a standard setup, supported by off-the-shelf tools; in particular we use
the implementation provided by Weka \cite{Holmes.Donkin.Witten:1994}, due to
its use by ML4PG, which makes our results more easily comparable.

Since k-means is iterative, we will use function notation to denote time steps,
so $x(t)$ denotes the value of $x$ at time $t$. We denote the clusters as $C^1$
to $C^k$. As the name suggests, k-means uses the mean value of each cluster,
which we denote as $\vect{m}^1$ to $\vect{m}^k$, hence:

\begin{equation*}
  m^i_j(t) = \mean{C^i_j}(t) = \frac{\sum_{\vect{x} \in C^i(t)} x_j}{|C^i(t)|} \quad \text{for $t > 0$}
\end{equation*}

Before k-means starts, we must choose \emph{seed} values for
$\vect{m}^i(0)$. Many methods have been proposed for choosing these values
\cite{arthur2007k}. For simplicity, we will choose values randomly from our
data set $S$; this is known as the Forgy method.

The elements of each cluster $C^i(t)$ are those data points closest to the mean
value at the previous time step:

\begin{equation*}
  C^i(t) = \{ \vect{x} \in S \mid i = \argmin\limits_j e(\vect{x}, \vect{m}^j(t-1)) \} \quad \text{for $t > 0$}
\end{equation*}

As $t$ increases, the clusters $C^i$ move from their initial location around the
``seeds'', to converge on a local minimum of the ``within-cluster sum of squared
error'' objective:

\begin{equation} \label{eq:kmeansobjective}
  \argmin\limits_C \sum_{i=1}^k \sum_{\vect{x} \in C^i} e(\vect{x}, \vect{m}^i)^2
\end{equation}

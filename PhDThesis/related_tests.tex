\subsection{Tests} \label{sec:tests}

Since we are working in the domain of Haskell programs, an abundant source of
statements are available in the form of \emph{tests}. For manually-written
tests, the effort required to write them implies that they must be of some
interest to their author. Many forms of test are \emph{not} suitable for our
purposes, such as \emph{unit tests} which are always trivially provable by
$\beta$-reduction; or \emph{integration tests}, which depend on the behaviour of
the external environment. One reason to study Haskell is its widespread use of
\emph{property checking}, which does give us useful data. Many Haskell property
checkers exist, based on random testing (\textsc{QuickCheck}
\cite{claessen2011quickcheck} and \textsc{SmartCheck}
\cite{pike2014smartcheck}), enumeration (\textsc{SmallCheck}
\cite{runciman2008smallcheck}), observation (\textsc{Lazy SmallCheck}
\cite{reich2013advances}) and logic programming (\textsc{SparseCheck}
\cite{sparsecheck}).

Thankfully the major differences between these systems are in the way they
instantiate test arguments; their representations of properties are largely the
same (modulo renaming of functions and types).

Here we consider the 10 most-downloaded packages from \textsc{Hackage} (as of
2015-10-30) which have property tests; these are \texttt{warp}, \texttt{aeson},
\texttt{text}, \texttt{lens}, \texttt{conduit}, \texttt{pandoc},
\texttt{attoparsec}, \texttt{scientific}, \texttt{yesod-core} and
\texttt{blaze-html}.

% TODO: Analysis
